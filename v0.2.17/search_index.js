var documenterSearchIndex = {"docs":
[{"location":"man/input_files/#Reading-input-files","page":"Input files","title":"Reading input files","text":"","category":"section"},{"location":"man/input_files/","page":"Input files","title":"Input files","text":"It is also possible to read cases that have been set up in MRST (see setup_case_from_mrst and simulate_mrst_case) or from .DATA files (see parse_data_file and simulate_data_file)","category":"page"},{"location":"man/input_files/#MAT-files-from-the-Matlab-Reservoir-Simulation-Toolbox-(MRST)","page":"Input files","title":"MAT-files from the Matlab Reservoir Simulation Toolbox (MRST)","text":"","category":"section"},{"location":"man/input_files/#Simulation-of-.MAT-files","page":"Input files","title":"Simulation of .MAT files","text":"","category":"section"},{"location":"man/input_files/","page":"Input files","title":"Input files","text":"setup_case_from_mrst\nsimulate_mrst_case","category":"page"},{"location":"man/input_files/#JutulDarcy.setup_case_from_mrst","page":"Input files","title":"JutulDarcy.setup_case_from_mrst","text":"setup_case_from_mrst(\"filename.mat\"; kwarg...)\n\nSet up a Jutul.SimulationCase from a MRST-exported .mat file.\n\n\n\n\n\n","category":"function"},{"location":"man/input_files/#JutulDarcy.simulate_mrst_case","page":"Input files","title":"JutulDarcy.simulate_mrst_case","text":"simulate_mrst_case(file_name)\nsimulate_mrst_case(file_name; <keyword arguments>)\n\nSimulate a MRST case from file_name as exported by writeJutulInput in MRST.\n\nArguments\n\nfile_name::String: The path to a .mat file that is to be simulated.\n\nKeyword arguments\n\nextra_outputs::Vector{Symbol} = [:Saturations]: Additional variables to output from the simulation.\nwrite_output::Bool = true: Write output (in the default JLD2 format)\noutput_path = nothing: Directory for output files. Files will be written under this directory. Defaults to the folder of file_name.\nwrite_mrst = true: Write MRST compatible output after completed simulation that can be read by readJutulOutput in MRST.\nbackend=:csc: choice of backend for linear systems. :csc for default Julia sparse, :csr for experimental parallel CSR.\nverbose=true: print some extra information specific to this routine upon calling\nnthreads=Threads.nthreads(): number of threads to use\nlinear_solver=:bicgstab: name of Krylov.jl solver to use, or :direct (for small cases only)\ninfo_level=0: standard Jutul info_level. 0 for minimal printing, -1 for no printing, 1-5 for various levels of verbosity\n\nAdditional input arguments are passed onto, setup_case_from_mrst, setup_reservoir_simulator and simulator_config if applicable.\n\n\n\n\n\n","category":"function"},{"location":"man/input_files/#MRST-specific-types","page":"Input files","title":"MRST-specific types","text":"","category":"section"},{"location":"man/input_files/","page":"Input files","title":"Input files","text":"Jutul.MRSTWrapMesh","category":"page"},{"location":"man/input_files/#Jutul.MRSTWrapMesh","page":"Input files","title":"Jutul.MRSTWrapMesh","text":"MRSTWrapMesh(G, N = nothing)\n\nMesh that adapts an exported MRST mesh to the Jutul interface. G is assumed to be read directly from file using MAT.matread. The raw exported grid can be found under the data field.\n\n\n\n\n\n","category":"type"},{"location":"man/input_files/#DATA-files-from-commercial-reservoir-modelling-software","page":"Input files","title":"DATA-files from commercial reservoir modelling software","text":"","category":"section"},{"location":"man/input_files/#Parsers","page":"Input files","title":"Parsers","text":"","category":"section"},{"location":"man/input_files/","page":"Input files","title":"Input files","text":"parse_data_file\nparse_grdecl_file","category":"page"},{"location":"man/input_files/#Simulation-of-.DATA-files","page":"Input files","title":"Simulation of .DATA files","text":"","category":"section"},{"location":"man/input_files/","page":"Input files","title":"Input files","text":"simulate_data_file","category":"page"},{"location":"man/input_files/#JutulDarcy.simulate_data_file","page":"Input files","title":"JutulDarcy.simulate_data_file","text":"simulate_data_file(inp; parse_arg = NamedTuple(), kwarg...)\n\nSimulate standard input file (with extension .DATA). inp can either be the output from setup_case_from_parsed_data or a String for the path of an input file.\n\nAdditional arguments are passed onto simulate_reservoir. Extra inputs to the parser can be sent as a parse_arg NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"EditURL = \"../../../examples/compositional_5components.jl\"","category":"page"},{"location":"examples/compositional_5components/#A-more-complex-compositional-model","page":"Compositional with five components","title":"A more complex compositional model","text":"","category":"section"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"This example sets up a more complex compositional simulation with five different components. Other than that, the example is similar to the others that include wells and is therefore not commented in great detail.","category":"page"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"using MultiComponentFlash\n\nn2_ch4 = MolecularProperty(0.0161594, 4.58e6, 189.515, 9.9701e-05, 0.00854)\nco2 = MolecularProperty(0.04401, 7.3866e6, 304.200, 9.2634e-05, 0.228)\nc2_5 = MolecularProperty(0.0455725, 4.0955e6, 387.607, 2.1708e-04, 0.16733)\nc6_13 = MolecularProperty(0.117740, 3.345e6, 597.497, 3.8116e-04, 0.38609)\nc14_24 = MolecularProperty(0.248827, 1.768e6, 698.515, 7.2141e-04, 0.80784)\n\nbic = [0.11883 0.00070981 0.00077754 0.01 0.011;\n       0.00070981 0.15 0.15 0.15 0.15;\n       0.00077754 0.15 0 0 0;\n       0.01 0.15 0 0 0;\n       0.011 0.15 0 0 0]\n\nmixture = MultiComponentMixture([n2_ch4, co2, c2_5, c6_13, c14_24], A_ij = bic, names = [\"N2-CH4\", \"CO2\", \"C2-5\", \"C6-13\", \"C14-24\"])\neos = GenericCubicEOS(mixture, PengRobinson())\n\nusing Jutul, JutulDarcy, CairoMakie\nDarcy, bar, kg, meter, Kelvin, day = si_units(:darcy, :bar, :kilogram, :meter, :Kelvin, :day)\nnx = ny = 20\nnz = 2\n\ndims = (nx, ny, nz)\ng = CartesianMesh(dims, (1000.0, 1000.0, 1.0))\nnc = number_of_cells(g)\nK = repeat([0.05*Darcy], 1, nc)\nres = reservoir_domain(g, porosity = 0.25, permeability = K)","category":"page"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"Set up a vertical well in the first corner, perforated in all layers","category":"page"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"prod = setup_vertical_well(g, K, nx, ny, name = :Producer)","category":"page"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"Set up an injector in the opposite corner, perforated in all layers","category":"page"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"inj = setup_vertical_well(g, K, 1, 1, name = :Injector)\n\nrhoLS = 1000.0*kg/meter^3\nrhoVS = 100.0*kg/meter^3\n\nrhoS = [rhoLS, rhoVS]\nL, V = LiquidPhase(), VaporPhase()","category":"page"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"Define system and realize on grid","category":"page"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"sys = MultiPhaseCompositionalSystemLV(eos, (L, V))\nmodel, parameters = setup_reservoir_model(res, sys, wells = [inj, prod], reference_densities = rhoS, block_backend = true);\nkr = BrooksCoreyRelativePermeabilities(sys, 2.0, 0.0, 1.0)\nmodel = replace_variables!(model, RelativePermeabilities = kr)\n\npush!(model[:Reservoir].output_variables, :Saturations)\n\nparameters[:Reservoir][:Temperature] = 387.45*Kelvin\nstate0 = setup_reservoir_state(model, Pressure = 225*bar, OverallMoleFractions = [0.463, 0.01640, 0.20520, 0.19108, 0.12432]);\n\ndt = repeat([2.0]*day, 365)\nrate_target = TotalRateTarget(0.0015)\nI_ctrl = InjectorControl(rate_target, [0, 1, 0, 0, 0], density = rhoVS)\nbhp_target = BottomHolePressureTarget(100*bar)\nP_ctrl = ProducerControl(bhp_target)\n\ncontrols = Dict()\ncontrols[:Injector] = I_ctrl\ncontrols[:Producer] = P_ctrl\nforces = setup_reservoir_forces(model, control = controls)\nws, states = simulate_reservoir(state0, model, dt, parameters = parameters, forces = forces)\n#!","category":"page"},{"location":"examples/compositional_5components/#Once-the-simulation-is-done,-we-can-plot-the-states","page":"Compositional with five components","title":"Once the simulation is done, we can plot the states","text":"","category":"section"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"sg = states[end][:OverallMoleFractions][2, :]\nfig, ax, p = plot_cell_data(g, sg)\nfig\n#!\nsg = states[end][:Saturations][2, :]\nfig, ax, p = plot_cell_data(g, sg)\nfig\n#!\np = states[end][:Pressure]\nfig, ax, p = plot_cell_data(g, p)\nfig","category":"page"},{"location":"examples/compositional_5components/#Example-on-GitHub","page":"Compositional with five components","title":"Example on GitHub","text":"","category":"section"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"If you would like to run this example yourself, it can be downloaded from the JutulDarcy.jl GitHub repository.","category":"page"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"","category":"page"},{"location":"examples/compositional_5components/","page":"Compositional with five components","title":"Compositional with five components","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/intro/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"examples/intro/","page":"Getting started","title":"Getting started","text":"Install packages:","category":"page"},{"location":"examples/intro/","page":"Getting started","title":"Getting started","text":"using Pkg\nPkg.add(\"Jutul\")\nPkg.add(\"JutulDarcy\")","category":"page"},{"location":"examples/intro/","page":"Getting started","title":"Getting started","text":"If you want the plotting used in the examples, you need this:","category":"page"},{"location":"examples/intro/","page":"Getting started","title":"Getting started","text":"Pkg.add(\"CairoMakie\")","category":"page"},{"location":"examples/intro/","page":"Getting started","title":"Getting started","text":"In addition, there is experimental 3D visualization and well plotting found as a conditional extension. To get access to these features, you need at least Julia 1.9 and the GLMakie package loaded.","category":"page"},{"location":"examples/intro/","page":"Getting started","title":"Getting started","text":"Pkg.add(\"GLMakie\")\nusing GLMakie","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"EditURL = \"../../../examples/two_phase_gravity_segregation.jl\"","category":"page"},{"location":"examples/two_phase_gravity_segregation/#Gravity-segregation-example","page":"Gravity segregation","title":"Gravity segregation example","text":"","category":"section"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"The simplest type of porous media simulation problem to set up that is not trivial is the transition to equilibrium from an unstable initial condition. Placing a heavy fluid on top of a lighter fluid will lead to the heavy fluid moving down while the lighter fluid moves up.","category":"page"},{"location":"examples/two_phase_gravity_segregation/#Problem-set-up","page":"Gravity segregation","title":"Problem set up","text":"","category":"section"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"We define a simple 1D gravity column with an approximate 10-1 ratio in density between the two compressible phases and let it simulate until equilibrium is reached.","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"using JutulDarcy, Jutul\nnc = 100\nDarcy, bar, kg, meter, day = si_units(:darcy, :bar, :kilogram, :meter, :day)\n\ng = CartesianMesh((1, 1, nc), (1.0, 1.0, 10.0))\ndomain = reservoir_domain(g, permeability = 1.0*Darcy)","category":"page"},{"location":"examples/two_phase_gravity_segregation/#Fluid-properties","page":"Gravity segregation","title":"Fluid properties","text":"","category":"section"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"Define two phases liquid and vapor with a 10-1 ratio reference densities and set up the simulation model.","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"p0 = 100*bar\n\nrhoLS = 1000.0*kg/meter^3\nrhoVS = 100.0*kg/meter^3\ncl, cv = 1e-5/bar, 1e-4/bar\nL, V = LiquidPhase(), VaporPhase()\nsys = ImmiscibleSystem([L, V])\nmodel = SimulationModel(domain, sys)","category":"page"},{"location":"examples/two_phase_gravity_segregation/#Definition-for-phase-mass-densities","page":"Gravity segregation","title":"Definition for phase mass densities","text":"","category":"section"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"Replace default density with a constant compressibility function that uses the reference values at the initial pressure.","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"density = ConstantCompressibilityDensities(sys, p0, [rhoLS, rhoVS], [cl, cv])\nset_secondary_variables!(model, PhaseMassDensities = density)","category":"page"},{"location":"examples/two_phase_gravity_segregation/#Set-up-initial-state","page":"Gravity segregation","title":"Set up initial state","text":"","category":"section"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"Put heavy phase on top and light phase on bottom. Saturations have one value per phase, per cell and consequently a per-cell instantiation will require a two by number of cells matrix as input.","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"nl = nc ÷ 2\nsL = vcat(ones(nl), zeros(nc - nl))'\ns0 = vcat(sL, 1 .- sL)\nstate0 = setup_state(model, Pressure = p0, Saturations = s0)","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"Convert time-steps from days to seconds","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"timesteps = repeat([0.02]*day, 150)","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"# Perform simulation\nstates, report = simulate(state0, model, timesteps, info_level = -1)","category":"page"},{"location":"examples/two_phase_gravity_segregation/#Plot-results","page":"Gravity segregation","title":"Plot results","text":"","category":"section"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"The 1D nature of the problem allows us to plot all timesteps simultaneously in 2D. We see that the heavy fluid, colored blue, is initially at the top of the domain and the lighter fluid is at the bottom. These gradually switch places until all the heavy fluid is at the lower part of the column.","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"using CairoMakie\ntmp = vcat(map((x) -> x[:Saturations][1, :]', states)...)\nf = Figure()\nax = Axis(f[1, 1], xlabel = \"Time\", ylabel = \"Depth\", title = \"Gravity segregation\")\nhm = heatmap!(ax, tmp, colormap = :seismic)\nColorbar(f[1, 2], hm)\nf","category":"page"},{"location":"examples/two_phase_gravity_segregation/#Example-on-GitHub","page":"Gravity segregation","title":"Example on GitHub","text":"","category":"section"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"If you would like to run this example yourself, it can be downloaded from the JutulDarcy.jl GitHub repository.","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"","category":"page"},{"location":"examples/two_phase_gravity_segregation/","page":"Gravity segregation","title":"Gravity segregation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/forces/#Driving-forces","page":"Driving forces","title":"Driving forces","text":"","category":"section"},{"location":"man/forces/#Source-terms","page":"Driving forces","title":"Source terms","text":"","category":"section"},{"location":"man/forces/","page":"Driving forces","title":"Driving forces","text":"SourceTerm","category":"page"},{"location":"man/forces/#JutulDarcy.SourceTerm","page":"Driving forces","title":"JutulDarcy.SourceTerm","text":"SourceTerm(cell, value; fractional_flow = [1.0], type = MassSource)\n\nCreate source term in given cell with given total value.\n\nThe optional fractional_flow argument controls how this term is divided over components if used for inflow and should contain one entry per component in the system: (number_of_components(system)). fractional_flow should sum up to 1.0. The type argument should be an instance of the FlowSourceType enum, with interpretations as follows:\n\nMassSource: Source is directly interpreted as component masses.\nStandardVolumeSource: Source is volume at standard/surface conditions.  References densities are used to convert into mass sources.\nVolumeSource: Source is volume at in-situ / reservoir conditions.\n\n\n\n\n\n","category":"type"},{"location":"man/forces/#Boundary-conditions","page":"Driving forces","title":"Boundary conditions","text":"","category":"section"},{"location":"man/forces/","page":"Driving forces","title":"Driving forces","text":"FlowBoundaryCondition","category":"page"},{"location":"man/forces/#JutulDarcy.FlowBoundaryCondition","page":"Driving forces","title":"JutulDarcy.FlowBoundaryCondition","text":"FlowBoundaryCondition(\ncell,\npressure = DEFAULT_MINIMUM_PRESSURE,\ntemperature = 298.15;\nfractional_flow = nothing,\ndensity = nothing,\ntrans_flow = 1e-12,\ntrans_thermal = 1e-6\n)\n\nDirchlet boundary condition for constant values (pressure/temperature) at some inflow boundary\n\n\n\n\n\n","category":"type"},{"location":"man/systems/#Supported-physical-systems","page":"Supported physical systems","title":"Supported physical systems","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"JutulDarcy supports a number of different systems. These are JutulSystem instances that describe a particular type of physics for porous media flow. We describe these in roughly the order of complexity that they can model.","category":"page"},{"location":"man/systems/#Summary","page":"Supported physical systems","title":"Summary","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"The general form of the flow systems we will discuss is a conservation law for N components on residual form:","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"R = fracpartialpartial t M_i + nabla cdot vecV_i - Q_i quad forall i in 1 dots N","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"Here, M_i is the conserved quantity (usually masses) for component i and vecV_i the velocity of the conserved quantity. Q_i represents source terms that come from direct sources SourceTerm, boundary conditions (FlowBoundaryCondition) or from wells (setup_well, setup_vertical_well).","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"The following table gives an overview of the available features that are described in more detail below:","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"System Number of phases Number of components M V\nSinglePhaseSystem 1 1 rho phi rho vecv\nImmiscibleSystem Any (Any) S_alpha rho_alpha phi rho_alpha vecv_alpha\nStandardBlackOilSystem 2-3 (2-3) rho_o^s(b_g S_g + R_s b_o S_o) b_g vecv_g + R_s b_g vecv_o\nMultiPhaseCompositionalSystemLV 2-3 Any rho_l X_i S_l + rho_v Y_i S_v rho_l X_i vecv_l + rho_v Y_i vecv_v","category":"page"},{"location":"man/systems/#Phases","page":"Supported physical systems","title":"Phases","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"Phases are defined using specific types. Some constructors take a list of phases present in the model. Phases do not contain any data themselves and the distinction between different phases applies primarily for well controls.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"LiquidPhase\nAqueousPhase\nVaporPhase","category":"page"},{"location":"man/systems/#JutulDarcy.LiquidPhase","page":"Supported physical systems","title":"JutulDarcy.LiquidPhase","text":"LiquidPhase()\n\nAbstractPhase subtype for liquid-like phases.\n\n\n\n\n\n","category":"type"},{"location":"man/systems/#JutulDarcy.AqueousPhase","page":"Supported physical systems","title":"JutulDarcy.AqueousPhase","text":"AqueousPhase()\n\nAbstractPhase subtype for water-like phases.\n\n\n\n\n\n","category":"type"},{"location":"man/systems/#JutulDarcy.VaporPhase","page":"Supported physical systems","title":"JutulDarcy.VaporPhase","text":"VaporPhase()\n\nAbstractPhase subtype for vapor or gaseous phases.\n\n\n\n\n\n","category":"type"},{"location":"man/systems/#Implementation-details","page":"Supported physical systems","title":"Implementation details","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"In the above the discrete version of M_i is implemented in the update function for TotalMasses that should by convention be named JutulDarcy.update_total_masses!. The discrete component fluxes are implemented by JutulDarcy.component_mass_fluxes!.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"JutulDarcy.update_total_masses!\nJutulDarcy.component_mass_fluxes!","category":"page"},{"location":"man/systems/#JutulDarcy.update_total_masses!","page":"Supported physical systems","title":"JutulDarcy.update_total_masses!","text":"update_total_masses!(totmass, tv, model, arg..., ix)\n\nUpdate total masses for a given system. Number of input arguments varies based on physical system under consideration.\n\n\n\n\n\n","category":"function"},{"location":"man/systems/#JutulDarcy.component_mass_fluxes!","page":"Supported physical systems","title":"JutulDarcy.component_mass_fluxes!","text":"component_mass_fluxes!(q, face, state, model, flux_type, kgrad, upw)\n\nImplementation of component fluxes for a given system for a given face. Should return a StaticVector with one entry per component.\n\n\n\n\n\n","category":"function"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"The source terms are implemented by Jutul.apply_forces_to_equation! for boundary conditions and sources, and Jutul.update_cross_term_in_entity! for wells. We use Julia's multiple dispatch to pair the right implementation with the right physics system.","category":"page"},{"location":"man/systems/#Single-phase-flow","page":"Supported physical systems","title":"Single-phase flow","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"SinglePhaseSystem","category":"page"},{"location":"man/systems/#JutulDarcy.SinglePhaseSystem","page":"Supported physical systems","title":"JutulDarcy.SinglePhaseSystem","text":"SinglePhaseSystem(phase = LiquidPhase(); reference_density = 1.0)\n\nA single-phase system that only solves for pressure.\n\n\n\n\n\n","category":"type"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"The simplest form of porous media flow is the single-phase system.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"r(p) = fracpartialpartial t( rho phi) + nabla cdot (rho vecv) - rho q","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"rho is the phase mass density and phi the apparent porosity of the medium, i.e. the void space in the rock available to flow. Where the velocity vecv is given by Darcy's law that relates the the pressure gradient nabla p and hydrostatic head to the velocity field:","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"vecv = - fracmathbfKmu (nabla p + rho g nabla z)","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"Here, mathbfK is a positive-definite permeability tensor, mu the fluid viscosity, g the magnitude of gravity oriented down and z the depth.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"note: Single-phase implementation\nThe SinglePhaseSystem is a dedicated single phase system. This is mathematically equivalent to an ImmiscibleSystem when set up with a single phase. For single phase flow, the fluid Pressure is the primary variable in each cell. The equation supports two types of compressibility: That of the fluid where density is a function rho(p) of pressure and that of the pores where the porosity phi(p) changes with pressure.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"tip: Tip\nJutulDarcy uses the notion of depth rather than coordinate when defining buoyancy forces. This is consistent with the convention in the literature on subsurface flow.","category":"page"},{"location":"man/systems/#Multi-phase,-immiscible-flow","page":"Supported physical systems","title":"Multi-phase, immiscible flow","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"ImmiscibleSystem","category":"page"},{"location":"man/systems/#JutulDarcy.ImmiscibleSystem","page":"Supported physical systems","title":"JutulDarcy.ImmiscibleSystem","text":"ImmiscibleSystem(phases; reference_densities = ones(length(phases)))\nImmiscibleSystem((LiquidPhase(), VaporPhase()), reference_densities = (1000.0, 700.0))\n\nImmiscible flow system: Each component exists only in a single phase, and the number of components equal the number of phases.\n\nSet up an immiscible system for the given phases with optional reference densitites. This system is easy to specify with Pressure and Saturations as the default primary variables. Immiscible system assume that there is no mass transfer between phases and that a phase is uniform in composition.\n\n\n\n\n\n","category":"type"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"The flow systems immediately become more interesting if we add more phases. We can extend the above single-phase system by introducing the phase saturation of phase with label alpha as S_alpha. The phase saturation represents the volumetric fraction of the rock void space occupied by the phase. If we consider a pair of phases n w non-wetting and wetting we can write the system as","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"r_alpha = fracpartialpartial t (S_alpha rho_alpha phi) + nabla cdot (rho_alpha vecv_alpha) - rho_alpha q_alpha = 0 quad alpha in n w","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"This requires an additional closure such that the amount of saturation of all phases exactly fills the available fluid volume:","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"S_w + S_n = 1 quad 1 ge S_alpha ge 0 quad alpha in n w","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"This equation is local and linear in the saturations and can be eliminated to produce the classical two-equation system for two-phase flow,","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"r_n = fracpartialpartial t ((1 - S_w) rho_n phi) + nabla cdot (rho_n vecv_n) - rho_n q_n = 0\nr_w = fracpartialpartial t (S_w rho_w phi) + nabla cdot (rho_w vecv_w) - rho_w q_w = 0","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"To complete this description we also need expressions for the phase fluxes. We use the standard multiphase extension of Darcy's law,","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"vecv_alpha = - mathbfK frack_ralphamu_alpha (nabla palpha + rho_alpha g nabla z)","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"Here, we have introduced the relative permeability of the phase k_ralpha, an empirical relationship between the saturation and the flow rate. Relative permeability is a complex topic with many different relationships and functional forms, but we limit the discussion to monotone, non-negative functions of their respective saturations, for example a simple Brooks-Corey type of k_ralpha(S_alpha) = S_alpha^2. We have also introduced separate phase pressures p_alpha that account for capillary pressure, e.g. p_w = p_n + p_c(S_w).","category":"page"},{"location":"man/systems/#Primary-variables","page":"Supported physical systems","title":"Primary variables","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"note: Immiscible implementation\nThe ImmiscibleSystem implements this system for any number of phases. The primary variables for this system is a single reference Pressure and phase Saturations. As we do not solve for the volume closure equation, there is one less degree of freedom associated with the saturations than there are number of phases.","category":"page"},{"location":"man/systems/#Black-oil:-Multi-phase,-pseudo-compositional-flow","page":"Supported physical systems","title":"Black-oil: Multi-phase, pseudo-compositional flow","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"StandardBlackOilSystem","category":"page"},{"location":"man/systems/#JutulDarcy.StandardBlackOilSystem","page":"Supported physical systems","title":"JutulDarcy.StandardBlackOilSystem","text":"StandardBlackOilSystem(; rs_max = nothing,\n                         rv_max = nothing,\n                         phases = (AqueousPhase(), LiquidPhase(), VaporPhase()),\n                         reference_densities = [786.507, 1037.84, 0.969758])\n\nSet up a standard black-oil system. Keyword arguments rs_max and rv_max can either be nothing or callable objects / functions for the maximum Rs and Rv as a function of pressure. phases can be specified together with reference_densities for each phase.\n\nNOTE: For the black-oil model, the reference densities significantly impact many aspects of the PVT behavior. These should generally be set consistently with the other properties.\n\n\n\n\n\n","category":"type"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"The black-oil equations is an extension of the immiscible description to handle limited miscibility between the phases. Originally developed for certain types of oil and gas simulation, these equations are useful when the number of components is low and tabulated values for dissolution and vaporization are available.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"The assumptions of the black-oil model is that the \"oil\" and \"gas\" pseudo-components have uniform composition throughout the domain. JutulDarcy supports two- and three-phase black oil flow. The difference between two and three phases amounts to an additional immiscible aqueous phase that is identical to that of the previous section. For that reason, we focus on the miscible pseudo-components:","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"r_o = rho_o^s left( fracpartialpartial t( (b_o S_o + R_v b_g (1 - S_o)) phi) + nabla cdot ( b_o vecv_o + R_v b_o vecv_g) - q_o^s right ) \nr_g = rho_g^s left( fracpartialpartial t( (b_g S_g + R_s b_o S_o) phi) + nabla cdot ( b_g vecv_g + R_s b_g vecv_o) - q_g^s right )","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"The model uses the notion of surface (or reference densities) rho_o^s rho_g^s to define the densities of the component at specific pressure and temperature conditions where it is assumed that all \"gas\" has moved to the vapor phase and the defined \"oil\" is only found in the liquid phase. Keeping this definition in mind, the above equations can be divided by the surface densities to produce a surface volume balance equation where we have defined b_o and b_g as the dimensionless reciprocal formation volume factors that relate a volume at reservoir conditions to surface volumes and R_s for the dissolved volume of gas in the oil phase when brought to surface conditions. R_v is the same definition, but for oil vaporized into the gas phase.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"note: Blackoil implementation\nThe StandardBlackOilSystem implements the black-oil equations. It is possible to run cases with and without water, with and without R_s and with and without R_v. The primary variables for the most general case is the reference Pressure, an ImmiscibleSaturation for the aqueous phase and the special BlackOilUnknown that will represent either S_o, R_s or R_v on a cell-by-cell basis depending on what phases are present and saturated.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"A full description of the black-oil equations is outside the scope of this documentation. Please see [1] for more details.","category":"page"},{"location":"man/systems/#Compositional:-Multi-phase,-multi-component-flow","page":"Supported physical systems","title":"Compositional: Multi-phase, multi-component flow","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"MultiPhaseCompositionalSystemLV","category":"page"},{"location":"man/systems/#JutulDarcy.MultiPhaseCompositionalSystemLV","page":"Supported physical systems","title":"JutulDarcy.MultiPhaseCompositionalSystemLV","text":"MultiPhaseCompositionalSystemLV(equation_of_state, phases = (LiquidPhase(), VaporPhase()); reference_densities = ones(length(phases)), other_name = \"Water\")\n\nSet up a compositional system for a given equation_of_state from MultiComponentFlash.\n\n\n\n\n\n","category":"type"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"The more general case of multi-component flow is often referred to as a compositional model. The typical version of this model describes the fluid as a system of N components where the phases present and fluid properties are determined by an equation-of-state. This can be highly accurate if the equation-of-state is tuned for the mixtures that are encountered, but comes at a significant computational cost as the equation-of-state must be evaluated many times.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"JutulDarcy implements a standard compositional model that assumes local instantaneous equilibrium and that the components are present in up to two phases with an optional immiscible phase added. This is sometimes referred to as a \"simple water\" or \"dead water\" description. By default the solvers use MultiComponentFlash.jl to solve thermodynamic equilibrium. This package implements the generalized cubic approach and defaults to Peng-Robinson.","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"Assume that we have two phases liquid and vapor referred to as l and v with the Darcy flux given as in the preceeding sections. We can then write the residual equation for each of the M components by the liquid and vapor mole fractions X_i Y_i`of that component as:","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"r_i = fracpartialpartial t left( (rho_l X_i S_l + rho_v Y_i S_v) phi right) + nabla cdot (rho_l X_i vecv_l + rho_v Y_i vecv_v) - Q_i quad M in 1 dots M","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"For additional details, please see Chapter 8 - Compositional Simulation with the AD-OO Framework in [2].","category":"page"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"note: Compositional implementation\nThe MultiPhaseCompositionalSystemLV implements the compositional model. The primary variables for the most general case is the reference Pressure, an ImmiscibleSaturation for the optional immiscible phase and M-1 OverallMoleFractions.","category":"page"},{"location":"man/systems/#Thermal-flow","page":"Supported physical systems","title":"Thermal flow","text":"","category":"section"},{"location":"man/systems/","page":"Supported physical systems","title":"Supported physical systems","text":"Currently experimental and undocumented. See ThermalSystem if you are feeling brave.","category":"page"},{"location":"ref/jutul/#Documentation-from-Jutul.jl","page":"Jutul functions","title":"Documentation from Jutul.jl","text":"","category":"section"},{"location":"ref/jutul/","page":"Jutul functions","title":"Jutul functions","text":"JutulDarcy.jl builds upon Jutul.jl. You can use JutulDarcy.jl without knowing the inner workings of Jutul.jl, but if you want to dive under the hood these docstrings may be helpful.","category":"page"},{"location":"ref/jutul/","page":"Jutul functions","title":"Jutul functions","text":"Modules = [Jutul]","category":"page"},{"location":"ref/jutul/#Jutul.AMGPreconditioner","page":"Jutul functions","title":"Jutul.AMGPreconditioner","text":"AMG on CPU (Julia native)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.BlockMajorLayout","page":"Jutul functions","title":"Jutul.BlockMajorLayout","text":"Same as EntityMajorLayout, but the system is a sparse matrix where each entry is a small dense matrix.\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give a diagonal of length 2: [(∂E1/∂p)₁ (∂E1/∂S)₁ ; (∂E2/∂p)₁ (∂E2/∂S)₁] [(∂E1/∂p)₂ (∂E1/∂S)₂ ; (∂E2/∂p)₂ (∂E2/∂S)₂]\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.BoundaryFaces","page":"Jutul functions","title":"Jutul.BoundaryFaces","text":"Entity for faces on the boundary (faces that are only connected to a single Cells)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.CartesianMesh","page":"Jutul functions","title":"Jutul.CartesianMesh","text":"CartesianMesh(dims, [Δ, [origin]])\n\nCreate a Cartesian mesh with dimensions specified by the Tuple dims.\n\nArguments\n\ndims::Tuple: Number of grid cells in each direction. For example, (nx, ny) will give a 2D grids with nx cells in the x-direction.\nΔ::Tuple=ones(length(dims)): Equal length to dims. First option: A Tuple of scalars where each entry is the length of each cell in that direction. For\n\nexample, specifying (Δx, Δy) for a uniform grid with each grid cell having area ofΔx*Δy. Second option: ATuple` of vectors where each entry contains the cell sizes in the direction.\n\norigin=zeros(length(dims)): The origin of the first corner in the grid.\n\nExamples\n\nGenerate a uniform 3D mesh that discretizes a domain of 2 by 3 by 5 units with 3 by 5 by 2 cells:\n\njulia> CartesianMesh((3, 5, 2), (2.0, 3.0, 5.0))\nCartesianMesh (3D) with 3x5x2=30 cells\n\nGenerate a non-uniform 2D mesh:\n\njulia> CartesianMesh((2, 3), ([1.0, 2.0], [0.1, 3.0, 2.5]))\nCartesianMesh (3D) with 3x5x2=30 cells\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.Cells","page":"Jutul functions","title":"Jutul.Cells","text":"Entity for Cells (closed volumes with averaged properties for a finite-volume solver)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.CoarseMesh-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.CoarseMesh","text":"CoarseMesh(G::JutulMesh, p)\n\nConstruct a coarse mesh from a given JutulMesh that can be converted to an UnstructuredMesh instance. The second argument p should be a partition Vector with one entry per cell in the original grid that assigns that cell to a coarse block. Should be one-indexed and the numbering should be sequential and contain at least one fine cell for each coarse index. This is tested by the function.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.CompactAutoDiffCache","page":"Jutul functions","title":"Jutul.CompactAutoDiffCache","text":"Cache that holds an AD vector/matrix together with their positions.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.DataDomain-Tuple{JutulDomain}","page":"Jutul functions","title":"Jutul.DataDomain","text":"DataDomain(domain::JutulDomain; property1 = p1, property2 = p2, ...)\n\nA wrapper around a domain that allows for storing of entity-associated data.\n\nExample:\n\n# Grid with 6 cells and 7 interior faces\ng = CartesianMesh((2, 3))\nd = DataDomain(g)\nd[:cell_vec] = rand(6) #ok, same as:\nd[:cell_vec, Cells()] = rand(6) #ok\nd[:cell_vec, Faces()] = rand(6) #not ok!\nd[:face_vec, Faces()] = rand(7) #ok!\n# Can also add general arrays if last dimension == entity dimension\nd[:cell_vec, Cells()] = rand(10, 3, 6) #ok\n# Can add general data too, but needs to be specified\nd[:not_on_face_or_cell, nothing] = rand(3) # also ok\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.DefaultContext","page":"Jutul functions","title":"Jutul.DefaultContext","text":"Default context\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.DiscretizedDomain","page":"Jutul functions","title":"Jutul.DiscretizedDomain","text":"DiscretizedDomain(domain, disc = nothing)\n\nA type for a discretized domain of some other domain or mesh. May contain one or more discretizations as-needed to write equations.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.EntityMajorLayout","page":"Jutul functions","title":"Jutul.EntityMajorLayout","text":"Equations are grouped by entity, listing all equations and derivatives for entity 1 before proceeding to entity 2 etc.\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E2/∂S)₁, (∂E1/∂p)₂, (∂E2/∂S)₂\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.EquationMajorLayout","page":"Jutul functions","title":"Jutul.EquationMajorLayout","text":"Equations are stored sequentially in rows, derivatives of same type in columns:\n\nFor a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E1/∂p)₂, (∂E2/∂S)₁, (∂E2/∂S)₂\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.EquationSet","page":"Jutul functions","title":"Jutul.EquationSet","text":"Set of a variable where equations are defined\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.FaceMap","page":"Jutul functions","title":"Jutul.FaceMap","text":"Struct that contains mappings for a set of faces that are made up of nodes and are part of cells.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.Faces","page":"Jutul functions","title":"Jutul.Faces","text":"Entity for Faces (intersection between pairs of Cells)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.FlowDiscretization","page":"Jutul functions","title":"Jutul.FlowDiscretization","text":"Discretization of kgradp + upwind\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.FractionVariables","page":"Jutul functions","title":"Jutul.FractionVariables","text":"Abstract type for fraction variables (vector variables that sum up to unity over each entity).\n\nBy default, these are limited to the [0, 1] range through maximum_value and minimum_value default implementations.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.GlobalSet","page":"Jutul functions","title":"Jutul.GlobalSet","text":"The global set of variables\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.GroupWisePreconditioner","page":"Jutul functions","title":"Jutul.GroupWisePreconditioner","text":"Multi-model preconditioners\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.HalfFaces","page":"Jutul functions","title":"Jutul.HalfFaces","text":"Entity for half-faces (face associated with a single Cells)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.HelperSimulator-Union{Tuple{E}, Tuple{M}, Tuple{M, Any}} where {M, E}","page":"Jutul functions","title":"Jutul.HelperSimulator","text":"HelperSimulator(model::M, T = Float64; state0 = setup_state(model), executor::E = Jutul.default_executor()) where {M, E}\n\nConstruct a helper simulator that can be used to compute the residuals and/or accumulation terms for a given type T. Useful for coupling Jutul to other solvers and types of automatic differentiation.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.ILUZeroPreconditioner","page":"Jutul functions","title":"Jutul.ILUZeroPreconditioner","text":"ILU(0) preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.IndirectionMap","page":"Jutul functions","title":"Jutul.IndirectionMap","text":"IndirectionMap(vals::Vector{V}, pos::Vector{Int}) where V\n\nCreate a indirection map that encodes a variable length dense vector.\n\npos is assumed to be a Vector{Int} of length n+1 where n is the number of dense vectors that is encoded. The vals array holds the entries for vector i in the range pos[i]:(pos[i+1]-1) for fast lookup. Indexing into the indirection map with index k will give a view into the values for vector k.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JacobiPreconditioner","page":"Jutul functions","title":"Jutul.JacobiPreconditioner","text":"Damped Jacobi preconditioner on CPU\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulAutoDiffCache","page":"Jutul functions","title":"Jutul.JutulAutoDiffCache","text":"An AutoDiffCache is a type that holds both a set of AD values and a map into some global Jacobian.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulCase","page":"Jutul functions","title":"Jutul.JutulCase","text":"JutulCase(model, dt = [1.0], forces = setup_forces(model); state0 = nothing, parameters = nothing, kwarg...)\n\nSet up a structure that holds the complete specification of a simulation case.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulConfig","page":"Jutul functions","title":"Jutul.JutulConfig","text":"JutulConfig(name = nothing)\n\nA configuration object that acts like a Dict{Symbol,Any} but contains additional data to limit the valid keys and values to those added by add_option!\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulContext","page":"Jutul functions","title":"Jutul.JutulContext","text":"Abstract type for the context Jutul should execute in (matrix formats, memory allocation, etc.)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulDiscretization","page":"Jutul functions","title":"Jutul.JutulDiscretization","text":"d = disc(i, Cells())\n\nAsk discretization for entry i when discretizing some equation on the  chosen entity (e.g. Cells)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulDiscretization-2","page":"Jutul functions","title":"Jutul.JutulDiscretization","text":"Abstract type for a Jutul discretization\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulDomain","page":"Jutul functions","title":"Jutul.JutulDomain","text":"Abstract type for domains where equations can be defined\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulEntity","page":"Jutul functions","title":"Jutul.JutulEntity","text":"Super-type for all entities where JutulVariables can be defined.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulEquation","page":"Jutul functions","title":"Jutul.JutulEquation","text":"Abstract type for all residual equations\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulForce","page":"Jutul functions","title":"Jutul.JutulForce","text":"Abstract type for driving forces\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulMatrixLayout","page":"Jutul functions","title":"Jutul.JutulMatrixLayout","text":"Abstract type for matrix layouts. A layout determines how primary variables and equations are ordered in a sparse matrix representation. Note that this is different from the matrix format itself as it concerns the ordering itself: For example, if all equations for a single cell come in sequence, or if a single equation is given for all entities before the next equation is written.\n\nDifferent layouts does not change the solution of the system, but different linear solvers support different layouts.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulMesh","page":"Jutul functions","title":"Jutul.JutulMesh","text":"A mesh is a type of domain that has been discretized. Abstract subtype.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulSystem","page":"Jutul functions","title":"Jutul.JutulSystem","text":"Abstract type for the physical system to be solved.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.JutulVariables","page":"Jutul functions","title":"Jutul.JutulVariables","text":"Abstract type for all variables in Jutul.\n\nA variable is associated with a JutulEntity through the associated_entity function. A variable is local to that entity, and cannot depend on other entities. Variables are used by models to define:\n\nprimary variables: Sometimes referred to as degrees of freedom, primary unknowns or solution variables\nparameters: Static quantities that impact the solution\nsecondary variables: Can be computed from a combination of other primary and secondary variables and parameters.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.LUPreconditioner","page":"Jutul functions","title":"Jutul.LUPreconditioner","text":"Full LU factorization as preconditioner (intended for smaller subsystems)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.LUSolver","page":"Jutul functions","title":"Jutul.LUSolver","text":"LUSolver(; reuse_memory = true, check = true, max_size = 50000)\n\nDirect solver that calls lu directly. Direct solvers are highly accurate, but are costly in terms of memory usage and execution speed for larger systems.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.MRSTWrapMesh","page":"Jutul functions","title":"Jutul.MRSTWrapMesh","text":"MRSTWrapMesh(G, N = nothing)\n\nMesh that adapts an exported MRST mesh to the Jutul interface. G is assumed to be read directly from file using MAT.matread. The raw exported grid can be found under the data field.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.MultiModel","page":"Jutul functions","title":"Jutul.MultiModel","text":"MultiModel(models)\n\nA model variant that is made up of many named submodels, each a fully realized SimulationModel.\n\nmodels should be a NamedTuple or Dict{Symbol, JutulModel}.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.NoEntity","page":"Jutul functions","title":"Jutul.NoEntity","text":"An entity for something that isn't associated with an entity\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.Nodes","page":"Jutul functions","title":"Jutul.Nodes","text":"Entity for Nodes (intersection between multiple Faces)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.ParallelCSRContext","page":"Jutul functions","title":"Jutul.ParallelCSRContext","text":"A context that uses a CSR sparse matrix format together with threads. Experimental.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.SPAI0Preconditioner","page":"Jutul functions","title":"Jutul.SPAI0Preconditioner","text":"Sparse Approximate Inverse preconditioner of lowest order – SPAI(0)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.SPU","page":"Jutul functions","title":"Jutul.SPU","text":"Single-point upwinding.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.ScalarVariable","page":"Jutul functions","title":"Jutul.ScalarVariable","text":"Abstract type for scalar variables (one entry per entity, e.g. pressure or temperature in each cell of a model)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.SimulationModel-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.SimulationModel","text":"SimulationModel(domain, system; <kwarg>)\n\nInstantiate a model for a given system discretized on the domain.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.SimulationModel-Tuple{JutulMesh, Any}","page":"Jutul functions","title":"Jutul.SimulationModel","text":"SimulationModel(g::JutulMesh, system; discretization = nothing, kwarg...)\n\nType that defines a simulation model - everything needed to solve the discrete equations.\n\nThe minimal setup requires a JutulMesh that defines topology together with a JutulSystem that imposes physical laws.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.Simulator-Tuple{Any}","page":"Jutul functions","title":"Jutul.Simulator","text":"Simulator(model; <kwarg>)\n\nSet up a simulator object for a model that can be used by simulate!. To avoid manually instantiating the simulator, the non-mutating simulate interface can be used instead.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.SparsityTracingWrapper-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Jutul functions","title":"Jutul.SparsityTracingWrapper","text":"SparsityTracingWrapper(x::AbstractArray{T, N}) where {T, N}\n\nCreate a sparsity tracing wrapper for a numeric array. This wrapped array produces outputs that have the same value as the wrapped type, but contains a SparsityTracing seeded value with seed equal to the column index (if matrix) or linear index (if vector).\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.TPFA","page":"Jutul functions","title":"Jutul.TPFA","text":"Two-point flux approximation.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.TwoPointFiniteVolumeGeometry","page":"Jutul functions","title":"Jutul.TwoPointFiniteVolumeGeometry","text":"TwoPointFiniteVolumeGeometry(neighbors, areas, volumes, normals, cell_centers, face_centers)\n\nStore two-point geometry information for a given list of neighbors specified as a 2 by n matrix where n is the number of faces such that face i connectes cells N[1, i] and N[2, i].\n\nThe two-point finite-volume geometry contains the minimal set of geometry information required to compute standard finite-volume discretizations.\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.UnstructuredMesh-Tuple{CartesianMesh}","page":"Jutul functions","title":"Jutul.UnstructuredMesh","text":"UnstructuredMesh(g::CartesianMesh)\n\nConvert CartesianMesh instance to unstructured grid (3D only)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.VariableSet","page":"Jutul functions","title":"Jutul.VariableSet","text":"Set of a variable where variables are defined\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.VectorVariables","page":"Jutul functions","title":"Jutul.VectorVariables","text":"Abstract type for vector variables (more than one entry per entity, for example saturations or displacements)\n\n\n\n\n\n","category":"type"},{"location":"ref/jutul/#Jutul.absolute_increment_limit-Tuple{JutulVariables}","page":"Jutul functions","title":"Jutul.absolute_increment_limit","text":"Absolute allowable change for variable during a nonlinear update.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.add_option!","page":"Jutul functions","title":"Jutul.add_option!","text":"add_option!(opts::JutulConfig, :my_cool_option, 3, \"My option has this brief description\")\n\nAdd an option to existing JutulConfig structure. Additional currently undocumented keyword arguments can be used to restrict valid types and values.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.align_to_jacobian!-NTuple{4, Any}","page":"Jutul functions","title":"Jutul.align_to_jacobian!","text":"Update an equation so that it knows where to store its derivatives in the Jacobian representation.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.align_to_jacobian!-Tuple{ConservationLawTPFAStorage, ConservationLaw, Any, Any, Cells}","page":"Jutul functions","title":"Jutul.align_to_jacobian!","text":"Update positions of law's derivatives in global Jacobian\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.allocate_array_ad-Tuple{AbstractMatrix}","page":"Jutul functions","title":"Jutul.allocate_array_ad","text":"allocate_array_ad(v::AbstractMatrix, ...)\n\nConvert matrix to AD matrix.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.allocate_array_ad-Tuple{AbstractVector}","page":"Jutul functions","title":"Jutul.allocate_array_ad","text":"allocate_array_ad(v::AbstractVector, ...)\n\nConvert vector to AD vector.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.allocate_array_ad-Union{Tuple{Vararg{R}}, Tuple{R}} where R<:Integer","page":"Jutul functions","title":"Jutul.allocate_array_ad","text":"allocate_array_ad(n[, m]; <keyword arguments>)\n\nAllocate vector or matrix as AD with optionally provided context and a specified non-zero on the diagonal.\n\nArguments\n\nn::Integer: number of entries in vector, or number of rows if m is given.\nm::Integer: number of rows (optional)\n\nKeyword arguments\n\nnpartials = 1: Number of partials derivatives to allocate for each element\ndiag_pos = nothing: Indices of where to put entities on the diagonal (if any)\n\nOther keyword arguments are passed onto get_ad_entity_scalar.\n\nExamples:\n\nAllocate a vector with a single partial:\n\njulia> allocate_array_ad(2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 1}}:\n Dual{nothing}(0.0,0.0)\n Dual{nothing}(0.0,0.0)\n\nAllocate a vector with two partials, and set the first to one:\n\njulia> allocate_array_ad(2, diag_pos = 1, npartials = 2)\n2-element Vector{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,1.0,0.0)\n\nSet up a matrix with two partials, where the first column has partials [1, 0] and the second [0, 1]:\n\njulia> allocate_array_ad(2, 2, diag_pos = [1, 2], npartials = 2)\n2×2 Matrix{ForwardDiff.Dual{nothing, Float64, 2}}:\n Dual{nothing}(0.0,1.0,0.0)  Dual{nothing}(0.0,1.0,0.0)\n Dual{nothing}(0.0,0.0,1.0)  Dual{nothing}(0.0,0.0,1.0)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.apply_forces!-NTuple{4, Any}","page":"Jutul functions","title":"Jutul.apply_forces!","text":"Apply a set of forces to all equations. Equations that don't support a given force will just ignore them, thanks to the power of multiple dispatch.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.apply_forces_to_equation!-NTuple{7, Any}","page":"Jutul functions","title":"Jutul.apply_forces_to_equation!","text":"apply_forces_to_equation!(diag_part, storage, model, eq, eq_s, force, time)\n\nUpdate an equation with the effect of a force. The default behavior for any force we do not know about is to assume that the force does not impact this particular equation.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.as_value-Tuple{AbstractArray}","page":"Jutul functions","title":"Jutul.as_value","text":"Create a mapped array that produces only the values when indexed.\n\nOnly useful for AD arrays, otherwise it does nothing.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.associated_entity-Tuple{JutulEquation}","page":"Jutul functions","title":"Jutul.associated_entity","text":"Return the domain entity the equation is associated with\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.associated_entity-Tuple{JutulVariables}","page":"Jutul functions","title":"Jutul.associated_entity","text":"The entity a variable is associated with, and can hold partial derivatives with respect to.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.cell_dims-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.cell_dims","text":"cell_dims(g, pos)::Tuple\n\nGet physical cell dimensions of cell with index pos for grid g.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.cell_index-Tuple{Any, Tuple}","page":"Jutul functions","title":"Jutul.cell_index","text":"cell_index(g, pos)\n\nGet linear (scalar) index of mesh cell from provided IJK tuple pos.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.compress_timesteps","page":"Jutul functions","title":"Jutul.compress_timesteps","text":"compress_timesteps(timesteps, forces = nothing; max_step = Inf)\n\nCompress a set of timesteps and forces to the largest possible steps that still covers the same interval and changes forces at exactly the same points in time, while being limited to a maximum size of max_step.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.compress_timesteps-Tuple{JutulCase}","page":"Jutul functions","title":"Jutul.compress_timesteps","text":"compress_timesteps(case::JutulCase; max_step = Inf)\n\nCompress time steps for a Jutul case. See compress_timesteps for the general case.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.compute_boundary_trans-Tuple{DataDomain, Any}","page":"Jutul functions","title":"Jutul.compute_boundary_trans","text":"compute_boundary_trans(d::DataDomain, perm)\n\nCompute the boundary half face transmissibilities for perm. The input perm can either be the symbol of some data defined on Cells(), a vector of numbers for each cell or a matrix with number of columns equal to the number of cells.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.compute_face_trans-Tuple{DataDomain, Vararg{Any}}","page":"Jutul functions","title":"Jutul.compute_face_trans","text":"computefacetrans(g::DataDomain, perm)\n\nCompute face trans for the interior faces. The input perm can either be the symbol of some data defined on Cells(), a vector of numbers for each cell or a matrix with number of columns equal to the number of cells.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.compute_half_face_trans-Tuple{DataDomain, Any}","page":"Jutul functions","title":"Jutul.compute_half_face_trans","text":"compute_half_face_trans(g::DataDomain, perm)\n\nCompute half-face trans for the interior faces. The input perm can either be the symbol of some data defined on Cells(), a vector of numbers for each cell or a matrix with number of columns equal to the number of cells.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.convergence_criterion-Tuple{Any, Any, JutulEquation, Any, Any}","page":"Jutul functions","title":"Jutul.convergence_criterion","text":"convergence_criterion(model, storage, eq, eq_s, r; dt = 1)\n\nGet the convergence criterion values for a given equation. Can be checked against the corresponding tolerances.\n\nArguments\n\nmodel: model that generated the current equation.\nstorage: global simulator storage.\neq::JutulEquation: equation implementation currently being checked\neq_s: storage for eq where values are contained.\nr: the local residual part corresponding to this model, as a matrix with column index equaling entity index\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.convert_from_si-Tuple{Any, String}","page":"Jutul functions","title":"Jutul.convert_from_si","text":"convert_from_si(value, unit_name::Union{Symbol, String})\n\nConvert value from SI representation to the unit in unit_symbol.\n\nExamples\n\njulia> convert_from_si(3600.0, :hour) # Get 3600 s represented as hours\n1.0\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.convert_state_ad","page":"Jutul functions","title":"Jutul.convert_state_ad","text":"Convert a state containing variables as arrays of doubles to a state where those arrays contain the same value as Dual types. The dual type is currently taken from ForwardDiff.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.convert_to_si-Tuple{Any, String}","page":"Jutul functions","title":"Jutul.convert_to_si","text":"convert_to_si(value, unit_name::String)\n\nConvert value to SI representation from value in the unit given by unit_symbol.\n\nExamples\n\njulia> convert_to_si(1.0, :hour) # Get 1 hour represented as seconds\n3600.0\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.coord_offset-Tuple{Any, AbstractFloat}","page":"Jutul functions","title":"Jutul.coord_offset","text":"Lower corner for one dimension, without any transforms applied\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.declare_pattern-Tuple{Any, Any, Any, Any, Vararg{Any}}","page":"Jutul functions","title":"Jutul.declare_pattern","text":"Give out source, target arrays of equal length for a given equation attached to the given model.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.declare_sparsity","page":"Jutul functions","title":"Jutul.declare_sparsity","text":"Give out I, J arrays of equal length for a given equation attached to the given model.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.degrees_of_freedom_per_entity-Tuple{Any, ScalarVariable}","page":"Jutul functions","title":"Jutul.degrees_of_freedom_per_entity","text":"Number of independent primary variables / degrees of freedom per computational entity.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.descalarize_primary_variable!-Tuple{Any, Any, Any, ScalarVariable, Any}","page":"Jutul functions","title":"Jutul.descalarize_primary_variable!","text":"descalarize_primary_variable!(dest_array, model, V, var::Jutul.ScalarVariable, index)\n\nDescalarize a primary variable, overwriting destarray at entity index. The AD status of entries in `destarray` will be retained.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.descalarize_primary_variables!","page":"Jutul functions","title":"Jutul.descalarize_primary_variables!","text":"descalarize_primary_variables!(state, model, V, pvars::NamedTuple = (; pairs(model.primary_variables)...), ind = eachindex(V))\n\nReplace valeus in state by the scalarized values found in V.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.dim-Tuple{JutulMesh}","page":"Jutul functions","title":"Jutul.dim","text":"dim(g)::Integer\n\nGet the dimension of a mesh.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.extra_debug_output!-NTuple{6, Any}","page":"Jutul functions","title":"Jutul.extra_debug_output!","text":"extra_debug_output!(report, storage, model, config, iteration, dt)\n\nAdd extra debug output to report during a nonlinear iteration.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.extract_submesh-Tuple{UnstructuredMesh, Any}","page":"Jutul functions","title":"Jutul.extract_submesh","text":"extract_submesh(g::UnstructuredMesh, cells)\n\nExtract a subgrid for a given mesh and a iterable of cells to keep.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.full_cell-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.full_cell","text":"Inner cell to local cell (full set)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_1d_interpolator-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.get_1d_interpolator","text":"get_1d_interpolator(xs, ys; <keyword arguments>)\n\nGet a 1D interpolator F(x) ≈ y for a table xs, ys that by default does constant extrapolation\n\nArguments\n\nxs: sorted list of parameter points.\nys: list of function values with equal length to xs\nmethod=LinearInterpolant: constructor for the interpolation. Defaults to LinearInterpolant which does simple linear interpolation.\ncap_endpoints = true: Add values so that the endpoints are capped (constant extrapolation). Otherwise, the extrapolation will match the method.\ncap_start = cap_endpoints: Fine-grained version of cap_endpoints for the start of the interval only (extrapolation for x < xs[1])\ncap_end = cap_endpoints:Fine-grained version of cap_endpoints for the end of the interval only (extrapolation for x > xs[end])\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_2d_interpolator-Tuple{Any, Any, Any}","page":"Jutul functions","title":"Jutul.get_2d_interpolator","text":"get_2d_interpolator(xs, ys, fs; method = BilinearInterpolant)\n\nFor xs of length nx and ys of length ny generate a 2D interpolation for values given as a nx by ny matrix.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_ad_entity_scalar-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real","page":"Jutul functions","title":"Jutul.get_ad_entity_scalar","text":"get_ad_entity_scalar(v::Real, npartials, diag_pos = nothing; <keyword_arguments>)\n\nGet scalar with partial derivatives as AD instance.\n\nArguments\n\nv::Real: Value of AD variable.\nnpartials: Number of partial derivatives each AD instance holds.\ndiag_pos = nothing: Position(s) of where to set 1 as the partial derivative instead of zero.\n\nKeyword arguments\n\ntag = nothing: Tag for AD instance. Two AD values of the different tag cannot interoperate to avoid perturbation confusion (see ForwardDiff documentation).\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_dependencies-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.get_dependencies","text":"Get dependencies of variable when viewed as a secondary variable. Normally autogenerated with @jutul_secondary\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_diagonal_entries-Tuple{JutulEquation, Any}","page":"Jutul functions","title":"Jutul.get_diagonal_entries","text":"get_diagonal_entries(eq::JutulEquation, eq_s)\n\nGet the diagonal entries of a cache, i.e. the entries where entity type and index equals that of the governing equation.\n\nNote: Be very careful about modifications to this array, as this is a view into the internal AD buffers and it is very easy to create inconsistent Jacobians.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_entity_tag-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.get_entity_tag","text":"get_entity_tag(basetag, entity)\n\nCombine a base tag (which can be nothing) with a entity to get a tag that captures base tag + entity tag for use with AD initialization.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_entries-Tuple{CompactAutoDiffCache}","page":"Jutul functions","title":"Jutul.get_entries","text":"Get entries of autodiff cache. Entries are AD vectors that hold values and derivatives.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_entries-Tuple{JutulEquation}","page":"Jutul functions","title":"Jutul.get_entries","text":"Get the entries of the main autodiff cache for an equation.\n\nNote: This only gets the .equation field's entries.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_mesh_entity_tag-Tuple{JutulMesh, Vararg{Any}}","page":"Jutul functions","title":"Jutul.get_mesh_entity_tag","text":"get_mesh_entity_tag(met::JutulMesh, entity::JutulEntity, tag_group::Symbol, tag_value = missing; throw = true)\n\nGet the indices tagged for entity in group tag_group, optionally for the specific tag_value. If ismissing(tag_value), the Dict containing the tag group will be returned.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_parameters-Tuple{SimulationModel}","page":"Jutul functions","title":"Jutul.get_parameters","text":"get_parameters(model::SimulationModel)\n\nGet the parameter definitions (as OrderedDict) for a given model.\n\nParameters are defined as static values in a forward simulation that combine with the primary variables to compute secondary variables and model equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_primary_variable_ordered_entities-Tuple{SimulationModel}","page":"Jutul functions","title":"Jutul.get_primary_variable_ordered_entities","text":"get_primary_variable_ordered_entities(model::SimulationModel)\n\nGet only the entities where primary variables are present, sorted by their order in the primary variables.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_primary_variables-Tuple{SimulationModel}","page":"Jutul functions","title":"Jutul.get_primary_variables","text":"get_primary_variables(model::SimulationModel)\n\nGet the primary variable definitions (as OrderedDict) for a given model.\n\nPrimary variables are sometimes referred to as solution variables or primary unknowns. The set of primary variables completely determines the state of the system together with the parameters.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_secondary_variables-Tuple{SimulationModel}","page":"Jutul functions","title":"Jutul.get_secondary_variables","text":"get_secondary_variables(model::SimulationModel)\n\nGet the secondary variable definitions (as OrderedDict) for a given model.\n\nSecondary variables are variables that can be computed from the primary variables together with the parameters.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_sparse_arguments-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.get_sparse_arguments","text":"get_sparse_arguments(storage, model)\n\nGet the [SparsePattern]@ref for the Jacobian matrix of a given simulator storage and corresponding model.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_tstr","page":"Jutul functions","title":"Jutul.get_tstr","text":"get_tstr(dT, lim = 3)\n\nGet formatted time string of dT given in seconds, limited to lim number of units.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.get_variable-Tuple{SimulationModel, Symbol}","page":"Jutul functions","title":"Jutul.get_variable","text":"get_variable(model::SimulationModel, name::Symbol)\n\nGet implementation of variable or parameter with name name for the model.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.get_variables-Tuple{SimulationModel}","page":"Jutul functions","title":"Jutul.get_variables","text":"get_variables(model::SimulationModel)\n\nGet all variable definitions (as OrderedDict) for a given model.\n\nThis is the union of get_secondary_variables and get_primary_variables.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.global_cell-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.global_cell","text":"Local cell -> global cell (full set)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.global_face-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.global_face","text":"Local face -> global face (full set)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.initialize_context!-NTuple{4, Any}","page":"Jutul functions","title":"Jutul.initialize_context!","text":"Initialize context when setting up a model\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.initialize_extra_state_fields!-Tuple{Any, JutulModel}","page":"Jutul functions","title":"Jutul.initialize_extra_state_fields!","text":"initialize_extra_state_fields!(state, model::JutulModel)\n\nAdd model-dependent changing variables that need to be in state, but are never AD variables themselves (for example status flags).\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.initialize_storage!-Tuple{Any, JutulModel}","page":"Jutul functions","title":"Jutul.initialize_storage!","text":"initialize_storage!(storage, model::JutulModel; initialize_state0 = true)\n\nInitialize the already allocated storage at the beginning of a simulation. Use this to e.g. set up extra stuff in state0 needed for initializing the simulation loop.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.initialize_variable_value-Tuple{Any, VectorVariables, AbstractVector}","page":"Jutul functions","title":"Jutul.initialize_variable_value","text":"Initializer for the value of non-scalar primary variables\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.interior_cell-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.interior_cell","text":"Local cell in full set -> inner cell (or zero)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.jutul_output_path","page":"Jutul functions","title":"Jutul.jutul_output_path","text":"pth = jutul_output_path(name = missing; subfolder = \"jutul\", basedir = missing, create = true)\n\nGet path for output. The final path will be found in /basedir/<subfolder/name. If subfolder=missing, the path will be set to /basedir/name instead. name will be autogenerated if not provided.\n\nPass the optional input create = false to avoid making the directory. To globally set the default output dir, set ENV[\"JUTUL_OUTPUT_PATH\"]to your desiredbasedir``.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.linear_timestep_selection","page":"Jutul functions","title":"Jutul.linear_timestep_selection","text":"linear_timestep_selection(x, x0, x1, dt0, dt1)\n\nProduce linear estimate of timestep dt for some value x from observed observations. If the observations have the same x or dt values, a simple scaling based on the x1 value is used.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.load_balanced_endpoint-Tuple{Any, Any, Any}","page":"Jutul functions","title":"Jutul.load_balanced_endpoint","text":"load_balanced_endpoint(block_index, nvals, nblocks)\n\nEndpoint for interval block_index that subdivides nvals into nblocks in a load balanced manner. This is done by adding one element to the first set of blocks whenever possible.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.load_balanced_interval-Tuple{Any, Any, Any}","page":"Jutul functions","title":"Jutul.load_balanced_interval","text":"load_balanced_interval(b, n, m)\n\nCreate UnitRange for block b ∈ [1, m] for interval of total length n\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.local_ad-Tuple{Any, Any, Any}","page":"Jutul functions","title":"Jutul.local_ad","text":"local_ad(state::T, index::I, ad_tag::∂T) where {T, I<:Integer, ∂T}\n\nCreate localad for state for index I of AD tag of type adtag\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.local_cell-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.local_cell","text":"Global cell -> local cell (full set)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.local_face-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.local_face","text":"Global face -> local face (full set)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.local_residual_view-NTuple{4, Any}","page":"Jutul functions","title":"Jutul.local_residual_view","text":"local_residual_view(r_buf, model, eq, equation_offset)\n\nGet a matrix view of the residual so that, independent of ordering, the column index corresponds to the entity index for the given equation eq starting at equation_offset in the global residual buffer r_buf.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.maximum_value-Tuple{JutulVariables}","page":"Jutul functions","title":"Jutul.maximum_value","text":"Upper (inclusive) limit for variable.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.merge_step_report_errors-Tuple{Any}","page":"Jutul functions","title":"Jutul.merge_step_report_errors","text":"merge_step_report_errors(data; fn = max)\n\nMerge step reports errors of the same type using a pair wise reduction (default: max)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.minimum_value-Tuple{JutulVariables}","page":"Jutul functions","title":"Jutul.minimum_value","text":"Lower (inclusive) limit for variable.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.model_accumulation!","page":"Jutul functions","title":"Jutul.model_accumulation!","text":"model_accumulation!(acc, sim::HelperSimulator, x, dt = 1.0;\n    forces = setup_forces(sim.model),\n    update_secondary = true,\n    kwarg...\n)\n\nCompute the accumulation term into Vector acc.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.model_residual!","page":"Jutul functions","title":"Jutul.model_residual!","text":"model_residual!(r, sim, x, x0 = missing, dt = 1.0;\n    forces = setup_forces(sim.model),\n    include_accumulation = true,\n    kwarg...\n)\n\nFill in the model residual into Vector r.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.model_residual-Union{Tuple{T}, Tuple{HelperSimulator{<:Any, <:Any, <:Any, T}, Any, Vararg{Any}}} where T","page":"Jutul functions","title":"Jutul.model_residual","text":"model_residual(sim::HelperSimulator, x, y = missing; kwarg...)\n\nOut of place version of model_residual!\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_cells-Tuple{JutulMesh}","page":"Jutul functions","title":"Jutul.number_of_cells","text":"number_of_cells(g)::Integer\n\nGet the number of cells in a mesh.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_degrees_of_freedom-Tuple{JutulModel}","page":"Jutul functions","title":"Jutul.number_of_degrees_of_freedom","text":"Total number of degrees of freedom for a model, over all primary variables and all entities.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_entities-Tuple{Any, JutulEquation}","page":"Jutul functions","title":"Jutul.number_of_entities","text":"Get the number of entities (e.g. the number of cells) that the equation is defined on.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_entities-Tuple{Any, JutulVariables}","page":"Jutul functions","title":"Jutul.number_of_entities","text":"Number of entities (e.g. Cells, Faces) a variable is defined on. By default, each primary variable exists on all cells of a discretized domain\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_entities-Tuple{JutulAutoDiffCache}","page":"Jutul functions","title":"Jutul.number_of_entities","text":"Get number of entities a cache is defined on.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_entities-Tuple{T} where T<:(AbstractVector)","page":"Jutul functions","title":"Jutul.number_of_entities","text":"Number of entities for vector stored in state (just the number of elements)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_entities-Tuple{T} where T<:AbstractArray","page":"Jutul functions","title":"Jutul.number_of_entities","text":"Number of entities for matrix stored in state (convention is number of columns)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_equations-Tuple{Any, JutulEquation}","page":"Jutul functions","title":"Jutul.number_of_equations","text":"Get the total number of equations on the domain of model.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_equations_per_entity-Tuple{JutulModel, JutulEquation}","page":"Jutul functions","title":"Jutul.number_of_equations_per_entity","text":"Get the number of equations per entity. For example, mass balance of two components will have two equations per grid cell (= entity)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_faces-Tuple{Any}","page":"Jutul functions","title":"Jutul.number_of_faces","text":"number_of_faces(g)::Integer\n\nGet the number of faces in a mesh.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_partials_per_entity-Tuple{SimulationModel, JutulEntity}","page":"Jutul functions","title":"Jutul.number_of_partials_per_entity","text":"number_of_partials_per_entity(model::SimulationModel, entity::JutulEntity)\n\nGet the number of local partial derivatives per entity in a model for a given JutulEntity. This is the sum of degrees_of_freedom_per_entity for all primary variables defined on entity.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.number_of_values","page":"Jutul functions","title":"Jutul.number_of_values","text":"Total number of values for a model, for a given type of variables over all entities\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.numerical_eltype-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Jutul functions","title":"Jutul.numerical_eltype","text":"numerical_eltype(x::AbstractArray{T}) where T\n\nGet the numerical eltype (i.e. the inner type of the element type that could potentially be AD)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.numerical_type-Tuple{T} where T<:Real","page":"Jutul functions","title":"Jutul.numerical_type","text":"numerical_type(::T) where T\n\nGet the numerical eltype (i.e. the inner type of the element type that could potentially be AD). This function should be overloaded if you have a custom type that wraps a numeric/potentially AD type.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.partition","page":"Jutul functions","title":"Jutul.partition","text":"partition(N::AbstractMatrix, num_coarse, weights = ones(size(N, 2)); partitioner = MetisPartitioner(), groups = nothing, n = maximum(N), group_by_weights = false, buffer_group = true)\n\nPartition based on neighborship (with optional groups kept contigious after partitioning)\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.partition_hypergraph","page":"Jutul functions","title":"Jutul.partition_hypergraph","text":"partition_hypergraph(g, n::Int, partitioner = MetisPartitioner(); expand = true)\n\nPartition a hypergraph from setup_partitioner_hypergraph using a given partitioner. If the optional expand parameter is set to true the result will be expanded to the full graph (i.e. where groups are not condensed).\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.physical_representation-Tuple{Any}","page":"Jutul functions","title":"Jutul.physical_representation","text":"physical_representation(x)\n\nGet the physical representation of an object. The physical representation is usually some kind of mesh or domain that represents a physical domain.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.physical_representation-Tuple{DataDomain}","page":"Jutul functions","title":"Jutul.physical_representation","text":"physical_representation(x::DataDomain)\n\nGet the underlying physical representation (domain or mesh) that is wrapped.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.physical_representation-Tuple{DiscretizedDomain}","page":"Jutul functions","title":"Jutul.physical_representation","text":"physical_representation(x::DiscretizedDomain)\n\nGet the underlying physical representation (domain or mesh) that was discretized.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.physical_representation-Tuple{SimulationModel}","page":"Jutul functions","title":"Jutul.physical_representation","text":"physical_representation(m::SimulationModel)\n\nGet the underlying physical representation for the model (domain or mesh)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.read_results-Tuple{Any}","page":"Jutul functions","title":"Jutul.read_results","text":"states, reports = readresults(pth; readstates = true, read_reports = true)\n\nRead results from a given output_path provded to simulate or simulator_config.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.relative_increment_limit-Tuple{JutulVariables}","page":"Jutul functions","title":"Jutul.relative_increment_limit","text":"Relative allowable change for variable during a nonlinear update. A variable with value |x| and relative limit 0.2 cannot change more than |x|*0.2.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.replace_variables!-Tuple{Any}","page":"Jutul functions","title":"Jutul.replace_variables!","text":"replace_variables!(model, throw = true, varname = vardef, varname2 = vardef2)\n\nReplace one or more variables that already exists (primary, secondary or parameters).\n\nArguments\n\nmodel: instance where variables is to be replaced\nvarname=vardef::JutulVariables: replace variable with varname by vardef\nthrow=true: throw an error if the named variable definition is not found in primary or secondary, otherwise silently return\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.scalarize_primary_variable-Tuple{Any, Any, ScalarVariable, Any}","page":"Jutul functions","title":"Jutul.scalarize_primary_variable","text":"scalarize_primary_variable(model, source_vec, var::Jutul.ScalarVariable, index)\n\nScalarize a primary variable. For scalars, this means getting the value itself.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.scalarize_primary_variables","page":"Jutul functions","title":"Jutul.scalarize_primary_variables","text":"scalarize_primary_variables(model, state, pvars = model.primary_variables)\n\nCreate a vector where each entry corresponds to a tuple of values that minimally defines the given variables. All variables must belong to the same type of entity. This is checked by this function.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.scalarize_primary_variables!-Union{Tuple{T}, Tuple{Array{Jutul.ScalarizedJutulVariables{T}, 1}, Any, Any, NamedTuple}} where T","page":"Jutul functions","title":"Jutul.scalarize_primary_variables!","text":"scalarize_primary_variables!(V::Vector{T}, model, state, pvars::NamedTuple) where T\n\nScalarize into array. See scalarizeprimaryvariables for more details.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.scalarized_primary_variable_type-Tuple{Any, ScalarVariable}","page":"Jutul functions","title":"Jutul.scalarized_primary_variable_type","text":"scalarized_primary_variable_type(model, var::Jutul.ScalarVariable)\n\nGet the type of a scalarized numerical variable (=Float64 for variables that are already represented as scalars)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.set_default_tolerances-Tuple{Any}","page":"Jutul functions","title":"Jutul.set_default_tolerances","text":"set_default_tolerances(model)\n\nSet default tolerances for the nonlinear convergence check of the governing equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.set_parameters!-Tuple{Any}","page":"Jutul functions","title":"Jutul.set_parameters!","text":"set_parameters!(model, parname = pardef)\n\nSet a parameter with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.set_primary_variables!-Tuple{Any}","page":"Jutul functions","title":"Jutul.set_primary_variables!","text":"set_primary_variables!(model, varname = vardef)\nset_primary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a primary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.set_secondary_variables!-Tuple{Any}","page":"Jutul functions","title":"Jutul.set_secondary_variables!","text":"set_secondary_variables!(model, varname = vardef)\nset_secondary_variables!(model, varname1 = vardef1, varname2 = vardef2)\n\nSet a secondary variable with name varname to the definition vardef (adding if it does not exist)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.setup_adjoint_storage-Tuple{Any}","page":"Jutul functions","title":"Jutul.setup_adjoint_storage","text":"setup_adjoint_storage(model; state0 = setup_state(model), parameters = setup_parameters(model))\n\nSet up storage for use with solve_adjoint_sensitivities!.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.setup_forces-Tuple{JutulModel}","page":"Jutul functions","title":"Jutul.setup_forces","text":"setup_forces(model::JutulModel; force_name = force_value)\n\nSet up forces for a given model. Keyword arguments varies depending on what the model supports.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.setup_parameter_optimization-Tuple{Any, Any, Any, Any, Any, Any, Vararg{Any}}","page":"Jutul functions","title":"Jutul.setup_parameter_optimization","text":"setup_parameter_optimization(model, state0, param, dt, forces, G, opt_cfg = optimization_config(model, param);\n                                                        grad_type = :adjoint,\n                                                        config = nothing,\n                                                        print = 1,\n                                                        copy_case = true,\n                                                        param_obj = false,\n                                                        kwarg...)\n\nSet up function handles for optimizing the case defined by the inputs to simulate together with a per-timestep objective function G.\n\nGenerally calling either of the functions will mutate the data Dict. The options are: Fo(x) -> evaluate objective dFo(dFdx, x) -> evaluate gradient of objective, mutating dFdx (may trigger evaluation of Fo) Fand_dF(F, dFdx, x) -> evaluate F and/or dF. Value of nothing will mean that the corresponding entry is skipped.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.setup_parameters-Tuple{DataDomain, JutulModel}","page":"Jutul functions","title":"Jutul.setup_parameters","text":"setup_parameters(model::JutulModel; name = value)\n\nSet up a parameter storage for a given model with values for the parameter defined in the model.\n\nArguments\n\nname=value: The name of the parameter together with the value(s) of the parameter.\n\nA scalar (or short vector of the right size for VectorVariables) will be repeated over the entire domain, while a vector (or matrix for VectorVariables) with length (number of columns for VectorVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.setup_partitioner_hypergraph-Tuple{Matrix{Int64}}","page":"Jutul functions","title":"Jutul.setup_partitioner_hypergraph","text":"setup_partitioner_hypergraph(N::Matrix{Int};\n    num_nodes::Int = maximum(N),\n    num_edges::Int = size(N, 2),\n    node_weights::Vector{Int} = ones(Int, num_nodes),\n    edge_weights::Vector{Int} = ones(Int, num_edges),\n    groups = [Int[]]\n)\n\nSet up a hypergraph structure for a given neighborship matrix. N should be a matrix with two rows, with one pair of cells in each column. Optionally node and edge weights can be provided. If a list of groups are provided, these nodes will be accumulated together in the hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.setup_state!","page":"Jutul functions","title":"Jutul.setup_state!","text":"setup_state!(state, model::JutulModel, init_values::AbstractDict = Dict())\n\nInitialize primary variables and other state fields, given initial values as a Dict\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.setup_state-Tuple{JutulModel, Vararg{Any}}","page":"Jutul functions","title":"Jutul.setup_state","text":"setup_state(model::JutulModel, name1 = value1, name2 = value2)\n\nSet up a state for a given model with values for the primary variables defined in the model. Normally all primary variables must be initialized in this way.\n\nArguments\n\nname=value: The name of the primary variable together with the value(s) used to initialize the primary variable.\n\nA scalar (or short vector of the right size for VectorVariables) will be repeated over the entire domain, while a vector (or matrix for VectorVariables) with length (number of columns for VectorVariables) equal to the entity count (for example, number of cells for a cell variable) will be used directly.\n\nNote: You likely want to overload [setup_state!]@ref for a custom model instead of setup_state\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.setup_state_and_parameters-Tuple{DataDomain, JutulModel, AbstractDict}","page":"Jutul functions","title":"Jutul.setup_state_and_parameters","text":"state, prm = setup_state_and_parameters(model, init)\n\nSimultaneously set up state and parameters from a single init file (typically a Dict containing values that might either be initial values or parameters)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.setup_storage!-Tuple{Any, JutulModel}","page":"Jutul functions","title":"Jutul.setup_storage!","text":"setup_storage!(storage, model::JutulModel; setup_linearized_system = true,\n                                                setup_equations = true,\n                                                state0 = setup_state(model),\n                                                parameters = setup_parameters(model),\n                                                tag = nothing,\n                                                state0_ad = false,\n                                                state_ad = true,\n                                                kwarg...)\n\nAllocate storage for a given model. The storage consists of all dynamic quantities used in the simulation. The default implementation allocates properties, equations and linearized system.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.setup_storage-Tuple{JutulModel}","page":"Jutul functions","title":"Jutul.setup_storage","text":"setup_storage(model::JutulModel; kwarg...)\n\nAllocate storage for the model. You should overload setup_storage! if you have a custom definition.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.si_unit-Tuple{Symbol}","page":"Jutul functions","title":"Jutul.si_unit","text":"si_unit(u::Union{String, Symbol})\n\nGet the multiplicative SI unit conversion factor for a single unit. The return value is given so that x*si_unit(:name) will convert x to the SI representation of the unit with the given name.\n\nExamples\n\njulia> si_unit(:day) # Get days represented as seconds\n86400.0\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.si_units-Tuple","page":"Jutul functions","title":"Jutul.si_units","text":"si_units(u1, arg...)\n\nGet multiplicative SI unit conversion factors for multiple units simultaneously. The return value will be a Tuple of values, one for each input argument. Each input arguments can be either a String a Symbol.\n\nExamples\n\njulia> meter, hour = si_units(:meter, :hour)\n(1.0, 3600.0)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}","page":"Jutul functions","title":"Jutul.simulate!","text":"simulate!(sim::JutulSimulator, timesteps::AbstractVector; forces = nothing,\n                                                               config = nothing,\n                                                               initialize = true,\n                                                               restart = nothing,\n                                                               state0 = nothing,\n                                                               parameters = nothing,\n                                                               kwarg...)\n\nNon-allocating (or perhaps less allocating) version of simulate!.\n\nArguments\n\ninitialize=true: Perform internal updates as if this is the first time \n\nSee also simulate for additional supported input arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}","page":"Jutul functions","title":"Jutul.simulate","text":"simulate(state0, model, timesteps, parameters = setup_parameters(model))\nsimulate(state0, model, timesteps, info_level = 3)\nsimulate(state0, model, timesteps; <keyword arguments>)\n\nSimulate a set of timesteps with model for the given initial state0 and optionally specific parameters. Additional keyword arguments are passed onto simulator_config and simulate!. This interface is primarily for convenience, as all storage for the simulator is allocated upon use and discared upon return. If you want to perform multiple simulations with the same model it is advised to instead instantiate Simulator  and combine it with simulate!.\n\nArguments\n\nstate0::Dict: initial state, typically created using setup_state for the model in use.\nmodel::JutulModel: model that describes the discretized system to solve, for example SimulationModel or MultiModel.\ntimesteps::AbstractVector: Vector of desired report steps. The simulator will perform time integration until sum(timesteps)  is reached, providing outputs at the end of each report step.\nparameters=setup_parameters(model): Optional overrides the default parameters for the model.\nforces=nothing: Either nothing (for no forces), a single set of forces from setup_forces(model) or a Vector of such forces with equal length to timesteps.\nrestart=nothing: If an integer is provided, the simulation will attempt to restart from that step. Requires that output_path is provided here or in the config.\nconfig=simulator_config(model): Configuration Dict that holds many fine grained settings for output, linear solver, time-steps, outputs etc.\n\nAdditional arguments are passed onto simulator_config.\n\nSee also simulate!, Simulator, SimulationModel, simulator_config.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.simulate-Tuple{Any, JutulSimulator, AbstractVector}","page":"Jutul functions","title":"Jutul.simulate","text":"simulate(state0, sim::JutulSimulator, timesteps::AbstractVector; parameters = nothing, kwarg...)\n\nSimulate a set of timesteps with simulator for the given initial state0 and optionally specific parameters.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.simulator_config-Tuple{Any}","page":"Jutul functions","title":"Jutul.simulator_config","text":"simulator_config(sim; info_level = 3, linear_solver = GenericKrylov())\n\nSet up a simulator configuration object that can be passed onto simulate!.\n\nThere are many options available to configure a given simulator. The best way to get an overview of these possible configuration options is to instatiate the config without any arguments and inspecting the resulting table by calling simulator_config(sim) in the REPL.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.solve_adjoint_sensitivities!-NTuple{6, Any}","page":"Jutul functions","title":"Jutul.solve_adjoint_sensitivities!","text":"solve_adjoint_sensitivities!(∇G, storage, states, state0, timesteps, G; forces = setup_forces(model))\n\nNon-allocating version of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.solve_adjoint_sensitivities-NTuple{4, Any}","page":"Jutul functions","title":"Jutul.solve_adjoint_sensitivities","text":"solve_adjoint_sensitivities(model, states, reports, G; extra_timing = false, state0 = setup_state(model), forces = setup_forces(model), raw_output = false, kwarg...)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nSolves the adjoint equations: For model equations F the gradient with respect to parameters p is     ∇ₚG = Σₙ (∂Fₙ / ∂p)ᵀ λₙ where n ∈ [1, N]. Given Lagrange multipliers λₙ from the adjoint equations     (∂Fₙ / ∂xₙ)ᵀ λₙ = - (∂J / ∂xₙ)ᵀ - (∂Fₙ₊₁ / ∂xₙ)ᵀ λₙ₊₁ where the last term is omitted for step n = N and G is the objective function.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.solve_numerical_sensitivities-NTuple{5, Any}","page":"Jutul functions","title":"Jutul.solve_numerical_sensitivities","text":"solve_numerical_sensitivities(model, states, reports, G, target;\n                                            forces = setup_forces(model),\n                                            state0 = setup_state(model),\n                                            parameters = setup_parameters(model),\n                                            epsilon = 1e-8)\n\nCompute sensitivities of model parameter with name target for objective function G.\n\nThis method uses numerical perturbation and is primarily intended for testing of solve_adjoint_sensitivities.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.solve_timestep!-NTuple{5, Any}","page":"Jutul functions","title":"Jutul.solve_timestep!","text":"solve_timestep!(sim, dT, forces, max_its, config; <keyword arguments>)\n\nInternal function for solving a single time-step with fixed driving forces.\n\nArguments\n\nsim: Simulator instance.\ndT: time-step to be solved\nforces: Driving forces for the time-step\nmax_its: Maximum number of steps/Newton iterations.\nconfig: Configuration for solver (typically output from simulator_config).\n\nNote: This function is exported for fine-grained simulation workflows. The general simulate interface is both easier to use and performs additional validation.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.subvariable-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.subvariable","text":"subvariable(var, map)\n\nGet subvariable of Jutul variable\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.successful_reports","page":"Jutul functions","title":"Jutul.successful_reports","text":"successful_reports(old_reports, current_reports, step_index, n = 1)\n\nGet the n last successful solve reports from all previous reports (old_reports) and the current ministep set.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.synchronize-Tuple{JutulContext}","page":"Jutul functions","title":"Jutul.synchronize","text":"Synchronize backend after allocations.\n\nSome backends may require notification that storage has been allocated.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.tpfv_geometry","page":"Jutul functions","title":"Jutul.tpfv_geometry","text":"tpfv_geometry(g)\n\nGenerate two-point finite-volume geometry for a given grid, if supported.\n\nSee also TwoPointFiniteVolumeGeometry.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.transfer-Tuple{Any, Any}","page":"Jutul functions","title":"Jutul.transfer","text":"Transfer v to the representation expected by a given context.\n\nFor the defalt context, the transfer function does nothing. For other context such as the CUDA version, it may convert integers and floats to other types (e.g. Float32) and Arrays to CuArrays.\n\nYou will likely have to implement some transfer operators for your own types if you want to simulate with a non-default context.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.two_point_potential_drop-NTuple{5, Real}","page":"Jutul functions","title":"Jutul.two_point_potential_drop","text":"Two-point potential drop with gravity (generic)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.unsafe_reinterpret-Tuple{Any, Any, Any}","page":"Jutul functions","title":"Jutul.unsafe_reinterpret","text":"unsafe_reinterpret(Vt, v, n)\n\nUnsafely reinterpret v as a n length vector of value type Vt\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.update_before_step!-NTuple{4, Any}","page":"Jutul functions","title":"Jutul.update_before_step!","text":"\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.update_equation!-Tuple{Any, JutulEquation, Any, Any, Any}","page":"Jutul functions","title":"Jutul.update_equation!","text":"Update equation based on currently stored properties\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.update_equations!","page":"Jutul functions","title":"Jutul.update_equations!","text":"update_equations!(storage, model, dt = nothing)\n\nUpdate the governing equations using the current set of primary variables, parameters and secondary variables. Does not fill linearized system.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.update_equations_and_apply_forces!-NTuple{4, Any}","page":"Jutul functions","title":"Jutul.update_equations_and_apply_forces!","text":"update_equations_and_apply_forces!(storage, model, dt, forces; time = NaN)\n\nUpdate the model equations and apply boundary conditions and forces. Does not fill linearized system.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.update_linearized_system!","page":"Jutul functions","title":"Jutul.update_linearized_system!","text":"update_linearized_system!(storage, model::JutulModel; <keyword arguments>)\n\nUpdate the linearized system with the current set of equations.\n\n\n\n\n\n","category":"function"},{"location":"ref/jutul/#Jutul.update_linearized_system_equation!-Tuple{AbstractArray, Any, Any, JutulEquation, CompactAutoDiffCache}","page":"Jutul functions","title":"Jutul.update_linearized_system_equation!","text":"Update a linearized system based on the values and derivatives in the equation.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.update_secondary_variable!-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}","page":"Jutul functions","title":"Jutul.update_secondary_variable!","text":"Update a secondary variable. Normally autogenerated with @jutul_secondary\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.update_state_dependents!-Tuple{Any, JutulModel, Any, Any}","page":"Jutul functions","title":"Jutul.update_state_dependents!","text":"update_state_dependents!(storage, model, dt, forces; time = NaN, update_secondary = true)\n\nPerform updates of everything that depends on the state: A full linearization for the current primary variables.\n\nThis includes properties, governing equations and the linearized system itself.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.update_values!-Tuple{AbstractArray, AbstractArray}","page":"Jutul functions","title":"Jutul.update_values!","text":"update_values!(x, dx)\n\nReplace values (for non-Real types, direct assignment)\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.update_values!-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}}","page":"Jutul functions","title":"Jutul.update_values!","text":"update_values!(x, dx)\n\nReplace values of x in-place by y, leaving x with the values of y and the partials of x.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.value-Tuple{AbstractDict}","page":"Jutul functions","title":"Jutul.value","text":"value(d::Dict)\n\nCall value on all elements of some Dict.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.value-Tuple{Any}","page":"Jutul functions","title":"Jutul.value","text":"Take value of AD.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.values_per_entity-Tuple{Any, JutulVariables}","page":"Jutul functions","title":"Jutul.values_per_entity","text":"Number of values held by a primary variable. Normally this is equal to the number of degrees of freedom, but some special primary variables are most conveniently defined by having N values and N-1 independent variables.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.variable_scale-Tuple{JutulVariables}","page":"Jutul functions","title":"Jutul.variable_scale","text":"Define a \"typical\" numerical value for a variable to scale the linear system entries.\n\n\n\n\n\n","category":"method"},{"location":"ref/jutul/#Jutul.@jutul_secondary-Tuple{Any}","page":"Jutul functions","title":"Jutul.@jutul_secondary","text":"Designate the function as updating a secondary variable.\n\nA generic evaluator is then defined, together with a function for getting the dependencies of that function upon the state. This is most easily documented with an example. If we define the following function annotated with the macro when updating the array containing the values of MyVarType realized for some model:\n\n@jutul_secondary function some_fn!(target, var::MyVarType, model, a, b, c, ix)\n    for i in ix\n        target[i] = a[i] + b[i] / c[i]\n    end\nend\n\nThe purpose of the macro is to translate this into two functions. The first defines for the dependencies of the function with respect to the fields of the state (primary variables, secondary variables and parameters):\n\nfunction get_dependencies(var::MyVarType, model)\n   return (:a, :b, :c)\nend\n\nThe second function defines a generic version that takes in state, and automatically expands the set of dependencies into getfield calls.\n\nfunction update_secondary_variable!(array_target, var::MyVarType, model, state, ix)\n    some_fn!(array_target, var, model, state.a, state.b, state.c, ix)\nend\n\nNote that the input names of arguments 4 to end-1 matter, as these will be fetched from state, exactly as written.\n\n\n\n\n\n","category":"macro"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"EditURL = \"../../../examples/two_phase_buckley_leverett.jl\"","category":"page"},{"location":"examples/two_phase_buckley_leverett/#Buckley-Leverett-two-phase-problem","page":"Two-phase Buckley-Leverett","title":"Buckley-Leverett two-phase problem","text":"","category":"section"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"The Buckley-Leverett test problem is a classical reservoir simulation benchmark that demonstrates the nonlinear displacement process of a viscous fluid being displaced by a less viscous fluid, typically taken to be water displacing oil.","category":"page"},{"location":"examples/two_phase_buckley_leverett/#Problem-definition","page":"Two-phase Buckley-Leverett","title":"Problem definition","text":"","category":"section"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"This is a simple model without wells, where the flow is driven by a simple source term and a simple constant pressure boundary condition at the outlet. We define a function that sets up a two-phase system, a simple 1D domain and replaces the default relative permeability functions with quadratic functions:","category":"page"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"k_ralpha(S) = min left(fracS - S_r1 - S_r 1right)^n S_r = 02 n = 2","category":"page"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"In addition, the phase viscosities are treated as constant parameters of 1 and 5 centipoise for the displacing and resident fluids, respectively.","category":"page"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"The function is parametrized on the number of cells and the number of time-steps used to solve the model. This function, since it uses a relatively simple setup without wells, uses the Jutul functions directly.","category":"page"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"using JutulDarcy, Jutul\nfunction solve_bl(;nc = 100, time = 1.0, nstep = nc)\n    T = time\n    tstep = repeat([T/nstep], nstep)\n    domain = get_1d_reservoir(nc)\n    nc = number_of_cells(domain)\n    timesteps = tstep*3600*24\n    bar = 1e5\n    p0 = 100*bar\n    sys = ImmiscibleSystem((LiquidPhase(), VaporPhase()))\n    model = SimulationModel(domain, sys)\n    kr = BrooksCoreyRelativePermeabilities(sys, [2.0, 2.0], [0.2, 0.2])\n    replace_variables!(model, RelativePermeabilities = kr)\n    tot_time = sum(timesteps)\n    pv = pore_volume(domain)\n    irate = 500*sum(pv)/tot_time\n    src  = SourceTerm(1, irate, fractional_flow = [1.0, 0.0])\n    bc = FlowBoundaryCondition(nc, p0/2)\n    forces = setup_forces(model, sources = src, bc = bc)\n    parameters = setup_parameters(model, PhaseViscosities = [1e-3, 5e-3]) # 1 and 5 cP\n    state0 = setup_state(model, Pressure = p0, Saturations = [0.0, 1.0])\n    states, report = simulate(state0, model, timesteps,\n        forces = forces, parameters = parameters, info_level = -1)\n    return states, model, report\nend","category":"page"},{"location":"examples/two_phase_buckley_leverett/#Run-the-base-case","page":"Two-phase Buckley-Leverett","title":"Run the base case","text":"","category":"section"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"We solve a small model with 100 cells and 100 steps to serve as the baseline.","category":"page"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"n, n_f = 100, 1000\nstates, model, report = solve_bl(nc = n)\nprint_stats(report)","category":"page"},{"location":"examples/two_phase_buckley_leverett/#Run-refined-version-(1000-cells,-1000-steps)","page":"Two-phase Buckley-Leverett","title":"Run refined version (1000 cells, 1000 steps)","text":"","category":"section"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"Using a grid with 100 cells will not yield a fully converged solution. We can increase the number of cells at the cost of increasing the runtime a bit. Note that most of the time is spent in the linear solver, which uses a direct sparse LU factorization by default. For larger problems it is recommended to use an iterative solver.","category":"page"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"states_refined, _, report_refined = solve_bl(nc = n_f);\nprint_stats(report_refined)","category":"page"},{"location":"examples/two_phase_buckley_leverett/#Plot-results","page":"Two-phase Buckley-Leverett","title":"Plot results","text":"","category":"section"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"We plot the saturation front for the base case at different times together with the final solution for the refined model. In this case, refining the grid by a factor 10 gave us significantly less smearing of the trailing front.","category":"page"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"using CairoMakie\nx = range(0, stop = 1, length = n)\nx_f = range(0, stop = 1, length = n_f)\nf = Figure()\nax = Axis(f[1, 1], ylabel = \"Saturation\", title = \"Buckley-Leverett\")\nfor i in 1:6:length(states)\n    lines!(ax, x, states[i][:Saturations][1, :], color = :darkgray)\nend\nlines!(ax, x_f, states_refined[end][:Saturations][1, :], color = :red)\nf","category":"page"},{"location":"examples/two_phase_buckley_leverett/#Example-on-GitHub","page":"Two-phase Buckley-Leverett","title":"Example on GitHub","text":"","category":"section"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"If you would like to run this example yourself, it can be downloaded from the JutulDarcy.jl GitHub repository.","category":"page"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"","category":"page"},{"location":"examples/two_phase_buckley_leverett/","page":"Two-phase Buckley-Leverett","title":"Two-phase Buckley-Leverett","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"EditURL = \"../../../examples/optimize_simple_bl.jl\"","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"using Jutul\nusing JutulDarcy\nusing LinearAlgebra\nusing CairoMakie","category":"page"},{"location":"examples/optimize_simple_bl/#Example-demonstrating-optimzation-of-parameters-against-observations","page":"Parameter optimization of Buckley-Leverett","title":"Example demonstrating optimzation of parameters against observations","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"We create a simple test problem: A 1D nonlinear displacement. The observations are generated by solving the same problem with the true parameters. We then match the parameters against the observations using a different starting guess for the parameters, but otherwise the same physical description of the system.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"function setup_bl(;nc = 100, time = 1.0, nstep = 100, poro = 0.1, perm = 9.8692e-14)\n    T = time\n    tstep = repeat([T/nstep], nstep)\n    G = get_1d_reservoir(nc, poro = poro, perm = perm)\n    nc = number_of_cells(G)\n\n    bar = 1e5\n    p0 = 1000*bar\n    sys = ImmiscibleSystem((LiquidPhase(), VaporPhase()))\n    model = SimulationModel(G, sys)\n    model.primary_variables[:Pressure] = Pressure(minimum = -Inf, max_rel = nothing)\n    kr = BrooksCoreyRelativePermeabilities(sys, [2.0, 2.0])\n    replace_variables!(model, RelativePermeabilities = kr)\n    tot_time = sum(tstep)\n\n    parameters = setup_parameters(model, PhaseViscosities = [1e-3, 5e-3]) # 1 and 5 cP\n    state0 = setup_state(model, Pressure = p0, Saturations = [0.0, 1.0])\n\n    irate = 100*sum(parameters[:FluidVolume])/tot_time\n    src  = [SourceTerm(1, irate, fractional_flow = [1.0-1e-3, 1e-3]),\n            SourceTerm(nc, -irate, fractional_flow = [1.0, 0.0])]\n    forces = setup_forces(model, sources = src)\n\n    return (model, state0, parameters, forces, tstep)\nend","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"Number of cells and time-steps","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"N = 100\nNt = 100\nporo_ref = 0.1\nperm_ref = 9.8692e-14","category":"page"},{"location":"examples/optimize_simple_bl/#Set-up-and-simulate-reference","page":"Parameter optimization of Buckley-Leverett","title":"Set up and simulate reference","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"model_ref, state0_ref, parameters_ref, forces, tstep = setup_bl(nc = N, nstep = Nt, poro = poro_ref, perm = perm_ref)\nstates_ref, = simulate(state0_ref, model_ref, tstep, parameters = parameters_ref, forces = forces, info_level = -1)","category":"page"},{"location":"examples/optimize_simple_bl/#Set-up-another-case-where-the-porosity-is-different","page":"Parameter optimization of Buckley-Leverett","title":"Set up another case where the porosity is different","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"model, state0, parameters, = setup_bl(nc = N, nstep = Nt, poro = 2*poro_ref, perm = 1.0*perm_ref)\nstates, rep = simulate(state0, model, tstep, parameters = parameters, forces = forces, info_level = -1)","category":"page"},{"location":"examples/optimize_simple_bl/#Plot-the-results","page":"Parameter optimization of Buckley-Leverett","title":"Plot the results","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"fig = Figure()\nax = Axis(fig[1, 1], title = \"Saturation\")\nlines!(ax, states_ref[end][:Saturations][1, :], label = \"Reference\")\nlines!(ax, states[end][:Saturations][1, :], label = \"Initial guess\")\naxislegend(ax)\nax = Axis(fig[1, 2], title = \"Pressure\")\nlines!(ax, states_ref[end][:Pressure], label = \"Reference\")\nlines!(ax, states[end][:Pressure], label = \"Initial guess\")\naxislegend(ax)\nfig","category":"page"},{"location":"examples/optimize_simple_bl/#Define-objective-function","page":"Parameter optimization of Buckley-Leverett","title":"Define objective function","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"Define objective as mismatch between water saturation in current state and reference state. The objective function is currently a sum over all time steps. We implement a function for one term of this sum.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"function mass_mismatch(m, state, dt, step_no, forces)\n    state_ref = states_ref[step_no]\n    fld = :Saturations\n    val = state[fld]\n    ref = state_ref[fld]\n    err = 0\n    for i in axes(val, 2)\n        err += (val[1, i] - ref[1, i])^2\n    end\n    return dt*err\nend\n@assert Jutul.evaluate_objective(mass_mismatch, model, states_ref, tstep, forces) == 0.0\n@assert Jutul.evaluate_objective(mass_mismatch, model, states, tstep, forces) > 0.0","category":"page"},{"location":"examples/optimize_simple_bl/#Set-up-a-configuration-for-the-optimization.-This-by-default-enables-all-parameters-for","page":"Parameter optimization of Buckley-Leverett","title":"Set up a configuration for the optimization. This by default enables all parameters for","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"optimization, with relative box limits 0.1 and 10 specified here. If use_scaling is enabled the variables in the optimization are scaled so that their actual limits are approximately box limits.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"We are not interested in matching gravity effects or viscosity here. Transmissibilities are derived from permeability and varies significantly. We can set log scaling to get a better conditioned optimization system, without changing the limits or the result.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"cfg = optimization_config(model, parameters, use_scaling = true, rel_min = 0.1, rel_max = 10)\nfor (ki, vi) in cfg\n    if ki in [:TwoPointGravityDifference, :PhaseViscosities]\n        vi[:active] = false\n    end\n    if ki == :Transmissibilities\n        vi[:scaler] = :log\n    end\nend\nprint_obj = 100","category":"page"},{"location":"examples/optimize_simple_bl/#Set-up-parameter-optimization.","page":"Parameter optimization of Buckley-Leverett","title":"Set up parameter optimization.","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"This gives us a set of function handles together with initial guess and limits. Generally calling either of the functions will mutate the data Dict. The options are: Fo(x) -> evaluate objective dFo(dFdx, x) -> evaluate gradient of objective, mutating dFdx (may trigger evaluation of Fo) Fand_dF(F, dFdx, x) -> evaluate F and/or dF. Value of nothing will mean that the corresponding entry is skipped.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"F_o, dF_o, F_and_dF, x0, lims, data = setup_parameter_optimization(model, state0, parameters, tstep, forces, mass_mismatch, cfg, print = print_obj, param_obj = true);\nF_initial = F_o(x0)\ndF_initial = dF_o(similar(x0), x0)\n@info \"Initial objective: $F_initial, gradient norm $(norm(dF_initial))\"","category":"page"},{"location":"examples/optimize_simple_bl/#Link-to-an-optimizer-package","page":"Parameter optimization of Buckley-Leverett","title":"Link to an optimizer package","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"We use Optim.jl but the interface is general enough that e.g. LBFGSB.jl can easily be swapped in.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"LBFGS is a good choice for this problem, as Jutul provides sensitivities via adjoints that are inexpensive to compute.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"using Optim\nlower, upper = lims\ninner_optimizer = LBFGS()\nopts = Optim.Options(store_trace = true, show_trace = true, time_limit = 30)\nresults = optimize(Optim.only_fg!(F_and_dF), lower, upper, x0, Fminbox(inner_optimizer), opts)\nx = results.minimizer\ndisplay(results)\nF_final = F_o(x)","category":"page"},{"location":"examples/optimize_simple_bl/#Compute-the-solution-using-the-tuned-parameters-found-in-x.","page":"Parameter optimization of Buckley-Leverett","title":"Compute the solution using the tuned parameters found in x.","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"parameters_t = deepcopy(parameters)\ndevectorize_variables!(parameters_t, model, x, data[:mapper], config = data[:config])\nx_truth = vectorize_variables(model_ref, parameters_ref, data[:mapper], config = data[:config])\n\nstates_tuned, = simulate(state0, model, tstep, parameters = parameters_t, forces = forces, info_level = -1);\nnothing","category":"page"},{"location":"examples/optimize_simple_bl/#Plot-final-parameter-spread","page":"Parameter optimization of Buckley-Leverett","title":"Plot final parameter spread","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"@info \"Final residual $F_final (down from $F_initial)\"\nfig = Figure()\nax1 = Axis(fig[1, 1], title = \"Scaled parameters\", ylabel = \"Value\")\nscatter!(ax1, x, label = \"Final X\")\nscatter!(ax1, x0, label = \"Initial X\")\nlines!(ax1, lower, label = \"Lower bound\")\nlines!(ax1, upper, label = \"Upper bound\")\naxislegend()\nfig","category":"page"},{"location":"examples/optimize_simple_bl/#Plot-the-final-solutions.","page":"Parameter optimization of Buckley-Leverett","title":"Plot the final solutions.","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"Note that we only match saturations - so any match in pressure is not guaranteed.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"fig = Figure()\nax = Axis(fig[1, 1], title = \"Saturation\")\nlines!(ax, states_ref[end][:Saturations][1, :], label = \"Reference\")\nlines!(ax, states[end][:Saturations][1, :], label = \"Initial guess\")\nlines!(ax, states_tuned[end][:Saturations][1, :], label = \"Tuned\")\n\naxislegend(ax)\nax = Axis(fig[1, 2], title = \"Pressure\")\nlines!(ax, states_ref[end][:Pressure], label = \"Reference\")\nlines!(ax, states[end][:Pressure], label = \"Initial guess\")\nlines!(ax, states_tuned[end][:Pressure], label = \"Tuned\")\naxislegend(ax)\nfig","category":"page"},{"location":"examples/optimize_simple_bl/#Plot-the-objective-history-and-function-evaluations","page":"Parameter optimization of Buckley-Leverett","title":"Plot the objective history and function evaluations","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"fig = Figure()\nax1 = Axis(fig[1, 1], yscale = log10, title = \"Objective evaluations\", xlabel = \"Iterations\", ylabel = \"Objective\")\nplot!(ax1, data[:obj_hist][2:end])\nax2 = Axis(fig[1, 2], yscale = log10, title = \"Outer optimizer\", xlabel = \"Iterations\", ylabel = \"Objective\")\nt = map(x -> x.value, Optim.trace(results))\nplot!(ax2, t)\ndisplay(fig)","category":"page"},{"location":"examples/optimize_simple_bl/#Example-on-GitHub","page":"Parameter optimization of Buckley-Leverett","title":"Example on GitHub","text":"","category":"section"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"If you would like to run this example yourself, it can be downloaded from the JutulDarcy.jl GitHub repository.","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"","category":"page"},{"location":"examples/optimize_simple_bl/","page":"Parameter optimization of Buckley-Leverett","title":"Parameter optimization of Buckley-Leverett","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/secondary/#Secondary-variables-(properties)","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"","category":"section"},{"location":"man/secondary/#Fluid-systems","page":"Secondary variables (properties)","title":"Fluid systems","text":"","category":"section"},{"location":"man/secondary/#General","page":"Secondary variables (properties)","title":"General","text":"","category":"section"},{"location":"man/secondary/#Relative-permeabilities","page":"Secondary variables (properties)","title":"Relative permeabilities","text":"","category":"section"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"BrooksCoreyRelativePermeabilities\nRelativePermeabilities\nJutulDarcy.ReservoirRelativePermeabilities","category":"page"},{"location":"man/secondary/#JutulDarcy.BrooksCoreyRelativePermeabilities","page":"Secondary variables (properties)","title":"JutulDarcy.BrooksCoreyRelativePermeabilities","text":"BrooksCoreyRelativePermeabilities(\n    sys_or_nph::Union{MultiPhaseSystem, Integer},\n    exponents = 1.0,\n    residuals = 0.0,\n    endpoints = 1.0\n)\n\nSecondary variable that implements the family of Brooks-Corey relative permeability functions. This is a simple analytical expression for relative permeabilities that has a limited number of parameters:\n\nK(S) = K_max * ((S - S_r)(1 - S_r^tot))^N\n\nFields\n\nexponents: Exponents for each phase\nresiduals: Residual saturations for each phase\nendpoints: Maximum relative permeability for each phase\nresidual_total: Total residual saturation over all phases\n\n\n\n\n\n","category":"type"},{"location":"man/secondary/#JutulDarcy.RelativePermeabilities","page":"Secondary variables (properties)","title":"JutulDarcy.RelativePermeabilities","text":"RelativePermeabilities((kr1, kr2, ...))\n\nA simple relative permeability implementation. Assumes that each phase has a relative permeability on the form:\n\nK_rphase = F(S_phase)\n\nSupports multiple fluid regions through the regions keyword.\n\nExamples\n\nSingle region:\n\nkr1 = S -> S^2\nkr2 = S -> S^3\n\nkr = RelativePermeabilities((kr1, kr2))\n\nTwo regions:\n\nkr1_reg1 = S -> S^2\nkr2_reg1 = S -> S^3\n\nkr1_reg2 = S -> S^3\nkr2_reg2 = S -> S^4\n\nregions # should be a vector with one entry that is 1 or 2 for each cell in the domain\n\nkr = RelativePermeabilities(((kr1_reg1, kr2_reg1), (kr1_reg2, kr2_reg2)), regions = regions)\n\n\n\n\n\n","category":"type"},{"location":"man/secondary/#JutulDarcy.ReservoirRelativePermeabilities","page":"Secondary variables (properties)","title":"JutulDarcy.ReservoirRelativePermeabilities","text":"ReservoirRelativePermeabilities(\n    w = nothing, g = nothing, ow = nothing, og = nothing,\n    scaling = NoKrScale, regions = nothing)\n\nRelative permeability with advanced features for reservoir simulation. Includes features like rel. perm. endpoint scaling, connate water adjustment and separate phase pair relative permeabilites for the oil phase.\n\nFields\n\nkrw\nkrow\nkrog\nkrg\nregions\nphases\n\n\n\n\n\n","category":"type"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"PhaseRelativePermeability","category":"page"},{"location":"man/secondary/#JutulDarcy.PhaseRelativePermeability","page":"Secondary variables (properties)","title":"JutulDarcy.PhaseRelativePermeability","text":"PhaseRelativePermeability(s, k; label = :w, connate = s[1], epsilon = 1e-16)\n\nType that stores a sorted phase relative permeability table (given as vectors of equal length s and k):\n\nK_r = K(S)\n\nOptionally, a label for the phase, the connate saturation and a small epsilon value used to avoid extrapolation can be specified.\n\n\n\n\n\n","category":"type"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"EndPointScalingCoefficients","category":"page"},{"location":"man/secondary/#Phase-viscosities","page":"Secondary variables (properties)","title":"Phase viscosities","text":"","category":"section"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"DeckPhaseViscosities","category":"page"},{"location":"man/secondary/#JutulDarcy.DeckPhaseViscosities","page":"Secondary variables (properties)","title":"JutulDarcy.DeckPhaseViscosities","text":"DeckPhaseViscosities(pvt, regions = nothing)\n\nSecondary variable used to evaluate viscosities when a case is generated from a input file. Typically not instantiated in user scripts.\n\n\n\n\n\n","category":"type"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"PhaseMassDensities","category":"page"},{"location":"man/secondary/#JutulDarcy.PhaseMassDensities","page":"Secondary variables (properties)","title":"JutulDarcy.PhaseMassDensities","text":"Abstract type representing the evaluation of mass density of each phase (i.e. units of mass per units of volume, for each cell in the model domain.)\n\n\n\n\n\n","category":"type"},{"location":"man/secondary/#Immiscible-flow","page":"Secondary variables (properties)","title":"Immiscible flow","text":"","category":"section"},{"location":"man/secondary/#Phase-densities","page":"Secondary variables (properties)","title":"Phase densities","text":"","category":"section"},{"location":"man/secondary/#Shrinkage-factors","page":"Secondary variables (properties)","title":"Shrinkage factors","text":"","category":"section"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"DeckShrinkageFactors","category":"page"},{"location":"man/secondary/#JutulDarcy.DeckShrinkageFactors","page":"Secondary variables (properties)","title":"JutulDarcy.DeckShrinkageFactors","text":"DeckShrinkageFactors(pvt, regions = nothing)\n\nSecondary variable used to evaluate shrinkage factors when a case is generated from a input file. Typically not instantiated in user scripts.\n\n\n\n\n\n","category":"type"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"ConstantCompressibilityDensities","category":"page"},{"location":"man/secondary/#JutulDarcy.ConstantCompressibilityDensities","page":"Secondary variables (properties)","title":"JutulDarcy.ConstantCompressibilityDensities","text":"ConstantCompressibilityDensities(\n    sys_or_nph::Union{MultiPhaseSystem, Integer},\n    reference_pressure = 1.0,\n    reference_density = 0.0,\n    compressibility = 1.0\n)\n\nSecondary variable that implements a constant compressibility relationship for density. Given the reference pressure, compressibility and density at the reference pressure, each phase density can be computed as:\n\nρ(S) = ρ_ref e^(p - p_ref)c\n\nThe constructor can take in either one value per phase or a single value for all phases for the reference pressure, compressibility and density at reference conditions.\n\nFields\n\nreference_pressure: Reference pressure for each phase (where the reference densities are given)\nreference_densities: Densities at the reference point\ncompressibility: Compressibility factor used when expanding around reference pressure, typically between 1e-3 and 1e-10\n\n\n\n\n\n","category":"type"},{"location":"man/secondary/#Black-oil-flow","page":"Secondary variables (properties)","title":"Black-oil flow","text":"","category":"section"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"","category":"page"},{"location":"man/secondary/#Compositional-flow","page":"Secondary variables (properties)","title":"Compositional flow","text":"","category":"section"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"PhaseMassFractions","category":"page"},{"location":"man/secondary/#JutulDarcy.PhaseMassFractions","page":"Secondary variables (properties)","title":"JutulDarcy.PhaseMassFractions","text":"PhaseMassFractions(:liquid)\n\nVariable that defines the component mass fractions in a specific phase.\n\n\n\n\n\n","category":"type"},{"location":"man/secondary/#Wells","page":"Secondary variables (properties)","title":"Wells","text":"","category":"section"},{"location":"man/secondary/","page":"Secondary variables (properties)","title":"Secondary variables (properties)","text":"TotalMass","category":"page"},{"location":"man/secondary/#JutulDarcy.TotalMass","page":"Secondary variables (properties)","title":"JutulDarcy.TotalMass","text":"TotalMasses()\n\nVariable that defines total mass of all components in each cell of the domain.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#Wells-and-controls","page":"Wells and controls","title":"Wells and controls","text":"","category":"section"},{"location":"man/wells/#Well-setup-routines","page":"Wells and controls","title":"Well setup routines","text":"","category":"section"},{"location":"man/wells/","page":"Wells and controls","title":"Wells and controls","text":"Wells can be set up using the convenience functions setup_well and setup_vertical_well. These routines act on the output from reservoir_domain and can set up both types of wells. We recommend that you use these functions instead of manually calling the well constructors.","category":"page"},{"location":"man/wells/#Types-of-wells","page":"Wells and controls","title":"Types of wells","text":"","category":"section"},{"location":"man/wells/#Simple-wells","page":"Wells and controls","title":"Simple wells","text":"","category":"section"},{"location":"man/wells/","page":"Wells and controls","title":"Wells and controls","text":"JutulDarcy.SimpleWell","category":"page"},{"location":"man/wells/#JutulDarcy.SimpleWell","page":"Wells and controls","title":"JutulDarcy.SimpleWell","text":"SimpleWell(reservoir_cells; <keyword arguments>)\n\nSet up a simple well.\n\nNote\n\nsetup_vertical_well or setup_well are the recommended way of setting up wells.\n\nFields\n\nvolume\nperforations\nsurface\nname\nexplicit_dp\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#Equations","page":"Wells and controls","title":"Equations","text":"","category":"section"},{"location":"man/wells/#Multisegment-wells","page":"Wells and controls","title":"Multisegment wells","text":"","category":"section"},{"location":"man/wells/","page":"Wells and controls","title":"Wells and controls","text":"MultiSegmentWell","category":"page"},{"location":"man/wells/#JutulDarcy.MultiSegmentWell","page":"Wells and controls","title":"JutulDarcy.MultiSegmentWell","text":"MultiSegmentWell(reservoir_cells, volumes, centers;\n                N = nothing,\n                name = :Well,\n                perforation_cells = nothing,\n                segment_models = nothing,\n                segment_length = nothing,\n                reference_depth = 0,\n                dz = nothing,\n                surface_conditions = default_surface_cond(),\n                accumulator_volume = mean(volumes),\n                )\n\nCreate well perforated in a vector of reservoir_cells with corresponding volumes and cell centers.\n\nNote\n\nsetup_vertical_well or setup_well are the recommended way of setting up wells.\n\nFields\n\nvolumes\nperforations\nneighborship\ntop\ncenters\nsurface\nname\nsegment_models\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#Well-controls-and-limits","page":"Wells and controls","title":"Well controls and limits","text":"","category":"section"},{"location":"man/wells/#Types-of-well-controls","page":"Wells and controls","title":"Types of well controls","text":"","category":"section"},{"location":"man/wells/","page":"Wells and controls","title":"Wells and controls","text":"InjectorControl\nProducerControl\nDisabledControl","category":"page"},{"location":"man/wells/#JutulDarcy.InjectorControl","page":"Wells and controls","title":"JutulDarcy.InjectorControl","text":"InjectorControl(target, mix, [density])\n\nWell control that specifies injection into the reservoir. target specifies the type of target and mix defines the injection mass fractions for all species in the model during injection. \n\nFor example, for a three-component system made up of CO2, H2O and H2, setting [0.1, 0.6, 0.3] would mean that the injection stream would contain 1 part CO2, 6 parts H2O and 3 parts H2 by mass. For an immiscible system (e.g. LiquidPhase(), VaporPhase()) the species corresponds to phases and [0.3, 0.7] would mean a 3 to 7 mixture of liquid and vapor by mass.\n\nThe density of the injected fluid at surface conditions is given by density which is defaulted to 1.0 if not given.\n\nSee also ProducerControl, DisabledControl.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.ProducerControl","page":"Wells and controls","title":"JutulDarcy.ProducerControl","text":"ProducerControl(target)\n\nWell control for production out of the reservoir. target specifies the type of target (for example BottomHolePressureTarget()).\n\nSee also DisabledControl, InjectorControl.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.DisabledControl","page":"Wells and controls","title":"JutulDarcy.DisabledControl","text":"DisabledControl()\n\nControl that disables a well. If a well is disabled, it is disconnected from the surface network and no flow occurs between the well and the top side. Mass transfer can still occur inside the well, and between the well and the reservoir unless perforations are also closed by a PerforationMask.\n\nSee also ProducerControl, InjectorControl.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/","page":"Wells and controls","title":"Wells and controls","text":"JutulDarcy.replace_target\nJutulDarcy.default_limits","category":"page"},{"location":"man/wells/#JutulDarcy.replace_target","page":"Wells and controls","title":"JutulDarcy.replace_target","text":"replace_target(ctrl, new_target)\n\nCreate new well control using ctrl as a template that operates under new_target.\n\n\n\n\n\n","category":"function"},{"location":"man/wells/#JutulDarcy.default_limits","page":"Wells and controls","title":"JutulDarcy.default_limits","text":"default_limits(ctrl)\n\nCreate reasonable default limits for well control ctrl, for example to avoid BHP injectors turning into producers.\n\n\n\n\n\n","category":"function"},{"location":"man/wells/#Types-of-well-targets","page":"Wells and controls","title":"Types of well targets","text":"","category":"section"},{"location":"man/wells/","page":"Wells and controls","title":"Wells and controls","text":"BottomHolePressureTarget\nSinglePhaseRateTarget\nSurfaceLiquidRateTarget\nSurfaceOilRateTarget\nSurfaceGasRateTarget\nSurfaceWaterRateTarget\nTotalRateTarget\nHistoricalReservoirVoidageTarget\nReservoirVoidageTarget\nDisabledTarget","category":"page"},{"location":"man/wells/#JutulDarcy.BottomHolePressureTarget","page":"Wells and controls","title":"JutulDarcy.BottomHolePressureTarget","text":"BottomHolePressureTarget(q, phase)\n\nBottom-hole pressure (bhp) target with target pressure value bhp. A well operating under a bhp constraint will keep the well pressure at the bottom hole (typically the top of the perforations) fixed at this value unless doing so would violate other constraints, like the well switching from injection to production when declared as an injector.\n\nExamples\n\njulia> BottomHolePressureTarget(100e5)\nBottomHolePressureTarget with value 100.0 [bar]\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.SinglePhaseRateTarget","page":"Wells and controls","title":"JutulDarcy.SinglePhaseRateTarget","text":"SinglePhaseRateTarget(q, phase)\n\nSingle-phase well target with value q specified for phase.\n\nExamples\n\njulia> SinglePhaseRateTarget(0.001, LiquidPhase())\nSinglePhaseRateTarget of 0.001 [m^3/s] for LiquidPhase()\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.SurfaceLiquidRateTarget","page":"Wells and controls","title":"JutulDarcy.SurfaceLiquidRateTarget","text":"SurfaceLiquidRateTarget(q)\n\nWell target of specified liquid rate at surface conditions with value q. Typically used for a ProducerControl as you have full control over the mixture composition during injection.\n\nLiquid rate, sometimes abbreviated LRAT, is made up of the phases that remain liquid at surface conditions. Typically, this will be water and oil if present in the model, but never different types of gas. If a producing becomes nearly or completely flooded by gas the well can go to very high or even infinite flows. It is therefore important to combine this control with a limit such as a bottom-hole-pressure constraint.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.SurfaceOilRateTarget","page":"Wells and controls","title":"JutulDarcy.SurfaceOilRateTarget","text":"SurfaceOilRateTarget(q)\n\nWell target of specified oil rate with value q at surface conditions. Typically used for a ProducerControl as oil, for economic reasons, is rarely injected into the subsurface. Abbreviated as ORAT in some settings.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.SurfaceGasRateTarget","page":"Wells and controls","title":"JutulDarcy.SurfaceGasRateTarget","text":"SurfaceGasRateTarget(q)\n\nWell target of specified gas rate with value q at surface conditions.\n\nOften used for both InjectorControl ProducerControl. Abbreviated as GRAT in some settings. If used for production it is important to also impose limits, as the well rate may become very high if there is little gas present.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.SurfaceWaterRateTarget","page":"Wells and controls","title":"JutulDarcy.SurfaceWaterRateTarget","text":"SurfaceWaterRateTarget(q)\n\nWell target of specified water rate with value q at surface conditions.\n\nOften used for both InjectorControl ProducerControl. If used for production it is important to also impose limits, as the well rate may become very high if there is little water present.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.TotalRateTarget","page":"Wells and controls","title":"JutulDarcy.TotalRateTarget","text":"TotalRateTarget(q)\n\nWell target of specified total rate (sum of all phases) with value q at surface conditions.\n\nOften used for both InjectorControl ProducerControl.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.HistoricalReservoirVoidageTarget","page":"Wells and controls","title":"JutulDarcy.HistoricalReservoirVoidageTarget","text":"HistoricalReservoirVoidageTarget(q, weights)\n\nHistorical RESV target for history matching cases. See ReservoirVoidageTarget. For historical rates, the weights described in that target are computed based on the reservoir pressure and conditions at the previous time-step.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.ReservoirVoidageTarget","page":"Wells and controls","title":"JutulDarcy.ReservoirVoidageTarget","text":"ReservoirVoidageTarget(q, weights)\n\nRESV target for history matching cases. The weights input should have one entry per phase (or pseudocomponent) in the system. The well control equation is then:\n\nq_ctrl - sum_i w_i q_i^s\n\nwhere q_i^s is the surface rate of phase i and w_i the weight of component stream i.\n\nThis constraint is typically set up from .DATA files for black-oil and immiscible cases.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#JutulDarcy.DisabledTarget","page":"Wells and controls","title":"JutulDarcy.DisabledTarget","text":"DisabledTarget(q)\n\nDisabled target used when a well is under DisabledControl() only. The well will be disconnected from the surface.\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#Imposing-limits-on-wells-(multiple-constraints)","page":"Wells and controls","title":"Imposing limits on wells (multiple constraints)","text":"","category":"section"},{"location":"man/wells/#Well-forces","page":"Wells and controls","title":"Well forces","text":"","category":"section"},{"location":"man/wells/#Changing-perforations","page":"Wells and controls","title":"Changing perforations","text":"","category":"section"},{"location":"man/wells/","page":"Wells and controls","title":"Wells and controls","text":"PerforationMask","category":"page"},{"location":"man/wells/#JutulDarcy.PerforationMask","page":"Wells and controls","title":"JutulDarcy.PerforationMask","text":"mask = PerforationMask(mask::Vector)\n\nCreate a perforation mask. This can be passed to setup_forces for a well under the mask argument. The mask should equal the number of perforations in the well and is applied to the reference well indices in a multiplicative fashion. For example, if a well named :Injector has two perforations, the following mask would disable the first perforation and decrease the connection strength for the second perforation by 50%:\n\nmask = PerforationMask([0.0, 0.5])\niforces = setup_forces(W, mask = mask)\nforces = setup_reservoir_forces(model, control = controls, Injector = iforces)\n\n\n\n\n\n","category":"type"},{"location":"man/wells/#Other-forces","page":"Wells and controls","title":"Other forces","text":"","category":"section"},{"location":"man/wells/","page":"Wells and controls","title":"Wells and controls","text":"Can use SourceTerm or FlowBoundaryCondition","category":"page"},{"location":"man/solution/#Solving-the-equations","page":"Solving the equations","title":"Solving the equations","text":"","category":"section"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"By default, Jutul solves a system as a fully-coupled implicit system of equations discretized with a two-point flux approximation with single-point upwind.","category":"page"},{"location":"man/solution/#Newton's-method","page":"Solving the equations","title":"Newton's method","text":"","category":"section"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"The standard way of solving a system of non-linear equations is by Newton's method (also known as Newton-Raphson's method). A quick recap: For a vector valued residual mathbfr(x) of the primary variable vector mathbfx we can defined a Newton update:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"mathbfx^k+1 = mathbfr^k - J^-1 mathbfr(mathbfx^k) quad J_ij = fracpartial mathbfr_ipartial mathbfx_j","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"JutulDarcy solves systems that generally have both non-smooth behavior and physical constraints on the values for textbfx. For that reason, we modify Newton's method slightly:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"mathbfx^k+1 = mathbfr^k + omega(Delta mathbfx)","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"Here, omega is a function that limits the variables so that they do not change too much (e.g. Appleyard chopping, limiting of pressure, saturation and composition updates) and that they are within the prescribed limits. There are also options for automated global dampening in the presence of convergence issues. The update is then defined from inverting the Jacobian:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"Delta mathbfx = -J^-1 mathbfr(mathbfx^k) quad J_ij = fracpartial mathbfr_ipartial mathbfx_j","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"Starting with mathbfx^0as some initial guess taken from the previous time-step, we can solve the system by iterating upon this loop.","category":"page"},{"location":"man/solution/#Linear-solvers-and-linear-systems","page":"Solving the equations","title":"Linear solvers and linear systems","text":"","category":"section"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"For most practical applications it is not feasible or efficient to invert the Jacobian. JutulDarcy uses preconditioned iterative solvers by default, but it is possible to use direct solvers as well when working with smaller models. The high level interface for setting up a reservoir model setup_reservoir_model has an optional block_backend=true keyword argument that determines the matrix format, and consequently the linear solver type to be used.","category":"page"},{"location":"man/solution/#Direct-solvers","page":"Solving the equations","title":"Direct solvers","text":"","category":"section"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"If block_backend is set to false, Jutul will assemble into the standard Julia CSC sparse matrix with Float64 elements and Julia's default direct solver will be used. It is also possible to use other Julia solvers on this system, but the default preconditioners assume that block backend is enabled.","category":"page"},{"location":"man/solution/#Iterative-solver","page":"Solving the equations","title":"Iterative solver","text":"","category":"section"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"If block_backend is set to true, Jutul will by default use a constrained-pressure residual (CPR) preconditioner for BiCGStab. Jutul relies on Krylov.jl for iterative solvers. The main function that selects the linear solver is reservoir_linsolve that allows for the selection of different preconditioners and linear solvers.","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"reservoir_linsolve\nJutul.GenericKrylov","category":"page"},{"location":"man/solution/#JutulDarcy.reservoir_linsolve","page":"Solving the equations","title":"JutulDarcy.reservoir_linsolve","text":"reservoir_linsolve(model, precond = :cpr; <keyword arguments>)\n\nSet up iterative linear solver for a reservoir model from setup_reservoir_model.\n\nArguments\n\nmodel: Reservoir model that will linearize the equations for the linear solver\nprecond=:cpr: Preconditioner type to use: Either :cpr (Constrained-Pressure-Residual) or :ilu0 (block-incomplete-LU) (no effect if solver = :direct).\nv=0: verbosity (can lead to a large amount of output)\nsolver=:bicgstab: the symbol of a Krylov.jl solver (typically :gmres or :bicgstab)\nupdate_interval=:once: how often the CPR AMG hierarchy is reconstructed (:once, :iteration, :ministep, :step)\nupdate_interval_partial=:iteration: how often the pressure system is updated in CPR\nmax_coarse: max size of coarse level if using AMG\ncpr_type=nothing: type of CPR (:true_impes, :quasi_impes or nothing for automatic)\npartial_update=true: perform partial update of CPR preconditioner outside of AMG update (see above)\nrtol=1e-3: relative tolerance for the linear solver\nmax_iterations=100: limit for linear solver iterations\n\nAdditional keywords are passed onto the linear solver constructor.\n\n\n\n\n\n","category":"function"},{"location":"man/solution/#Jutul.GenericKrylov","page":"Solving the equations","title":"Jutul.GenericKrylov","text":"GenericKrylov(solver = :gmres; preconditioner = nothing; <kwarg>)\n\nSolver that wraps Krylov.jl with support for preconditioning.\n\n\n\n\n\n","category":"type"},{"location":"man/solution/#Single-model-(only-porous-medium)","page":"Solving the equations","title":"Single model (only porous medium)","text":"","category":"section"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"If the model is a single model (e.g. only a reservoir) the matrix format is a block-CSC matrix that combines Julia's builtin sparse matrix format with statically sized elements from the StaticArrays.jl package. If we consider the two-phase immiscible system from Multi-phase, immiscible flow we have a pair of equations R_n R_w together with the corresponding primary variables pressure and first saturation p S_n defined for all N_c cells. Let us simplify the notation a bit so that the subscripts of the primary variables are p s and define a N_c times N_c block Jacobian linear system where the entires are given by:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"J_ij = beginbmatrix\n   left(fracpartial r_npartial pright)_ij  left(fracpartial r_npartial sright)_ij \n   left(fracpartial r_wpartial pright)_ij  left(fracpartial r_wpartial sright)_ij endbmatrix = beginbmatrix\n   J_np  J_ns \n   J_wp  J_ws\nendbmatrix_ij","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"This block system has several advantages:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"We immediately get access to more powerful version of standard Julia  preconditioners provided that all operations used are applicable for matrices  and are applied in the right commutative order. For example, JutulDarcy uses  the ILUZero.jl package when a CSC  linear system is preconditioned with incomplete LU factorization with zero  fill-in.\nSparse matrix vector products are much more efficient as less indicies need to  be looked up for each element wise multiplication.\nPerforming local reductions over variables is much easier when they are  located in a local matrix.","category":"page"},{"location":"man/solution/#Constrained-Pressure-Residual","page":"Solving the equations","title":"Constrained Pressure Residual","text":"","category":"section"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"The CPR preconditioner [3, 4] CPRPreconditioner is a multi-stage physics-informed preconditioner that seeks to decouple the global pressure part of the system from the local  transport part. In the limits of incompressible flow without gravity it can be thought of as an elliptic / hyperbolic splitting.","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"CPRPreconditioner","category":"page"},{"location":"man/solution/#JutulDarcy.CPRPreconditioner","page":"Solving the equations","title":"JutulDarcy.CPRPreconditioner","text":"CPRPreconditioner(p = default_psolve(), s = ILUZeroPreconditioner(); strategy = :quasi_impes, weight_scaling = :unit, update_frequency = 1, update_interval = :iteration, partial_update = true)\n\nConstruct a constrained pressure residual (CPR) preconditioner.\n\nBy default, this is a AMG-BILU(0) version (algebraic multigrid for pressure, block-ILU(0) for the global system).\n\n\n\n\n\n","category":"type"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"The short version of the CPR preconditioner can be motivated by our test system:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"r_n = fracpartialpartial t ((1 - S_w) rho_n phi) + nabla cdot (rho_n vecv_n) - rho_n q_n = 0\nr_w = fracpartialpartial t (S_w rho_w phi) + nabla cdot (rho_w vecv_w) - rho_w q_w = 0","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"For simplicity, we assume that there is no gravity, source terms, or compressibility. Each equation can then be divided by their respective densities and summed up to produce a pressure equation:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"r_p = fracpartialpartial t ((1 - S_w) phi) + nabla cdot vecv_n + fracpartialpartial t (S_w phi) + nabla cdot  vecv_w \n= fracpartialpartial t ((S_w - S_w) phi) + nabla cdot (vecv_n + vecv_w) \n= nabla cdot (vecv_n + vecv_w) \n= - nabla mathbfK(k_rwmu_w + k_rnmu_n) nabla p \n= - nabla mathbfKlambda_t nabla p = 0","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"The final equation is the variable coefficient Poisson equation and is referred to as the incompressible pressure equation for a porous  media. We know that algebraic multigrid preconditioners (AMG) are highly efficient for linear systems made by discretizing this equation. The idea in CPR is to exploit this by constructing an approximate pressure equation that is suited for AMG inside the preconditioner.","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"Constructing the preconditioner is done in two stages:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"First, weights for each equation is found locally in each cell that decouples the time derivative from the non-pressure variables. In the above example, this was the true IMPES weights (dividing by density). JutulDarcy supports analytical true IMPES weights for some systems, numerical true IMPES weights for all systems and quasi IMPES weights for all systems.\nA pressure equation is formed by weighting each equation by the respective weights and summing. We then have two systems: The pressure system r_p with scalar entries and the full system r that has block structure.","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"During the linear solve, the preconditioner is then made up of two broad stages: First, a preconditioner is applied to the pressure part (typically AMG), then the full system is preconditioned (typically ILU(0)) after the residual has been corrected by the pressure estimate:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"Form weighted pressure residual r_p = sum_i w_i r_i.\nApply pressure preconditioer M_p: Delta p = M_p^-1 r_p.\nCorrect global residual r^* = r - J P(Delta p) where P expands the pressure update to the full system vector, with zero entries outside the pressure indices.\nPrecondition the full system Delta x^* = M^-1r^*\nCorrect the global update with the pressure to obtain the final update: Delta x = Delta x^* + P(Delta p)","category":"page"},{"location":"man/solution/#Multi-model-(porous-medium-with-wells)","page":"Solving the equations","title":"Multi model (porous medium with wells)","text":"","category":"section"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"If a model is a porous medium with wells, the same preconditioners can be used, but an additional step is required to incorporate the well system. In practical terms, this means that our linearized system is expanded to multiple linear systems:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"J Delta mathbfx = beginbmatrix\n   J_rr  J_rw \n   J_wr  J_ww\nendbmatrix\nbeginbmatrix\nDelta mathbfx_r \nDelta mathbfx_w\nendbmatrix\n = \nbeginbmatrix\nmathbfr_r \nmathbfr_w\nendbmatrix","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"Here, J_rr is the reservoir equations differentiated with respect to the reservoir primary variables, i.e. the Jacobian from the previous section. J_ww is the well system differentiated with respect to the well primary variables. The cross terms, J_rwand J_wr, are the same equations differentiated with respect to the primary variables of the other system.","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"The well system is generally much smaller than the reservoir system and can be solved by a direct solver. We would like to reuse the block preconditioners defined for the base system. The approach we use is a Schur complement approach to solve the full system. If we linearly eliminate the dependence of the reservoir equations on the well primary variables, we obtain the reduced system:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"J Delta mathbfx = beginbmatrix\n   J_rr - J_rwJ_ww^-1J_wr  0 \n   J_wr  J_ww\nendbmatrix\nbeginbmatrix\nDelta mathbfx_r \nDelta mathbfx_w\nendbmatrix\n = \nbeginbmatrix\nmathbfr_r - J_rwJ_ww^-1mathbfr_w\nmathbfr_w\nendbmatrix","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"We can then solve the system in terms of the reservoir degrees of freedom where the system is a block linear system and we already have a working preconditioner:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"left(J_rr - J_rwJ_ww^-1J_wrright)mathbfx_r = mathbfr_r - J_rwJ_ww^-1mathbfr_w","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"Once that system is solved for mathbfx_r, we can recover the well degrees of freedom mathbfr_w directly:","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"mathbfr_w = J_ww^-1(mathbfr_w - J_wrmathbfx_r)","category":"page"},{"location":"man/solution/","page":"Solving the equations","title":"Solving the equations","text":"note: Efficiency of Schur complement\nExplicitly forming the matrix J_rr - J_rwJ_ww^-1J_wr will generally lead to a lot of fill-in in the linear system. JutulDarcy instead uses the action of J_rr - J_rwJ_ww^-1J_wr as a linear operator from LinearOperators.jl. This means that we must apply the inverse of the well system every time we need to compute the residual or action of the system matrix, but fortunately performing the action of the Schur complement is inexpensive as long as J_ww is small and the factorization can be stored.","category":"page"},{"location":"man/plotting/#Plotting-and-visualization","page":"Visualization","title":"Plotting and visualization","text":"","category":"section"},{"location":"man/plotting/","page":"Visualization","title":"Visualization","text":"plot_reservoir\nplot_well_results\nJutulDarcy.plot_reservoir_simulation_result\nJutul.plot_cell_data","category":"page"},{"location":"man/plotting/#JutulDarcy.plot_reservoir_simulation_result","page":"Visualization","title":"JutulDarcy.plot_reservoir_simulation_result","text":"plot_reservoir_simulation_result(model::MultiModel, res::ReservoirSimResult; wells = true, reservoir = true)\n\nPlot a reservoir simulation result. If wells=true well curves will be shown interactively. If reservoir=true the reservoir quantities will be visualized in 3D. These options can be combined.\n\n\n\n\n\n","category":"function"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"EditURL = \"../../../examples/co2_brine_2d_vertical.jl\"","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Example-demonstrating-compositional-flow","page":"Intro to compositional flow","title":"Example demonstrating compositional flow","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"This is a simple conceptual example demonstrating how to solve compositional flow. This example uses a two-component water-CO2 system. Note that the default Peng-Robinson is not accurate for this system without adjustments to the parameters. However, the example demonstrates the conceptual workflow for getting started with compositional simulation.","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Set-up-mixture","page":"Intro to compositional flow","title":"Set up mixture","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"We load the external flash package and define a two-component H2O-CO2 system. The constructor for each species takes in molecular weight, critical pressure, critical temperature, critical volume, acentric factor given as strict SI. This means, for instance, that molar masses are given in kg/mole and not g/mole or kg/kmol.","category":"page"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"using MultiComponentFlash\nh2o = MolecularProperty(0.018015268, 22.064e6, 647.096, 5.595e-05, 0.3442920843)\nco2 = MolecularProperty(0.0440098, 7.3773e6, 304.1282, 9.412e-05, 0.22394)\n\nbic = [0 0;\n       0 0]\n\nmixture = MultiComponentMixture([h2o, co2], A_ij = bic, names = [\"H2O\", \"CO2\"])\neos = GenericCubicEOS(mixture, PengRobinson())","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Set-up-domain-and-wells","page":"Intro to compositional flow","title":"Set up domain and wells","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"using Jutul, JutulDarcy, CairoMakie\nnx = 50\nny = 1\nnz = 20\ndims = (nx, ny, nz)\ng = CartesianMesh(dims, (100.0, 10.0, 10.0))\nnc = number_of_cells(g)\nDarcy, bar, kg, meter, Kelvin, day, sec = si_units(:darcy, :bar, :kilogram, :meter, :Kelvin, :day, :second)\nK = repeat([0.1, 0.1, 0.001]*Darcy, 1, nc)\nres = reservoir_domain(g, porosity = 0.3, permeability = K)","category":"page"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"Set up a vertical well in the first corner, perforated in top layer","category":"page"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"prod = setup_well(g, K, [(nx, ny, 1)], name = :Producer)","category":"page"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"Set up an injector in the opposite corner, perforated in bottom layer","category":"page"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"inj = setup_well(g, K, [(1, 1, nz)], name = :Injector)","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Define-system-and-realize-on-grid","page":"Intro to compositional flow","title":"Define system and realize on grid","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"rhoLS = 844.23*kg/meter^3\nrhoVS = 126.97*kg/meter^3\nrhoS = [rhoLS, rhoVS]\nL, V = LiquidPhase(), VaporPhase()\nsys = MultiPhaseCompositionalSystemLV(eos, (L, V))\nmodel, parameters = setup_reservoir_model(res, sys, wells = [inj, prod], reference_densities = rhoS);\npush!(model[:Reservoir].output_variables, :Saturations)\nkr = BrooksCoreyRelativePermeabilities(sys, 2.0, 0.0, 1.0)\nmodel = replace_variables!(model, RelativePermeabilities = kr)\nT0 = repeat([303.15*Kelvin], 1, nc)\nparameters[:Reservoir][:Temperature] = T0\nstate0 = setup_reservoir_state(model, Pressure = 50*bar, OverallMoleFractions = [1.0, 0.0]);\nnothing #hide","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Define-schedule","page":"Intro to compositional flow","title":"Define schedule","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"5 year (5*365.24 days) simulation period","category":"page"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"dt0 = repeat([1]*day, 26)\ndt1 = repeat([10.0]*day, 180)\ndt = append!(dt0, dt1)\nrate_target = TotalRateTarget(9.5066e-06*meter^3/sec)\nI_ctrl = InjectorControl(rate_target, [0, 1], density = rhoVS)\nbhp_target = BottomHolePressureTarget(50*bar)\nP_ctrl = ProducerControl(bhp_target)\n\ncontrols = Dict()\ncontrols[:Injector] = I_ctrl\ncontrols[:Producer] = P_ctrl\nforces = setup_reservoir_forces(model, control = controls)\nws, states = simulate_reservoir(state0, model, dt, parameters = parameters, forces = forces)","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Once-the-simulation-is-done,-we-can-plot-the-states","page":"Intro to compositional flow","title":"Once the simulation is done, we can plot the states","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"Note that this example is intended for static publication in the documentation. For interactive visualization you can replace CairoMakie with GLMakie and use functions like plot_interactive to interactively visualize the states.","category":"page"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"z = states[end][:OverallMoleFractions][2, :]\nfunction plot_vertical(x, t)\n    data = reshape(x, (nx, nz))\n    data = data[:, end:-1:1]\n    fig, ax, plot = heatmap(data)\n    ax.title = t\n    Colorbar(fig[1, 2], plot)\n    fig\nend","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Plot-final-CO2-mole-fraction","page":"Intro to compositional flow","title":"Plot final CO2 mole fraction","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"plot_vertical(z, \"CO2\")","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Plot-final-vapor-saturation","page":"Intro to compositional flow","title":"Plot final vapor saturation","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"sg = states[end][:Saturations][2, :]\nplot_vertical(sg, \"Vapor saturation\")","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Plot-final-pressure","page":"Intro to compositional flow","title":"Plot final pressure","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"p = states[end][:Pressure]\nplot_vertical(p./bar, \"Pressure [bar]\")","category":"page"},{"location":"examples/co2_brine_2d_vertical/#Example-on-GitHub","page":"Intro to compositional flow","title":"Example on GitHub","text":"","category":"section"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"If you would like to run this example yourself, it can be downloaded from the JutulDarcy.jl GitHub repository.","category":"page"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"","category":"page"},{"location":"examples/co2_brine_2d_vertical/","page":"Intro to compositional flow","title":"Intro to compositional flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/intro/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"man/intro/#A-short-motivational-example","page":"Getting started","title":"A short motivational example","text":"","category":"section"},{"location":"extras/faq/#Frequently-asked-questions","page":"FAQ","title":"Frequently asked questions","text":"","category":"section"},{"location":"extras/faq/","page":"FAQ","title":"FAQ","text":"info: Note about units\nJutulDarcy does currently not make us of conversion factors or explicit units can in principle use any consistent unit system. Some default scaling of variables assume that the magnitude pressures and velocities roughly match that of strict SI (e.g. Pascals and cubic meters per second). These scaling factors are primarily used when iterative linear solvers are used.","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"EditURL = \"../../../examples/two_phase_unstable_gravity.jl\"","category":"page"},{"location":"examples/two_phase_unstable_gravity/#Gravity-circulation-with-CPR-preconditioner","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"","category":"section"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"This example demonstrates a more complex gravity driven instability. The problem is a bit larger than the Gravity segregation example, and is therefore set up using the high level API that automatically sets up an iterative linear solver with a constrained pressure residual (CPR) preconditioner and automatic timestepping.","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"The high level API uses the more low level Jutul API seen in the other examples under the hood and makes more complex problems easy to set up. The same data structures and functions are used, allowing for deep customization if the defaults are not appropriate.","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"using JutulDarcy\nusing Jutul\nusing CairoMakie\ncmap = :seismic\nnx = nz = 100;\nnothing #hide","category":"page"},{"location":"examples/two_phase_unstable_gravity/#Define-the-domain","page":"Gravity circulation with CPR preconditioner","title":"Define the domain","text":"","category":"section"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"D = 10.0\ng = CartesianMesh((nx, 1, nz), (D, 1.0, D))\ndomain = reservoir_domain(g)","category":"page"},{"location":"examples/two_phase_unstable_gravity/#Set-up-model-and-properties","page":"Gravity circulation with CPR preconditioner","title":"Set up model and properties","text":"","category":"section"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"Darcy, bar, kg, meter, day = si_units(:darcy, :bar, :kilogram, :meter, :day)\np0 = 100*bar\nrhoLS = 1000.0*kg/meter^3 # Definition of fluid phases\nrhoVS = 500.0*kg/meter^3\ncl, cv = 1e-5/bar, 1e-4/bar\nL, V = LiquidPhase(), VaporPhase()\nsys = ImmiscibleSystem([L, V])\nmodel, parameters = setup_reservoir_model(domain, sys)\ndensity = ConstantCompressibilityDensities(sys, p0, [rhoLS, rhoVS], [cl, cv]) # Replace density with a lighter pair\nreplace_variables!(model, PhaseMassDensities = density);\nkr = BrooksCoreyRelativePermeabilities(sys, [2.0, 3.0])\nreplace_variables!(model, RelativePermeabilities = kr)","category":"page"},{"location":"examples/two_phase_unstable_gravity/#Define-initial-saturation","page":"Gravity circulation with CPR preconditioner","title":"Define initial saturation","text":"","category":"section"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"Set the left part of the domain to be filled by the vapor phase and the heavy liquid phase in the remainder. To do this, we grab the cell centroids in the x direction from the domain, reshape them to the structured mesh we are working on and define the liquid saturation from there.","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"c = domain[:cell_centroids]\nx = reshape(c[1, :], nx, nz)\n\nsL = zeros(nx, nz)\nplane = D/2.0\nfor i in 1:nx\n    for j = 1:nz\n        X = x[i, j]\n        sL[i, j] = clamp(Float64(X > plane), 0, 1)\n    end\nend\nheatmap(sL, colormap = cmap, axis = (title = \"Initial saturation\",))","category":"page"},{"location":"examples/two_phase_unstable_gravity/#Set-up-initial-state","page":"Gravity circulation with CPR preconditioner","title":"Set up initial state","text":"","category":"section"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"sL = vec(sL)'\nsV = 1 .- sL\ns0 = vcat(sV, sL)\nstate0 = setup_reservoir_state(model, Pressure = p0, Saturations = s0)","category":"page"},{"location":"examples/two_phase_unstable_gravity/#Set-the-viscosity-of-the-phases","page":"Gravity circulation with CPR preconditioner","title":"Set the viscosity of the phases","text":"","category":"section"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"By default, viscosity is a parameter and can be set per-phase and per cell.","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"μ = parameters[:Reservoir][:PhaseViscosities]\n@. μ[1, :] = 1e-3\n@. μ[2, :] = 5e-3","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"Convert time-steps from days to seconds","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"timesteps = repeat([10.0*3600*24], 20)\n_, states, = simulate_reservoir(state0, model, timesteps, parameters = parameters, info_level = 1);\nnothing #hide","category":"page"},{"location":"examples/two_phase_unstable_gravity/#Plot-results","page":"Gravity circulation with CPR preconditioner","title":"Plot results","text":"","category":"section"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"Plot initial saturation","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"tmp = reshape(state0[:Reservoir][:Saturations][1, :], nx, nz)\nf = Figure()\nax = Axis(f[1, 1], title = \"Before\")\nheatmap!(ax, tmp, colormap = cmap)","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"Plot intermediate saturation","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"tmp = reshape(states[length(states) ÷ 2][:Saturations][1, :], nx, nz)\nax = Axis(f[1, 2], title = \"Half way\")\nhm = heatmap!(ax, tmp, colormap = cmap)","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"Plot final saturation","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"tmp = reshape(states[end][:Saturations][1, :], nx, nz)\nax = Axis(f[1, 3], title = \"After\")\nhm = heatmap!(ax, tmp, colormap = cmap)\nColorbar(f[1, 4], hm)\nf","category":"page"},{"location":"examples/two_phase_unstable_gravity/#Example-on-GitHub","page":"Gravity circulation with CPR preconditioner","title":"Example on GitHub","text":"","category":"section"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"If you would like to run this example yourself, it can be downloaded from the JutulDarcy.jl GitHub repository.","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"","category":"page"},{"location":"examples/two_phase_unstable_gravity/","page":"Gravity circulation with CPR preconditioner","title":"Gravity circulation with CPR preconditioner","text":"This page was generated using Literate.jl.","category":"page"},{"location":"extras/refs/#References","page":"References","title":"References","text":"","category":"section"},{"location":"extras/refs/","page":"References","title":"References","text":"K.-A. Lie. An introduction to reservoir simulation using MATLAB/GNU Octave: User guide for the MATLAB Reservoir Simulation Toolbox (MRST) (Cambridge University Press, 2019).\n\n\n\nK.-A. Lie and O. Møyner. Advanced modelling with the MATLAB reservoir simulation toolbox (Cambridge University Press, 2021).\n\n\n\nJ. R. Wallis. Incomplete Gaussian elimination as a preconditioning for generalized conjugate gradient acceleration. In: SPE Reservoir Simulation Conference (Society of Petroleum Engineers, 1983).\n\n\n\nH. Cao, H. A. Tchelepi, J. Wallis and H. Yardumian. Parallel scalable unstructured CPR-type linear solver for reservoir simulation. In: SPE Annual Technical Conference and Exhibition (Society of Petroleum Engineers, 2005).\n\n\n\n","category":"page"},{"location":"man/highlevel/#High-level-API","page":"High-level functions","title":"High-level API","text":"","category":"section"},{"location":"man/highlevel/#Setup","page":"High-level functions","title":"Setup","text":"","category":"section"},{"location":"man/highlevel/#Meshes","page":"High-level functions","title":"Meshes","text":"","category":"section"},{"location":"man/highlevel/#Reservoir","page":"High-level functions","title":"Reservoir","text":"","category":"section"},{"location":"man/highlevel/","page":"High-level functions","title":"High-level functions","text":"reservoir_domain","category":"page"},{"location":"man/highlevel/#JutulDarcy.reservoir_domain","page":"High-level functions","title":"JutulDarcy.reservoir_domain","text":"reservoir_domain(g; permeability = convert_to_si(0.1, :darcy), porosity = 0.1, kwarg...)\n\nSet up a DataDomain instance for given mesh or other representation g. permeability and porosity are then added to the domain. If scalars are passed, they are expanded to cover all cells. Arrays are asserted to match all cells. Permeability is either one value per cell (diagonal scalar), one value per dimension given in each row (for a diagonal tensor) or a vector that represents a compact full tensor representation (6 elements in 3D, 3 in 2D).\n\nDefault data and their values\n\nName Explanation Unit Default\npermeability Rock ability to conduct fluid flow m^2 100 mD\nporosity Rock void fraction open to flow (0 to 1) - 0.3\nrock_thermal_conductivity Heat conductivity of rock Wm K 3.0\nfluid_thermal_conductivity Heat conductivity of fluid phases Wm K 0.6\nrock_density Mass density of rock kg^3m^3 2000.0\n\n\n\n\n\nreservoir_domain(m::Union{SimulationModel, MultiModel})\n\nGet reservoir domain embedded in model.\n\n\n\n\n\nreservoir_domain(case::JutulCase)\n\nGet reservoir domain from a reservoir simulation case.\n\n\n\n\n\n","category":"function"},{"location":"man/highlevel/#Wells","page":"High-level functions","title":"Wells","text":"","category":"section"},{"location":"man/highlevel/","page":"High-level functions","title":"High-level functions","text":"setup_well\nsetup_vertical_well","category":"page"},{"location":"man/highlevel/#JutulDarcy.setup_well","page":"High-level functions","title":"JutulDarcy.setup_well","text":"setup_well(D::DataDomain, reservoir_cells; skin = 0.0, Kh = nothing, radius = 0.1, dir = :z)\n\nSet up a well in reservoir_cells with given skin factor and radius. The order of cells matter as it is treated as a trajectory.\n\n\n\n\n\n","category":"function"},{"location":"man/highlevel/#JutulDarcy.setup_vertical_well","page":"High-level functions","title":"JutulDarcy.setup_vertical_well","text":"setup_vertical_well(D::DataDomain, i, j; <kwarg>)\n\nSet up a vertical well with a DataDomain input that represents the porous medium / reservoir where the wells it to be placed.\n\n\n\n\n\nsetup_vertical_well(g, K, i, j; heel = 1, toe = grid_dims_ijk(g)[3], kwarg...)\n\nSet up a vertical well for given grid g and permeability K at logical indices i, j perforating all cells starting at k-logical index heel to toe.\n\n\n\n\n\n","category":"function"},{"location":"man/highlevel/#Model","page":"High-level functions","title":"Model","text":"","category":"section"},{"location":"man/highlevel/","page":"High-level functions","title":"High-level functions","text":"setup_reservoir_model","category":"page"},{"location":"man/highlevel/#JutulDarcy.setup_reservoir_model","page":"High-level functions","title":"JutulDarcy.setup_reservoir_model","text":"setup_reservoir_model(reservoir, system; wells = [], <keyword arguments>)\nsetup_reservoir_model(reservoir, system; wells = [], context = DefaultContext(), reservoir_context = nothing, backend = :csc, <keyword arguments>)\n\nSet up a reservoir MultiModel for a given reservoir DataDomain typically set up from  reservoir_domain and an optional vector of wells that are created using setup_vertical_well and  setup_well.\n\nThe routine automatically sets up a facility and couples the wells with the reservoir and that facility.\n\n\n\n\n\n","category":"function"},{"location":"man/highlevel/#Initial-state","page":"High-level functions","title":"Initial state","text":"","category":"section"},{"location":"man/highlevel/","page":"High-level functions","title":"High-level functions","text":"setup_reservoir_state","category":"page"},{"location":"man/highlevel/#JutulDarcy.setup_reservoir_state","page":"High-level functions","title":"JutulDarcy.setup_reservoir_state","text":"setup_reservoir_state(model, <keyword arguments>)\n# Ex: For immiscible two-phase\nsetup_reservoir_state(model, Pressure = 1e5, Saturations = [0.2, 0.8])\n\nConvenience constructor that initializes a state for a MultiModel set up using setup_reservoir_model. The main convenience over setup_state is only the reservoir initialization values need be provided: wells are automatically initialized from the connected reservoir cells.\n\nAs an alternative to passing keyword arguments, a Dict{Symbol, Any} instance can be sent in as a second, non-keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"man/highlevel/#Why-is-initialization-needed?","page":"High-level functions","title":"Why is initialization needed?","text":"","category":"section"},{"location":"man/highlevel/#Simple-initialization","page":"High-level functions","title":"Simple initialization","text":"","category":"section"},{"location":"man/highlevel/#Hydrostatic-equilibriation","page":"High-level functions","title":"Hydrostatic equilibriation","text":"","category":"section"},{"location":"man/highlevel/#Simulation","page":"High-level functions","title":"Simulation","text":"","category":"section"},{"location":"man/highlevel/","page":"High-level functions","title":"High-level functions","text":"simulate_reservoir\nsetup_reservoir_simulator","category":"page"},{"location":"man/highlevel/#JutulDarcy.simulate_reservoir","page":"High-level functions","title":"JutulDarcy.simulate_reservoir","text":"simulate_reservoir(state0, model, dt;\n    parameters = setup_parameters(model),\n    restart = false,\n    forces = setup_forces(model),\n    kwarg...\n)\nsimulate_reservoir(case;\n    kwarg...\n)\n\nConvenience function for simulating a reservoir model. This function internally calls setup_reservoir_simulator, simulates the problem and returns a ReservoirSimResult.\n\nYou can optionally unpack this result into the most typical desired outputs:\n\nwellsols, states = simulate_reservoir(...)\n\nwhere wellsols contains the well results and states the reservoir results (pressure, saturations and so on, in each cell of the reservoir domain).\n\n\n\n\n\n","category":"function"},{"location":"man/highlevel/#JutulDarcy.setup_reservoir_simulator","page":"High-level functions","title":"JutulDarcy.setup_reservoir_simulator","text":"setup_reservoir_simulator(models, initializer, parameters = nothing; <keyword arguments>)\n\nArguments\n\nmodels: either a single model or a Dict with the key :Reservoir for multimodels\ninitializer: used to setup state0, must be compatible with model\nparameters: initialized parameters, must be compatible with model if provided\nlinear_solver=:bicgstab: iterative solver to use (provided model supports it)\nprecond=:cpr: preconditioner for iterative solver: Either :cpr or :ilu0.\nrtol=1e-3: relative tolerance for linear solver\ninitial_dt=3600*24.0: initial time-step in seconds (one day by default)\ntarget_its=8: target number of nonlinear iterations per time step\noffset_its=1: dampening parameter for time step selector where larger values lead to more pessimistic estimates.\ntol_cnv=1e-3: maximum allowable point-wise error (volume-balance)\ntol_mb=1e-7: maximum alllowable integrated error (mass-balance)\nspecialize=false: use deep specialization of storage for faster execution, but significantly more compile time\n\nAdditional keyword arguments are passed onto simulator_config.\n\n\n\n\n\n","category":"function"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"EditURL = \"../../../examples/five_spot_ensemble.jl\"","category":"page"},{"location":"examples/five_spot_ensemble/#Quarter-five-spot-example","page":"Quarter-five-spot with variation","title":"Quarter-five-spot example","text":"","category":"section"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"The quarter-five-spot is a standard test problem that simulates 1/4 of the five spot well pattern by assuming axial symmetry. The problem contains an injector in one corner and the producer in the opposing corner, with a significant volume of fluids injected into the domain.","category":"page"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"using JutulDarcy, Jutul\nnx = 50","category":"page"},{"location":"examples/five_spot_ensemble/#Setup","page":"Quarter-five-spot with variation","title":"Setup","text":"","category":"section"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"We define a function that, for a given porosity field, computes a solution with an estimated permeability field. For assumptions and derivation of the specific form of the Kozeny-Carman relation used in this example, see Lie, Knut-Andreas. An introduction to reservoir simulation using MATLAB/GNU Octave: User guide for the MATLAB Reservoir Simulation Toolbox (MRST). Cambridge University Press, 2019, Section 2.5.2","category":"page"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"function perm_kozeny_carman(Φ)\n    return ((Φ^3)*(1e-5)^2)/(0.81*72*(1-Φ)^2);\nend\n\nfunction simulate_qfs(porosity = 0.2)\n    Dx = 1000.0\n    Dz = 10.0\n    Darcy = 9.869232667160130e-13\n    Darcy, bar, kg, meter, Kelvin, day, sec = si_units(:darcy, :bar, :kilogram, :meter, :Kelvin, :day, :second)\n\n    mesh = CartesianMesh((nx, nx, 1), (Dx, Dx, Dz))\n    K = perm_kozeny_carman.(porosity)\n    domain = reservoir_domain(mesh, permeability = K, porosity = porosity)\n    Inj = setup_vertical_well(domain, 1, 1, name = :Injector);\n    Prod = setup_vertical_well(domain, nx, nx, name = :Producer);\n    phases = (LiquidPhase(), VaporPhase())\n    rhoLS = 1000.0*kg/meter^3\n    rhoGS = 700.0*kg/meter^3\n    rhoS = [rhoLS, rhoGS]\n    sys = ImmiscibleSystem(phases, reference_densities = rhoS)\n    model, parameters = setup_reservoir_model(domain, sys, wells = [Inj, Prod])\n    c = [1e-6/bar, 1e-6/bar]\n    ρ = ConstantCompressibilityDensities(p_ref = 150*bar, density_ref = rhoS, compressibility = c)\n    kr = BrooksCoreyRelativePermeabilities(sys, [2.0, 2.0])\n    replace_variables!(model, PhaseMassDensities = ρ, RelativePermeabilities = kr);\n\n    state0 = setup_reservoir_state(model, Pressure = 150*bar, Saturations = [1.0, 0.0])\n    dt = repeat([30.0]*day, 12*10)\n    dt = vcat([0.1, 1.0, 10.0], dt)\n    inj_rate = Dx*Dx*Dz*0.2/sum(dt) # 1 PVI if average porosity is 0.2\n\n    rate_target = TotalRateTarget(inj_rate)\n    I_ctrl = InjectorControl(rate_target, [0.0, 1.0], density = rhoGS)\n    bhp_target = BottomHolePressureTarget(50*bar)\n    P_ctrl = ProducerControl(bhp_target)\n    controls = Dict()\n    controls[:Injector] = I_ctrl\n    controls[:Producer] = P_ctrl\n    forces = setup_reservoir_forces(model, control = controls)\n    return simulate_reservoir(state0, model, dt, parameters = parameters, forces = forces, info_level = -1)\nend","category":"page"},{"location":"examples/five_spot_ensemble/#Simulate-base-case","page":"Quarter-five-spot with variation","title":"Simulate base case","text":"","category":"section"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"This will give the solution with uniform porosity of 0.2.","category":"page"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"ws, states, report_time = simulate_qfs()","category":"page"},{"location":"examples/five_spot_ensemble/#Plot-the-solution-of-the-base-case","page":"Quarter-five-spot with variation","title":"Plot the solution of the base case","text":"","category":"section"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"We observe a radial flow pattern initially, before coning occurs near the producer well once the fluid has reached the opposite corner. The uniform permeability and porosity gives axial symmetry at x=y.","category":"page"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"using CairoMakie\nto_2d(x) = reshape(vec(x), nx, nx)\nget_sat(state) = to_2d(state[:Saturations][2, :])\nnt = length(report_time)\nfig = Figure()\nh = nothing\nax = Axis(fig[1, 1])\nh = contourf!(ax, get_sat(states[nt÷3]))\nax = Axis(fig[1, 2])\nh = contourf!(ax, get_sat(states[nt]))\nColorbar(fig[1, end+1], h)\nfig","category":"page"},{"location":"examples/five_spot_ensemble/#Create-10-realizations","page":"Quarter-five-spot with variation","title":"Create 10 realizations","text":"","category":"section"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"We create a small set of realizations of the same model, with porosity that is uniformly varying between 0.05 and 0.3. This is not especially sophisticated geostatistics - for a more realistic approach, take a look at GeoStats.jl. The main idea is to get significantly different flow patterns as the porosity and permeability changes.","category":"page"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"N = 10\nsaturations = []\nwells = []\nreport_step = nt\nfor i = 1:N\n    poro = 0.05 .+ 0.25*rand(Float64, (nx*nx))\n    ws, states, rt = simulate_qfs(poro)\n    push!(wells, ws)\n    push!(saturations, get_sat(states[report_step]))\nend","category":"page"},{"location":"examples/five_spot_ensemble/#Plot-the-oil-rate-at-the-producer-over-the-ensemble","page":"Quarter-five-spot with variation","title":"Plot the oil rate at the producer over the ensemble","text":"","category":"section"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"using Statistics\nfig = Figure()\nax = Axis(fig[1, 1])\nfor i = 1:N\n    ws = wells[i]\n    q = -ws[:Producer][Symbol(\"Surface oil rate\")]\n    lines!(ax, report_time, q)\nend\nxlims!(ax, [mean(report_time), report_time[end]])\nylims!(ax, 0, 0.0075)\nfig","category":"page"},{"location":"examples/five_spot_ensemble/#Plot-the-average-saturation-over-the-ensemble","page":"Quarter-five-spot with variation","title":"Plot the average saturation over the ensemble","text":"","category":"section"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"avg = mean(saturations)\nfig = Figure()\nh = nothing\nax = Axis(fig[1, 1])\nh = contourf!(ax, avg)\nfig","category":"page"},{"location":"examples/five_spot_ensemble/#Plot-the-isocontour-lines-over-the-ensemble","page":"Quarter-five-spot with variation","title":"Plot the isocontour lines over the ensemble","text":"","category":"section"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"fig = Figure()\nh = nothing\nax = Axis(fig[1, 1])\nfor s in saturations\n    contour!(ax, s, levels = 0:0.1:1)\nend\nfig","category":"page"},{"location":"examples/five_spot_ensemble/#Example-on-GitHub","page":"Quarter-five-spot with variation","title":"Example on GitHub","text":"","category":"section"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"If you would like to run this example yourself, it can be downloaded from the JutulDarcy.jl GitHub repository.","category":"page"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"","category":"page"},{"location":"examples/five_spot_ensemble/","page":"Quarter-five-spot with variation","title":"Quarter-five-spot with variation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/mpi/#Parallel-solution-using-MPI.jl,-PartitionedArrays.jl-and-HYPRE.jl","page":"Parallel solves with MPI","title":"Parallel solution using MPI.jl, PartitionedArrays.jl and HYPRE.jl","text":"","category":"section"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"JutulDarcy can use threads by default, but advanced options can improve performance significantly for larger models.","category":"page"},{"location":"man/mpi/#Overview-of-parallel-support","page":"Parallel solves with MPI","title":"Overview of parallel support","text":"","category":"section"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"There are two main ways of exploiting multiple cores in Jutul/JutulDarcy: Threads are automatically used for assembly and can be used for parts of the linear solve. If you require the best performance, you have to go to MPI where the linear solvers can use a parallel BoomerAMG preconditioner via HYPRE.jl.","category":"page"},{"location":"man/mpi/#MPI-parallelization","page":"Parallel solves with MPI","title":"MPI parallelization","text":"","category":"section"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"MPI parallelizes all aspects of the solver using domain decomposition and allows a simulation to be divided between multiple nodes in e.g. a supercomputer. It is significantly more cumbersome to use than standard simulations as the program must be launched in MPI mode. This is typically a non-interactive process where you launch your MPI processes and once they complete the simulation the result is available on disk.","category":"page"},{"location":"man/mpi/#Thread-parallelization","page":"Parallel solves with MPI","title":"Thread parallelization","text":"","category":"section"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"JutulDarcy also supports threads. By defualt, this only parallelizes property evaluations and assembly of the linear system. For many problems, the linear solve is the limiting factor for performance.Using threads is automatic if you start Julia with multiple threads.","category":"page"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"An experimental thread-parallel backend for matrices and linear algebra can be enabled by setting backend=:csr in the call to setup_reservoir_model. This backend provides additional features such as a parallel zero-overlap ILU(0) implementation and parallel apply for AMG, but these features are still work in progress.","category":"page"},{"location":"man/mpi/#Mixed-mode-parallelism","page":"Parallel solves with MPI","title":"Mixed-mode parallelism","text":"","category":"section"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"You can mix the two approaches: Adding multiple threads to each MPI process can use threads to speed up assembly and property evaluations.","category":"page"},{"location":"man/mpi/#Solving-with-MPI-in-practice","page":"Parallel solves with MPI","title":"Solving with MPI in practice","text":"","category":"section"},{"location":"man/mpi/#Setting-up-the-environment","page":"Parallel solves with MPI","title":"Setting up the environment","text":"","category":"section"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"Tou will have to set up an environment with the following packages under Julia 1.9+: PartitionedArrays, MPI, JutulDarcy and HYPRE. This is generally the best performing solver setup available, even if you are working in a shared memory environment.","category":"page"},{"location":"man/mpi/#Writing-the-script","page":"Parallel solves with MPI","title":"Writing the script","text":"","category":"section"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"Write your script as usual. The following options must then be set:","category":"page"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"setup_reservoir_model should have the extra keyword argument split_wells=true. We also recommend backend=:csr for the best performance.\nsimulate_reservoir or setup_reservoir_simulator should get the optional argument mode = :mpi","category":"page"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"You must then run the file using the approprioate mpiexec as described in the MPI.jl documentation. Specialized functions will be called by simulate_reservoir when this is the case. We document them here, even if we recommend using the high level version of this interface:","category":"page"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"setup_reservoir_simulator_parray\nsimulate_reservoir_parray","category":"page"},{"location":"man/mpi/#Limitations-for-running-in-MPI","page":"Parallel solves with MPI","title":"Limitations for running in MPI","text":"","category":"section"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"note: Note\nYou should be familiar with the MPI programming model to use this feature. See MPI.jl for more details, and how MPI is handled in Julia specifically.","category":"page"},{"location":"man/mpi/","page":"Parallel solves with MPI","title":"Parallel solves with MPI","text":"note: Note\nMPI consolidates results by writing files to disk. Unless you have a plan to work with the distributed states in-memory returned by the simulate! call, it is best to specify a output_path optional argument to setup_reservoir_simulator. After the simulation, that folder will contain output just as if you had run the case in serial.","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"EditURL = \"../../../examples/mrst_validation.jl\"","category":"page"},{"location":"examples/mrst_validation/#Validation-of-Jutul-against-existing-reservoir-simulators","page":"Validation of reservoir simulator","title":"Validation of Jutul against existing reservoir simulators","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"This example contains validation of Jutul against MRST. In general, minor differences are observed. These can be traced back to a combination of different internal timestepping done by the simulators and that JutulDarcy by default uses a multisegment well formulation while MRST uses a standard instantaneous equilibrium model without well bore storage terms. These differences are most evident when simulators start up.","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"These cases have been exported using the MRST jutul module which can export MRST or Eclipse-type of cases to a JutulDarcy-compatible input format. They can then be simulated using simulate_mrst_case.","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"using JutulDarcy, Jutul\nusing CairoMakie","category":"page"},{"location":"examples/mrst_validation/#Define-a-few-utilities-for-plotting-the-MRST-results","page":"Validation of reservoir simulator","title":"Define a few utilities for plotting the MRST results","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"We are going to compare well responses against pre-computed results stored inside the JutulDarcy module.","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"function mrst_case_path(name)\n    base_path, = splitdir(pathof(JutulDarcy))\n    joinpath(base_path, \"..\", \"test\", \"mrst\", \"$(name).mat\")\nend\n\nfunction mrst_solution(result)\n    return result.extra[:mrst][\"extra\"][1][\"mrst_solution\"]\nend\n\nfunction mrst_well_index(mrst_result, k)\n    return findfirst(isequal(\"$k\"), vec(mrst_result[\"names\"]))\nend\n\nfunction get_mrst_comparison(wdata, ref, wname, t = :bhp)\n    yscale = \"m³/s\"\n    if t == :bhp\n        tname = \"Bottom hole pressure\"\n        mname = \"bhp\"\n        yscale = \"Pa\"\n    elseif t == :qos\n        tname = \"Surface oil rate\"\n        mname = \"qOs\"\n    elseif t == :qws\n        tname = \"Surface water rate\"\n        mname = \"qWs\"\n    elseif t == :qgs\n        tname = \"Surface gas rate\"\n        mname = \"qGs\"\n    else\n        error(\"Not supported: $t\")\n    end\n    jutul = wdata[Symbol(tname)]\n    mrst = ref[mname][:, mrst_well_index(ref, wname)]\n\n    return (jutul, mrst, tname, yscale)\nend\n\nfunction plot_comparison(wells, ref, rep_t, t, wells_keys = keys(wells))\n    fig = Figure()\n    ax = Axis(fig[1, 1], xlabel = \"time (days)\")\n    l = \"\"\n    yscale = \"\"\n    T = rep_t./(3600*24.0)\n    for (w, d) in wells\n        if !(w in wells_keys)\n            continue\n        end\n        jutul, mrst, l, yscale = get_mrst_comparison(d, ref, w, t)\n        lines!(ax, T, abs.(jutul), label = \"$w\")\n        scatter!(ax, T, abs.(mrst), markersize = 8)\n    end\n    axislegend()\n    ax.ylabel[] = \"$l ($yscale)\"\n    fig\nend","category":"page"},{"location":"examples/mrst_validation/#The-Egg-model-(oil-water-compressible)","page":"Validation of reservoir simulator","title":"The Egg model (oil-water compressible)","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"A two-phase model that is taken from the first member of the EGG ensemble. For more details, see the paper where the ensemble is introduced:","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"Jansen, Jan-Dirk, et al. \"The egg model–a geological ensemble for reservoir simulation.\" Geoscience Data Journal 1.2 (2014): 192-195.","category":"page"},{"location":"examples/mrst_validation/#Simulate-model","page":"Validation of reservoir simulator","title":"Simulate model","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"egg = simulate_mrst_case(mrst_case_path(\"egg\"), info_level = -1)\nwells = egg.wells\nrep_t = egg.time\nref = mrst_solution(egg);\nnothing #hide","category":"page"},{"location":"examples/mrst_validation/#Compare-well-responses","page":"Validation of reservoir simulator","title":"Compare well responses","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"injectors = [:INJECT1, :INJECT2, :INJECT3, :INJECT4, :INJECT5, :INJECT6, :INJECT7]\nproducers = [:PROD1, :PROD2, :PROD3, :PROD4]","category":"page"},{"location":"examples/mrst_validation/#Bottom-hole-pressures","page":"Validation of reservoir simulator","title":"Bottom hole pressures","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :bhp, injectors)","category":"page"},{"location":"examples/mrst_validation/#Oil-rates","page":"Validation of reservoir simulator","title":"Oil rates","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :qos, producers)","category":"page"},{"location":"examples/mrst_validation/#Water-rates","page":"Validation of reservoir simulator","title":"Water rates","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :qws, producers)","category":"page"},{"location":"examples/mrst_validation/#SPE1-(black-oil,-disgas)","page":"Validation of reservoir simulator","title":"SPE1 (black oil, disgas)","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"A shortened version of the SPE1 benchmark case.","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"Odeh, A.S. 1981. Comparison of Solutions to a Three-Dimensional Black-Oil Reservoir Simulation Problem. J Pet Technol 33 (1): 13–25. SPE-9723-PA","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"For comparison against other simulators, see the equivialent JutulSPE1 example in the Jutul module for MRST","category":"page"},{"location":"examples/mrst_validation/#Simulate-model-2","page":"Validation of reservoir simulator","title":"Simulate model","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"spe1 = simulate_mrst_case(mrst_case_path(\"spe1\"), info_level = -1)\nwells = spe1.wells\nrep_t = spe1.time\nref = mrst_solution(spe1);\nnothing #hide","category":"page"},{"location":"examples/mrst_validation/#Compare-well-responses-2","page":"Validation of reservoir simulator","title":"Compare well responses","text":"","category":"section"},{"location":"examples/mrst_validation/#Bottom-hole-pressures-2","page":"Validation of reservoir simulator","title":"Bottom hole pressures","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :bhp)","category":"page"},{"location":"examples/mrst_validation/#Gas-rates","page":"Validation of reservoir simulator","title":"Gas rates","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :qgs, [:PRODUCER])","category":"page"},{"location":"examples/mrst_validation/#SPE3-(black-oil,-vapoil)","page":"Validation of reservoir simulator","title":"SPE3 (black oil, vapoil)","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"A black-oil variant of the SPE3 benchmark case.","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"Kenyon, D. \"Third SPE comparative solution project: gas cycling of retrograde condensate reservoirs.\" Journal of Petroleum Technology 39.08 (1987): 981-997","category":"page"},{"location":"examples/mrst_validation/#Simulate-model-3","page":"Validation of reservoir simulator","title":"Simulate model","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"spe3 = simulate_mrst_case(mrst_case_path(\"spe3\"), info_level = -1)\nwells = spe3.wells\nrep_t = spe3.time\nref = mrst_solution(spe3);\nnothing #hide","category":"page"},{"location":"examples/mrst_validation/#Compare-well-responses-3","page":"Validation of reservoir simulator","title":"Compare well responses","text":"","category":"section"},{"location":"examples/mrst_validation/#Bottom-hole-pressures-3","page":"Validation of reservoir simulator","title":"Bottom hole pressures","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :bhp, [:PRODUCER])","category":"page"},{"location":"examples/mrst_validation/#Gas-rates-2","page":"Validation of reservoir simulator","title":"Gas rates","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :qgs, [:PRODUCER])","category":"page"},{"location":"examples/mrst_validation/#Oil-rates-2","page":"Validation of reservoir simulator","title":"Oil rates","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :qos, [:PRODUCER])","category":"page"},{"location":"examples/mrst_validation/#SPE9-(black-oil,-disgas)","page":"Validation of reservoir simulator","title":"SPE9 (black oil, disgas)","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"Example of the SPE9 model exported from MRST running in JutulDarcy.","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"Killough, J. E. 1995. Ninth SPE comparative solution project: A   reexamination of black-oil simulation. In SPE Reservoir Simulation   Symposium,  12-15 February 1995, San Antonio, Texas. SPE 29110-MS","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"For comparison against other simulators, see the equivialent JutulSPE9 example in the Jutul module for MRST","category":"page"},{"location":"examples/mrst_validation/#Simulate-model-4","page":"Validation of reservoir simulator","title":"Simulate model","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"spe9 = simulate_mrst_case(mrst_case_path(\"spe9\"), info_level = -1)\nwells = spe9.wells\nrep_t = spe9.time\nref = mrst_solution(spe9);\nnothing #hide","category":"page"},{"location":"examples/mrst_validation/#Compare-well-responses-4","page":"Validation of reservoir simulator","title":"Compare well responses","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"injectors = [:INJE1]\nproducers = [Symbol(\"PROD$i\") for i in 1:25]","category":"page"},{"location":"examples/mrst_validation/#Injector-water-rate","page":"Validation of reservoir simulator","title":"Injector water rate","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :qws, injectors)","category":"page"},{"location":"examples/mrst_validation/#Oil-rates-3","page":"Validation of reservoir simulator","title":"Oil rates","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :qos, producers)","category":"page"},{"location":"examples/mrst_validation/#Water-rates-2","page":"Validation of reservoir simulator","title":"Water rates","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :qws, producers)","category":"page"},{"location":"examples/mrst_validation/#Bottom-hole-pressures-4","page":"Validation of reservoir simulator","title":"Bottom hole pressures","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"plot_comparison(wells, ref, rep_t, :bhp, producers)","category":"page"},{"location":"examples/mrst_validation/#Example-on-GitHub","page":"Validation of reservoir simulator","title":"Example on GitHub","text":"","category":"section"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"If you would like to run this example yourself, it can be downloaded from the JutulDarcy.jl GitHub repository.","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"","category":"page"},{"location":"examples/mrst_validation/","page":"Validation of reservoir simulator","title":"Validation of reservoir simulator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"EditURL = \"../../../examples/wells_intro.jl\"","category":"page"},{"location":"examples/wells_intro/#Example-with-wells","page":"Intro to wells","title":"Example with wells","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"This example demonstrates how to set up a 3D domain with a layered permeability field, define wells and solve a simple production-injection schedule. We begin by loading the Jutul package that contains generic features like grids and linear solvers and the JutulDarcy package itself.","category":"page"},{"location":"examples/wells_intro/#Preliminaries","page":"Intro to wells","title":"Preliminaries","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"using JutulDarcy, Jutul","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"JutulDarcy uses SI units internally. It is therefore convenient to define a few constants at the start of the script to have more managable numbers later on.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"Darcy, bar, kg, meter, day = si_units(:darcy, :bar, :kilogram, :meter, :day)","category":"page"},{"location":"examples/wells_intro/#Defining-a-porous-medium","page":"Intro to wells","title":"Defining a porous medium","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We start by defining the static part of our simulation problem – the porous medium itself.","category":"page"},{"location":"examples/wells_intro/#Defining-the-grid","page":"Intro to wells","title":"Defining the grid","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"The first step is to create a grid for our simulation domain. We make a tiny 5 by 5 grid with 4 layers that discretizes a physical domain of 2000 by 1500 by 50 meters.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"nx = ny = 5\nnz = 4\ndims = (nx, ny, nz)\ng = CartesianMesh(dims, (2000.0, 1500.0, 50.0))","category":"page"},{"location":"examples/wells_intro/#Adding-properties-and-making-a-domain","page":"Intro to wells","title":"Adding properties and making a domain","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"The grid by itself does not fully specify a porous medium. For that we need to specify the permeability in each cell and the porosity. Permeability, often denoted by a positive-definite tensor K, describes the relationship between a pressure gradient and the flow through the medium. Porosity is a dimensionless number between 0 and 1 that describes how much of the porous medium is void space where fluids can be present. The assumption of Darcy flow becomes less reasonable for high porosity values and the flow equations break down at zero porosity. A porosity of 0.2 is then a safe choice.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"Jutul uses the DataDomain type to store a domain/grid together with data. For porous media simulation, JutulDarcy includes a convenience function reservoir_domain that contains defaults for permeability and porosity. We specify the permeability per-cell with varying values per layer in the vertical direction and a single porosity value for all cells that the function will expand for us. From the output, we can see that basic geometry primitives are also automatically added:","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"nlayer = nx*ny # Cells in each layer\nK = vcat(\n    repeat([0.65], nlayer),\n    repeat([0.3], nlayer),\n    repeat([0.5], nlayer),\n    repeat([0.2], nlayer)\n    )*Darcy\n\ndomain = reservoir_domain(g, permeability = K, porosity = 0.2)","category":"page"},{"location":"examples/wells_intro/#Defining-wells","page":"Intro to wells","title":"Defining wells","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"Now that we have a porous medium with all static properties set up, it is time to introduce some driving forces. Jutul assumes no-flow boundary conditions on all boundary faces unless otherwise specified so we can go ahead and add wells to the model.","category":"page"},{"location":"examples/wells_intro/#A-vertical-producer-well","page":"Intro to wells","title":"A vertical producer well","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We will define two wells: A first well is named \"Producer\" and is a vertical well positioned at (1, 1). By default, the setup_vertical_well function perforates all layers in the model.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"Prod = setup_vertical_well(domain, 1, 1, name = :Producer);\nnothing #hide","category":"page"},{"location":"examples/wells_intro/#A-single-perforation-injector","page":"Intro to wells","title":"A single-perforation injector","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We also define an injector by setup_well. This function allows us to pass a vector of either cell indices or tuples of logical indices that the well trajectory will follow. We setup the injector in the upper left corner.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"Inj = setup_well(domain, [(nx, ny, 1)], name = :Injector);\nnothing #hide","category":"page"},{"location":"examples/wells_intro/#Choosing-a-fluid-system","page":"Intro to wells","title":"Choosing a fluid system","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"To solve multiphase flow with our little toy reservoir we need to pick a fluid system. The type of system determines what physical effects are modelled, what parameters are required and the runtime and accuracy of the resulting simulation. The choice is in practice a trade-off between accuracy, runtime and available data that should be informed by modelling objectives. In this example our goal is to understand how to set up a simple well problem and the ImmiscibleSystem requires a minimal amount of input. We define liquid and gas phases and their densities at some reference conditions and instantiate the system.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"# Set up a two-phase immiscible system and define a density secondary variable\nphases = (LiquidPhase(), VaporPhase())\nrhoLS = 1000.0\nrhoGS = 100.0\nrhoS = [rhoLS, rhoGS] .* kg/meter^3\nsys = ImmiscibleSystem(phases, reference_densities = rhoS)","category":"page"},{"location":"examples/wells_intro/#Creating-the-model","page":"Intro to wells","title":"Creating the model","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"The same fluid system can be used for both flow inside the wells and the reservoir. JutulDarcy treats wells as first-class citizens and models flow inside the well bore using the same fluid description as the reservoir, with modified equations to account for the non-Darcy velocities. We call the utility function that sets up all of this for us:","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"model, parameters = setup_reservoir_model(domain, sys, wells = [Inj, Prod])\nmodel","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"The model is an instance of the MultiModel from Jutul where a submodel is defined for the reservoir, each of the wells and the facility that controls both wells. In addition we can see the cross-terms that couple these wells together. If we want to see more details on how either of these are set up, we can display for example the reservoir model.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"reservoir = model[:Reservoir]","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We can see that the model contains primary variables, secondary variables (sometimes referred to as properties) and static parameters in addition to the system we already set up. These can be replaced or modified to alter the behavior of the system.","category":"page"},{"location":"examples/wells_intro/#Replace-the-density-function-with-our-custom-version","page":"Intro to wells","title":"Replace the density function with our custom version","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"Let us change the definition of phase mass densities for our model. We'd like to model our liquid phase as weakly compressible and the vapor phase with more significant compressibility. A common approach is to define densities rho_alpha^s at some reference pressure p_r and use a phase compressibility c_alpha to extrapolate around that known value.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"rho_alpha (p) = rho_alpha^s exp((p - p_r)c_alpha)","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"This is already implement in Jutul and we simply need to instantiate the variable definition:","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"c = [1e-6/bar, 1e-4/bar]\nρ = ConstantCompressibilityDensities(p_ref = 1*bar, density_ref = rhoS, compressibility = c)","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"Before replacing it in the model. This change will propagate to all submodels that have a definition given for PhaseMassDensities, including the wells. The facility, which does not know about densities, will ignore it.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"replace_variables!(model, PhaseMassDensities = ρ);\nnothing #hide","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"This concludes the setup of the model.","category":"page"},{"location":"examples/wells_intro/#Set-up-initial-state","page":"Intro to wells","title":"Set up initial state","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"The model is time-dependent and requires initial conditions. For the immiscible model it is sufficient to specify the reference phase pressure and the saturations for both phases, summed up to one. These can be specified per cell or one for the entire grid. Specifying a single pressure for the entire model is not very realistic, but should be fine for our simple example. The initial conditions will equilibrate themselves from gravity fairly quickly.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"state0 = setup_reservoir_state(model, Pressure = 150*bar, Saturations = [1.0, 0.0])","category":"page"},{"location":"examples/wells_intro/#Set-up-report-time-steps-and-injection-rate","page":"Intro to wells","title":"Set up report time steps and injection rate","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We create a set of time-steps. These are report steps where the solution will be reported, but the simulator itself will do internal subdivision of time steps if these values are too coarse for the solvers. We also define an injection rate of a full pore-volume (at reference conditions) of gas.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"dt = repeat([30.0]*day, 12*5)\npv = pore_volume(model, parameters)\ninj_rate = sum(pv)/sum(dt)","category":"page"},{"location":"examples/wells_intro/#Set-up-well-controls","page":"Intro to wells","title":"Set up well controls","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We then set up a total rate target (positive value for injection) together with a corresponding injection control that specifies the mass fractions of the two components/phases for pure gas injection, with surface density given by the known gas density. The producer operates at a fixed bottom hole pressure. These are given as a Dict with keys that correspond to the well names.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"rate_target = TotalRateTarget(inj_rate)\nI_ctrl = InjectorControl(rate_target, [0.0, 1.0], density = rhoGS)\nbhp_target = BottomHolePressureTarget(50*bar)\nP_ctrl = ProducerControl(bhp_target)\ncontrols = Dict()\ncontrols[:Injector] = I_ctrl\ncontrols[:Producer] = P_ctrl\n# Set up the forces","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"Set up forces for the whole model. For this example, all other forces than the well controls are defaulted (amounting to no-flow for the reservoir). Jutul supports either a single set of forces for the entire simulation, or a vector of equal length to dt with varying forces. Reasonable operational limits for wells are also set up by default.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"forces = setup_reservoir_forces(model, control = controls)","category":"page"},{"location":"examples/wells_intro/#Simulate-the-model","page":"Intro to wells","title":"Simulate the model","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We are finally ready to simulate the model for the given initial state state0, report steps dt, parameters and forces. As the model is small, barring any compilation time, this should run in about 300 ms.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"result = simulate_reservoir(state0, model, dt, parameters = parameters, forces = forces)","category":"page"},{"location":"examples/wells_intro/#Unpacking-the-result","page":"Intro to wells","title":"Unpacking the result","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"The result contains a lot of data. This can be unpacked to get the most typical desired outputs: Well responses, reservoir states and the time they correspond to.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"wd, states, t = result","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We could in fact equally well have written wd, states, t = simulate_reservoir(...) to arrive at the same result.","category":"page"},{"location":"examples/wells_intro/#Plot-the-producer-responses","page":"Intro to wells","title":"Plot the producer responses","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We load a plotting package to plot the wells.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"using CairoMakie","category":"page"},{"location":"examples/wells_intro/#Plot-the-surface-rates-at-the-producer","page":"Intro to wells","title":"Plot the surface rates at the producer","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"We observe that the total rate does not vary much, but the composition changes from liquid to gas as the front propagate through the domain and hits the producer well.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"qg = wd[:Producer][Symbol(\"Surface gas rate\")]\nqt = wd[:Producer][Symbol(\"Surface total rate\")]\nql = qt - qg\nx = t/day\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Time (days)\",\n                     ylabel = \"Rate (m³/day)\",\n                     title = \"Well production rates\")\nlines!(ax, x, abs.(qg).*day, label = \"Gas\")\nlines!(ax, x, abs.(ql).*day, label = \"Liquid\")\nlines!(ax, x, abs.(qt).*day, label = \"Total\")\naxislegend(position = :rb)\nfig","category":"page"},{"location":"examples/wells_intro/#Plot-bottom-hole-pressure-of-the-injector","page":"Intro to wells","title":"Plot bottom hole pressure of the injector","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"The pressure builds during injection, until the gas breaks through to the other well.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"bh = wd[:Injector][Symbol(\"Bottom hole pressure\")]\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Time (days)\",\n                     ylabel = \"Bottom hole pressure (bar)\",\n                     title = \"Injector bottom hole pressure\")\nlines!(ax, x, bh./bar)\nfig","category":"page"},{"location":"examples/wells_intro/#Example-on-GitHub","page":"Intro to wells","title":"Example on GitHub","text":"","category":"section"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"If you would like to run this example yourself, it can be downloaded from the JutulDarcy.jl GitHub repository.","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"","category":"page"},{"location":"examples/wells_intro/","page":"Intro to wells","title":"Intro to wells","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/primary/#Primary-variables","page":"Primary variables","title":"Primary variables","text":"","category":"section"},{"location":"man/primary/#Fluid-systems","page":"Primary variables","title":"Fluid systems","text":"","category":"section"},{"location":"man/primary/#General","page":"Primary variables","title":"General","text":"","category":"section"},{"location":"man/primary/","page":"Primary variables","title":"Primary variables","text":"Pressure\nImmiscibleSaturation","category":"page"},{"location":"man/primary/#JutulDarcy.Pressure","page":"Primary variables","title":"JutulDarcy.Pressure","text":"Pressure(; max_abs = nothing, max_rel = 0.2, scale = si_unit(:bar), maximum = Inf, minimum = DEFAULT_MINIMUM_PRESSURE)\n\nPressure variable definition. max_abs/max_rel maximum allowable absolute/relative change over a Newton iteration, scale is a \"typical\" value used to regularize the linear system, maximum the largest possible value and minimum the smallest.\n\n\n\n\n\n","category":"type"},{"location":"man/primary/#JutulDarcy.ImmiscibleSaturation","page":"Primary variables","title":"JutulDarcy.ImmiscibleSaturation","text":"A single saturation variable that represents the \"other\" phase in a three phase compositional system where two phases are predicted by an EoS\n\n\n\n\n\n","category":"type"},{"location":"man/primary/#Immiscible-flow","page":"Primary variables","title":"Immiscible flow","text":"","category":"section"},{"location":"man/primary/","page":"Primary variables","title":"Primary variables","text":"Saturations","category":"page"},{"location":"man/primary/#JutulDarcy.Saturations","page":"Primary variables","title":"JutulDarcy.Saturations","text":"Saturations(; ds_max = 0.2)\n\nSaturations as primary variable. ds_max controls maximum allowable saturation change between two successive Newton iterations.\n\n\n\n\n\n","category":"type"},{"location":"man/primary/#Black-oil-flow","page":"Primary variables","title":"Black-oil flow","text":"","category":"section"},{"location":"man/primary/","page":"Primary variables","title":"Primary variables","text":"BlackOilUnknown\nBlackOilX","category":"page"},{"location":"man/primary/#JutulDarcy.BlackOilUnknown","page":"Primary variables","title":"JutulDarcy.BlackOilUnknown","text":"BlackOilUnknown(dr_max = Inf, ds_max = Inf)\n\nVariable defining the variable switching black-oil variable. The ds_max argument limits the maximum saturation change over a single Newton iteration when both a oileic and gaseous phase is present. The dr_max limits the maximum change in the undersaturated variable, taken relative to the maximum value of the undersaturated variable.\n\nDuring simulation, this variable can take on the following interpretations: Gas saturation, Rs or Rv, depending on the phase conditions and miscibility model.\n\n\n\n\n\n","category":"type"},{"location":"man/primary/#JutulDarcy.BlackOilX","page":"Primary variables","title":"JutulDarcy.BlackOilX","text":"BlackOilX(sys::BlackOilVariableSwitchingSystem, p; sw = 0.0, so = 0.0, sg = 0.0, rs = 0.0, rv = 0.0, region = 1)\n\nHigh level initializer for the black oil unknown degree of freedom. Will try to fill in the gaps unless system is really underspecified.\n\n\n\n\n\n","category":"type"},{"location":"man/primary/#Compositional-flow","page":"Primary variables","title":"Compositional flow","text":"","category":"section"},{"location":"man/primary/","page":"Primary variables","title":"Primary variables","text":"OverallMoleFractions","category":"page"},{"location":"man/primary/#JutulDarcy.OverallMoleFractions","page":"Primary variables","title":"JutulDarcy.OverallMoleFractions","text":"OverallMoleFractions(;dz_max = 0.2)\n\nOverall mole fractions definition for compositional. dz_max is the maximum allowable change in any composition during a single Newton iteration.\n\n\n\n\n\n","category":"type"},{"location":"man/primary/#Wells","page":"Primary variables","title":"Wells","text":"","category":"section"},{"location":"man/primary/","page":"Primary variables","title":"Primary variables","text":"TotalMassFlux","category":"page"},{"location":"man/primary/#JutulDarcy.TotalMassFlux","page":"Primary variables","title":"JutulDarcy.TotalMassFlux","text":"TotalMassFlux(scale = si_unit(:day), max_abs = nothing, max_rel = nothing)\n\nVariable normally used as primary variable. Represents the total mass flux going through a face. The typical usage is the mass flow through a segment of a MultiSegmentWell.\n\nNote that the flow direction can often switch signs over a segment during a complex simulation. Setting max_rel to something other than nothing can therefore lead to severe convergence issues in the case of flow reversal.\n\nFields (as keyword arguments)\n\nscale: Scaling for variable\nmax_abs: Max absolute change between Newton iterations\nmax_rel: Maximum relative change between Newton iterations\n\n\n\n\n\n","category":"type"},{"location":"man/primary/#WellGroup-/-Facility","page":"Primary variables","title":"WellGroup / Facility","text":"","category":"section"},{"location":"man/primary/","page":"Primary variables","title":"Primary variables","text":"TotalSurfaceMassRate","category":"page"},{"location":"man/primary/#JutulDarcy.TotalSurfaceMassRate","page":"Primary variables","title":"JutulDarcy.TotalSurfaceMassRate","text":"TotalSurfaceMassRate(max_absolute_change = nothing, max_relative_change = nothing)\n\nVariable, typically representing the primary variable for a WellGroup. The variable is a single entry per well and solves for the total surface mass rate from a well to the facility model.\n\n\n\n\n\n","category":"type"},{"location":"#JutulDarcy.jl-reservoir-simulation-and-porous-media-flow-in-Julia","page":"Home","title":"JutulDarcy.jl - reservoir simulation and porous media flow in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = JutulDarcy","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using Jutul;\n    using JutulDarcy;\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for JutulDarcy.jl. The documentation is currently limited to docstrings and a series of examples. The examples are sorted by complexity. We suggest you start with Gravity segregation example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"JutulDarcy builds upon the general features found in Jutul.jl. You may also find it useful to look at the Jutul.jl documentation.","category":"page"},{"location":"#Package-docstring","page":"Home","title":"Package docstring","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JutulDarcy","category":"page"},{"location":"#JutulDarcy.JutulDarcy","page":"Home","title":"JutulDarcy.JutulDarcy","text":"(Image: DOI) (Image: Dev) (Image: Build Status)\n\n(Image: Jutul Darcy logo)\n\nReservoir simulation in Julia\n\nJutulDarcy.jl: Darcy-scale and subsurface flow (CO2 sequestration, gas/H2 storage, oil/gas fields) using Jutul.jl developed by the Applied Computational Science group at SINTEF Digital.\n\nKey features\n\nJutulDarcy is a general purpose porous media simulator with high performance written in Julia. It is fully differentiable with respect to forces and discretization parameters.\n\nPhysical systems\n\nImmiscible multi-phase flow\nBlack-oil type models with support for both dissolved vapor (Rs) and vaporized liquid (Rv)\nEquation-of-state compositional flow with up to three phases and any number of components\n\nAll solvers can incorporate general multisegment wells with rigorous mass balance, friction pressure loss, complex well limits and time-dependent controls.\n\nArchitecture\n\nWritten in pure Julia, with automatic differentiation and dynamic sparsity detection\nSupport for sensitivities with respect to any model parameters using the adjoint method\nHigh performance assembly and linear solvers, with support for two-stage CPR BILU(0)-CPR Krylov solvers\nMPI support with domain decomposition and BoomerAMG-CPR solver with automatic METIS partitioning\n\nInput/output and workflow tools\n\nUnstructured grids and complex cases input from the Matlab Reservoir Simulation Toolbox (MRST) using the jutul module\nExperimental support for reading in and running .DATA files with corner point grids\n3D visualization of grids and wells by loading a Makie.jl backend (requires Julia 1.9, GLMakie for interactivity)\nInteractive plotting of well curves\n\nThe compositional simulator has been matched against commercial offerings, AD-GPRS and MRST. The blackoil simulator has been validated on the standard SPE benchmarks (SPE1, SPE9, ...).\n\nExample run times on benchmarks\n\nName Cells Report steps Preconditioner Time [s]\nSPE1CASE2 300 120 block-ILU(0) 0.30\nSPE9 9000 35 block-ILU(0) 3.41\nEgg 18553 123 CPR-block-ILU(0) 8.60\n\nSimulated with default julia, no threads. Runtime with single-threaded HYPRE on the full SPE10 model 2 model is about 20 minutes with default settings and strict mass-balance tolerances and less than 4 minutes for realization 1 of the OLYMPUS optimization benchmark challenge.\n\nA few of the packages used by Jutul and JutulDarcy\n\nJutul builds upon many of the excellent packages in the Julia ecosystem. Here are a few of them, and what they are used for:\n\nForwardDiff.jl implements the Dual number class used throughout the code\nSparsityTracing.jl provides sparsity detection inside Jutul\nKrylov.jl provides the iterative linear solvers\nILUZero.jl for ILU(0) preconditioners\nAlgebraicMultigrid.jl for AMG preconditioners\nHYPRE.jl for robust AMG preconditioners with MPI support\nPartitionedArrays.jl for MPI assembly and linear solve\nTullio.jl for automatically optimized loops and Polyester.jl for lightweight threads\nTimerOutputs.jl and ProgressMeter.jl gives nice output to terminal \nMakie.jl is used for the visualization features\nMultiComponentFlash.jl provides many of the compositional features\n\n...and many more, both directly in the Project.toml file and indirectly!\n\nGetting started\n\nInstall Julia and add the package to your environment of choice:\n\nusing Pkg\nPkg.add(\"CairoMakie\")\nPkg.add(\"Jutul\")\nPkg.add(\"JutulDarcy\")\n\nYou can then run any of the examples in the examples directory by including them.\n\nAdditional examples and further reading\n\nThe documentation is still work in progress, but contains a fair bit of useful information. In addition, see the examples folder for more information. Some functionality is also demonstrated in the tests.\n\nInternals and undocumented functions are subject to change at this time. However, the main interface for the reservoir simulator itself seen in the examples should be fairly stable.\n\n\n\nModule exports:\n\nAqueousPhase\nBlackOilUnknown\nBlackOilX\nBottomHolePressureTarget\nBrooksCoreyRelativePermeabilities\nCPRPreconditioner\nConstMuBTable\nConstantCompressibilityDensities\nDeckPhaseMassDensities\nDeckPhaseViscosities\nDeckShrinkageFactors\nDisabledControl\nDisabledTarget\nFlowBoundaryCondition\nHistoricalReservoirVoidageTarget\nImmiscibleSaturation\nImmiscibleSystem\nInjectorControl\nLiquidPhase\nMassSource\nMinimalTPFAGrid\nMixedWellSegmentFlow\nMuBTable\nMultiPhaseCompositionalSystemLV\nMultiPhaseSystem\nMultiSegmentWell\nOverallMoleFractions\nPerforationMask\nPerforations\nPhaseMassDensities\nPhaseMassFractions\nPhaseRelativePermeability\nPotentialDropBalanceWell\nPressure\nProducerControl\nRelativePermeabilities\nReservoirSimResult\nReservoirVoidageTarget\nSaturations\nSegmentWellBoreFrictionHB\nSinglePhaseRateTarget\nSinglePhaseSystem\nSourceTerm\nStandardBlackOilSystem\nStandardVolumeSource\nSurfaceGasRateTarget\nSurfaceLiquidRateTarget\nSurfaceOilRateTarget\nSurfaceWaterRateTarget\nTabulatedSimpleRelativePermeabilities\nThermalSystem\nThreePhaseCompositionalDensitiesLV\nThreePhaseLBCViscositiesLV\nTotalMass\nTotalMassFlux\nTotalMassVelocityMassFractionsFlow\nTotalMasses\nTotalRateTarget\nTotalSurfaceMassRate\nVaporPhase\nVolumeSource\nWellDomain\nWellGroup\nWells\navailable_well_targets\ncomponent_mass_fluxes!\ncompute_peaceman_index\ndiscretized_domain_tpfv_flow\ndiscretized_domain_well\nfluid_volume\nfull_well_outputs\nget_1d_reservoir\nget_test_setup\nget_well_from_mrst_data\nnumber_of_phases\nplot_reservoir\nplot_reservoir_simulation_result\nplot_well!\nplot_well_results\npore_volume\nreservoir_domain\nreservoir_linsolve\nreservoir_model\nreservoir_system\nsegment_pressure_drop\nsetup_case_from_data_file\nsetup_case_from_mrst\nsetup_reservoir_forces\nsetup_reservoir_model\nsetup_reservoir_simulator\nsetup_reservoir_simulator_parray\nsetup_reservoir_state\nsetup_vertical_well\nsetup_well\nsimulate_data_file\nsimulate_mrst_case\nsimulate_reservoir\nsimulate_reservoir_parray\ntable_to_relperm\nupdate_total_masses!\nwell_mismatch\nwell_output\nwell_symbols\nwellgroup_symbols\n\n\n\n\n\n","category":"module"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"man/parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"man/parameters/#General","page":"Parameters","title":"General","text":"","category":"section"},{"location":"man/parameters/","page":"Parameters","title":"Parameters","text":"FluidVolume","category":"page"},{"location":"man/parameters/#Reservoir-parameters","page":"Parameters","title":"Reservoir parameters","text":"","category":"section"},{"location":"man/parameters/#Transmissibility","page":"Parameters","title":"Transmissibility","text":"","category":"section"},{"location":"man/parameters/","page":"Parameters","title":"Parameters","text":"JutulDarcy.Transmissibilities","category":"page"},{"location":"man/parameters/#JutulDarcy.Transmissibilities","page":"Parameters","title":"JutulDarcy.Transmissibilities","text":"Transmissibilities()\n\nVariable/parameter used to define the cell-to-cell transmissibilities when using a two-point flux approximation scheme.\n\n\n\n\n\n","category":"type"},{"location":"man/parameters/","page":"Parameters","title":"Parameters","text":"reservoir_transmissibility","category":"page"},{"location":"man/parameters/#Other","page":"Parameters","title":"Other","text":"","category":"section"},{"location":"man/parameters/","page":"Parameters","title":"Parameters","text":"TwoPointGravityDifference\nConnateWater\nEndPointScalingCoefficients","category":"page"},{"location":"man/parameters/#Well-parameters","page":"Parameters","title":"Well parameters","text":"","category":"section"},{"location":"man/parameters/","page":"Parameters","title":"Parameters","text":"WellIndices\nPerforationGravityDifference","category":"page"}]
}
