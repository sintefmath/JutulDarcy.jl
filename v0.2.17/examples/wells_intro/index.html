<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Intro to wells · JutulDarcy.jl</title><meta name="title" content="Intro to wells · JutulDarcy.jl"/><meta property="og:title" content="Intro to wells · JutulDarcy.jl"/><meta property="twitter:title" content="Intro to wells · JutulDarcy.jl"/><meta name="description" content="Documentation for JutulDarcy.jl."/><meta property="og:description" content="Documentation for JutulDarcy.jl."/><meta property="twitter:description" content="Documentation for JutulDarcy.jl."/><meta property="og:url" content="https://sintefmath.github.io/JutulDarcy.jl/examples/wells_intro/"/><meta property="twitter:url" content="https://sintefmath.github.io/JutulDarcy.jl/examples/wells_intro/"/><link rel="canonical" href="https://sintefmath.github.io/JutulDarcy.jl/examples/wells_intro/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JutulDarcy.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JutulDarcy.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/intro/">Getting started</a></li><li><a class="tocitem" href="../../man/highlevel/">High-level functions</a></li><li><a class="tocitem" href="../../man/input_files/">Input files</a></li><li><a class="tocitem" href="../../man/forces/">Driving forces</a></li><li><a class="tocitem" href="../../man/systems/">Supported physical systems</a></li><li><a class="tocitem" href="../../man/wells/">Wells and controls</a></li><li><a class="tocitem" href="../../man/solution/">Solving the equations</a></li><li><a class="tocitem" href="../../man/primary/">Primary variables</a></li><li><a class="tocitem" href="../../man/secondary/">Secondary variables (properties)</a></li><li><a class="tocitem" href="../../man/parameters/">Parameters</a></li><li><a class="tocitem" href="../../man/plotting/">Visualization</a></li></ul></li><li><span class="tocitem">Advanced usage</span><ul><li><a class="tocitem" href="../../man/mpi/">Parallel solves with MPI</a></li><li><a class="tocitem" href="../../man/compiled/">JutulDarcy.jl compiled app</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../intro/">Getting started</a></li><li><a class="tocitem" href="../two_phase_gravity_segregation/">Gravity segregation</a></li><li><a class="tocitem" href="../two_phase_buckley_leverett/">Two-phase Buckley-Leverett</a></li><li><a class="tocitem" href="../two_phase_unstable_gravity/">Gravity circulation with CPR preconditioner</a></li><li class="is-active"><a class="tocitem" href>Intro to wells</a><ul class="internal"><li><a class="tocitem" href="#Preliminaries"><span>Preliminaries</span></a></li><li><a class="tocitem" href="#Defining-a-porous-medium"><span>Defining a porous medium</span></a></li><li><a class="tocitem" href="#Defining-wells"><span>Defining wells</span></a></li><li><a class="tocitem" href="#Choosing-a-fluid-system"><span>Choosing a fluid system</span></a></li><li><a class="tocitem" href="#Set-up-initial-state"><span>Set up initial state</span></a></li><li><a class="tocitem" href="#Set-up-report-time-steps-and-injection-rate"><span>Set up report time steps and injection rate</span></a></li><li><a class="tocitem" href="#Set-up-well-controls"><span>Set up well controls</span></a></li><li><a class="tocitem" href="#Simulate-the-model"><span>Simulate the model</span></a></li><li><a class="tocitem" href="#Plot-the-producer-responses"><span>Plot the producer responses</span></a></li><li><a class="tocitem" href="#Plot-the-surface-rates-at-the-producer"><span>Plot the surface rates at the producer</span></a></li><li><a class="tocitem" href="#Plot-bottom-hole-pressure-of-the-injector"><span>Plot bottom hole pressure of the injector</span></a></li><li><a class="tocitem" href="#Example-on-GitHub"><span>Example on GitHub</span></a></li></ul></li><li><a class="tocitem" href="../five_spot_ensemble/">Quarter-five-spot with variation</a></li><li><a class="tocitem" href="../co2_brine_2d_vertical/">Intro to compositional flow</a></li><li><a class="tocitem" href="../compositional_5components/">Compositional with five components</a></li><li><a class="tocitem" href="../optimize_simple_bl/">Parameter optimization of Buckley-Leverett</a></li><li><a class="tocitem" href="../mrst_validation/">Validation of reservoir simulator</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../ref/jutul/">Jutul functions</a></li></ul></li><li><span class="tocitem">Additional information </span><ul><li><a class="tocitem" href="../../extras/refs/">References</a></li><li><a class="tocitem" href="../../extras/faq/">FAQ</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Intro to wells</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Intro to wells</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sintefmath/JutulDarcy.jl/blob/main/examples/wells_intro.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Example-with-wells"><a class="docs-heading-anchor" href="#Example-with-wells">Example with wells</a><a id="Example-with-wells-1"></a><a class="docs-heading-anchor-permalink" href="#Example-with-wells" title="Permalink"></a></h1><p>This example demonstrates how to set up a 3D domain with a layered permeability field, define wells and solve a simple production-injection schedule. We begin by loading the <code>Jutul</code> package that contains generic features like grids and linear solvers and the <code>JutulDarcy</code> package itself.</p><h2 id="Preliminaries"><a class="docs-heading-anchor" href="#Preliminaries">Preliminaries</a><a id="Preliminaries-1"></a><a class="docs-heading-anchor-permalink" href="#Preliminaries" title="Permalink"></a></h2><pre><code class="language-julia hljs">using JutulDarcy, Jutul</code></pre><p><code>JutulDarcy</code> uses SI units internally. It is therefore convenient to define a few constants at the start of the script to have more managable numbers later on.</p><pre><code class="language-julia hljs">Darcy, bar, kg, meter, day = si_units(:darcy, :bar, :kilogram, :meter, :day)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(9.86923266716013e-13, 100000.0, 1.0, 1.0, 86400.0)</code></pre><h2 id="Defining-a-porous-medium"><a class="docs-heading-anchor" href="#Defining-a-porous-medium">Defining a porous medium</a><a id="Defining-a-porous-medium-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-porous-medium" title="Permalink"></a></h2><p>We start by defining the static part of our simulation problem – the porous medium itself.</p><h3 id="Defining-the-grid"><a class="docs-heading-anchor" href="#Defining-the-grid">Defining the grid</a><a id="Defining-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-grid" title="Permalink"></a></h3><p>The first step is to create a grid for our simulation domain. We make a tiny 5 by 5 grid with 4 layers that discretizes a physical domain of 2000 by 1500 by 50 meters.</p><pre><code class="language-julia hljs">nx = ny = 5
nz = 4
dims = (nx, ny, nz)
g = CartesianMesh(dims, (2000.0, 1500.0, 50.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CartesianMesh (3D) with 5x5x4=100 cells</code></pre><h3 id="Adding-properties-and-making-a-domain"><a class="docs-heading-anchor" href="#Adding-properties-and-making-a-domain">Adding properties and making a domain</a><a id="Adding-properties-and-making-a-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-properties-and-making-a-domain" title="Permalink"></a></h3><p>The grid by itself does not fully specify a porous medium. For that we need to specify the permeability in each cell and the porosity. Permeability, often denoted by a positive-definite tensor K, describes the relationship between a pressure gradient and the flow through the medium. Porosity is a dimensionless number between 0 and 1 that describes how much of the porous medium is void space where fluids can be present. The assumption of Darcy flow becomes less reasonable for high porosity values and the flow equations break down at zero porosity. A porosity of 0.2 is then a safe choice.</p><p>Jutul uses the <code>DataDomain</code> type to store a domain/grid together with data. For porous media simulation, <code>JutulDarcy</code> includes a convenience function <code>reservoir_domain</code> that contains defaults for permeability and porosity. We specify the permeability per-cell with varying values per layer in the vertical direction and a single porosity value for all cells that the function will expand for us. From the output, we can see that basic geometry primitives are also automatically added:</p><pre><code class="language-julia hljs">nlayer = nx*ny # Cells in each layer
K = vcat(
    repeat([0.65], nlayer),
    repeat([0.3], nlayer),
    repeat([0.5], nlayer),
    repeat([0.2], nlayer)
    )*Darcy

domain = reservoir_domain(g, permeability = K, porosity = 0.2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataDomain wrapping CartesianMesh (3D) with 5x5x4=100 cells with 17 data fields added:
  100 Cells
    :permeability =&gt; 100 Vector{Float64}
    :porosity =&gt; 100 Vector{Float64}
    :rock_thermal_conductivity =&gt; 100 Vector{Float64}
    :fluid_thermal_conductivity =&gt; 100 Vector{Float64}
    :rock_density =&gt; 100 Vector{Float64}
    :cell_centroids =&gt; 3×100 Matrix{Float64}
    :volumes =&gt; 100 Vector{Float64}
  235 Faces
    :neighbors =&gt; 2×235 Matrix{Int64}
    :areas =&gt; 235 Vector{Float64}
    :normals =&gt; 3×235 Matrix{Float64}
    :face_centroids =&gt; 3×235 Matrix{Float64}
  470 HalfFaces
    :half_face_cells =&gt; 470 Vector{Int64}
    :half_face_faces =&gt; 470 Vector{Int64}
  130 BoundaryFaces
    :boundary_areas =&gt; 130 Vector{Float64}
    :boundary_centroids =&gt; 3×130 Matrix{Float64}
    :boundary_normals =&gt; 3×130 Matrix{Float64}
    :boundary_neighbors =&gt; 130 Vector{Int64}
</code></pre><h2 id="Defining-wells"><a class="docs-heading-anchor" href="#Defining-wells">Defining wells</a><a id="Defining-wells-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-wells" title="Permalink"></a></h2><p>Now that we have a porous medium with all static properties set up, it is time to introduce some driving forces. Jutul assumes no-flow boundary conditions on all boundary faces unless otherwise specified so we can go ahead and add wells to the model.</p><h3 id="A-vertical-producer-well"><a class="docs-heading-anchor" href="#A-vertical-producer-well">A vertical producer well</a><a id="A-vertical-producer-well-1"></a><a class="docs-heading-anchor-permalink" href="#A-vertical-producer-well" title="Permalink"></a></h3><p>We will define two wells: A first well is named &quot;Producer&quot; and is a vertical well positioned at <code>(1, 1)</code>. By default, the <a href="../../man/highlevel/#JutulDarcy.setup_vertical_well"><code>setup_vertical_well</code></a> function perforates all layers in the model.</p><pre><code class="language-julia hljs">Prod = setup_vertical_well(domain, 1, 1, name = :Producer);</code></pre><h3 id="A-single-perforation-injector"><a class="docs-heading-anchor" href="#A-single-perforation-injector">A single-perforation injector</a><a id="A-single-perforation-injector-1"></a><a class="docs-heading-anchor-permalink" href="#A-single-perforation-injector" title="Permalink"></a></h3><p>We also define an injector by <a href="../../man/highlevel/#JutulDarcy.setup_well"><code>setup_well</code></a>. This function allows us to pass a vector of either cell indices or tuples of logical indices that the well trajectory will follow. We setup the injector in the upper left corner.</p><pre><code class="language-julia hljs">Inj = setup_well(domain, [(nx, ny, 1)], name = :Injector);</code></pre><h2 id="Choosing-a-fluid-system"><a class="docs-heading-anchor" href="#Choosing-a-fluid-system">Choosing a fluid system</a><a id="Choosing-a-fluid-system-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-a-fluid-system" title="Permalink"></a></h2><p>To solve multiphase flow with our little toy reservoir we need to pick a fluid system. The type of system determines what physical effects are modelled, what parameters are required and the runtime and accuracy of the resulting simulation. The choice is in practice a trade-off between accuracy, runtime and available data that should be informed by modelling objectives. In this example our goal is to understand how to set up a simple well problem and the <a href="../../man/systems/#JutulDarcy.ImmiscibleSystem"><code>ImmiscibleSystem</code></a> requires a minimal amount of input. We define liquid and gas phases and their densities at some reference conditions and instantiate the system.</p><pre><code class="language-julia hljs"># Set up a two-phase immiscible system and define a density secondary variable
phases = (LiquidPhase(), VaporPhase())
rhoLS = 1000.0
rhoGS = 100.0
rhoS = [rhoLS, rhoGS] .* kg/meter^3
sys = ImmiscibleSystem(phases, reference_densities = rhoS)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ImmiscibleSystem with LiquidPhase, VaporPhase</code></pre><h3 id="Creating-the-model"><a class="docs-heading-anchor" href="#Creating-the-model">Creating the model</a><a id="Creating-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-model" title="Permalink"></a></h3><p>The same fluid system can be used for both flow inside the wells and the reservoir. JutulDarcy treats wells as first-class citizens and models flow inside the well bore using the same fluid description as the reservoir, with modified equations to account for the non-Darcy velocities. We call the utility function that sets up all of this for us:</p><pre><code class="language-julia hljs">model, parameters = setup_reservoir_model(domain, sys, wells = [Inj, Prod])
model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MultiModel with 4 models and 6 cross-terms. 221 equations and 221 degrees of freedom.

  models:
    1) Reservoir (200x200)
       ImmiscibleSystem with LiquidPhase, VaporPhase
       ∈ MinimalTPFATopology (100 cells, 235 faces)
    2) Injector (5x5)
       ImmiscibleSystem with LiquidPhase, VaporPhase
       ∈ MultiSegmentWell [Injector] (2 nodes, 1 segments, 1 perforations)
    3) Producer (14x14)
       ImmiscibleSystem with LiquidPhase, VaporPhase
       ∈ MultiSegmentWell [Producer] (5 nodes, 4 segments, 4 perforations)
    4) Facility (2x2)
       JutulDarcy.PredictionMode()
       ∈ WellGroup([:Injector, :Producer], true)

  cross_terms:
    1) Injector &lt;-&gt; Reservoir (Eq: mass_conservation)
       JutulDarcy.ReservoirFromWellFlowCT
    2) Producer &lt;-&gt; Reservoir (Eq: mass_conservation)
       JutulDarcy.ReservoirFromWellFlowCT
    3) Injector  -&gt; Facility (Eq: control_equation)
       JutulDarcy.FacilityFromWellFlowCT
    4) Facility  -&gt; Injector (Eq: mass_conservation)
       JutulDarcy.WellFromFacilityFlowCT
    5) Producer  -&gt; Facility (Eq: control_equation)
       JutulDarcy.FacilityFromWellFlowCT
    6) Facility  -&gt; Producer (Eq: mass_conservation)
       JutulDarcy.WellFromFacilityFlowCT

Model storage will be optimized for compilation performance.
</code></pre><p>The model is an instance of the <a href="../../ref/jutul/#Jutul.MultiModel"><code>MultiModel</code></a> from <code>Jutul</code> where a submodel is defined for the reservoir, each of the wells and the facility that controls both wells. In addition we can see the cross-terms that couple these wells together. If we want to see more details on how either of these are set up, we can display for example the reservoir model.</p><pre><code class="language-julia hljs">reservoir = model[:Reservoir]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SimulationModel:
  domain:
    DiscretizedDomain with MinimalTPFATopology (100 cells, 235 faces) and discretizations for mass_flow, heat_flow

  system:
    ImmiscibleSystem with LiquidPhase, VaporPhase

  context:
    DefaultContext(BlockMajorLayout(false), 1000, 1)

  formulation:
    FullyImplicitFormulation()

  data_domain:
    DataDomain wrapping CartesianMesh (3D) with 5x5x4=100 cells with 17 data fields added:
  100 Cells
    :permeability =&gt; 100 Vector{Float64}
    :porosity =&gt; 100 Vector{Float64}
    :rock_thermal_conductivity =&gt; 100 Vector{Float64}
    :fluid_thermal_conductivity =&gt; 100 Vector{Float64}
    :rock_density =&gt; 100 Vector{Float64}
    :cell_centroids =&gt; 3×100 Matrix{Float64}
    :volumes =&gt; 100 Vector{Float64}
  235 Faces
    :neighbors =&gt; 2×235 Matrix{Int64}
    :areas =&gt; 235 Vector{Float64}
    :normals =&gt; 3×235 Matrix{Float64}
    :face_centroids =&gt; 3×235 Matrix{Float64}
  470 HalfFaces
    :half_face_cells =&gt; 470 Vector{Int64}
    :half_face_faces =&gt; 470 Vector{Int64}
  130 BoundaryFaces
    :boundary_areas =&gt; 130 Vector{Float64}
    :boundary_centroids =&gt; 3×130 Matrix{Float64}
    :boundary_normals =&gt; 3×130 Matrix{Float64}
    :boundary_neighbors =&gt; 130 Vector{Int64}

  primary_variables:
   1) Pressure    ∈ 100 Cells: 1 dof each
   2) Saturations ∈ 100 Cells: 1 dof, 2 values each

  secondary_variables:
   1) PhaseMassDensities     ∈ 100 Cells: 2 values each
      -&gt; ConstantCompressibilityDensities as evaluator
   2) TotalMasses            ∈ 100 Cells: 2 values each
      -&gt; TotalMasses as evaluator
   3) RelativePermeabilities ∈ 100 Cells: 2 values each
      -&gt; BrooksCoreyRelativePermeabilities as evaluator
   4) PhaseMobilities        ∈ 100 Cells: 2 values each
      -&gt; JutulDarcy.PhaseMobilities as evaluator
   5) PhaseMassMobilities    ∈ 100 Cells: 2 values each
      -&gt; JutulDarcy.PhaseMassMobilities as evaluator

  parameters:
   1) Transmissibilities        ∈ 235 Faces: Scalar
   2) TwoPointGravityDifference ∈ 235 Faces: Scalar
   3) PhaseViscosities          ∈ 100 Cells: 2 values each
   4) FluidVolume               ∈ 100 Cells: Scalar

  equations:
   1) mass_conservation ∈ 100 Cells: 2 values each
      -&gt; ConservationLaw{:TotalMasses, TwoPointPotentialFlowHardCoded{Vector{Int64}, Vector{@NamedTuple{face::Int64, face_sign::Int64, other::Int64, self::Int64}}}, Jutul.DefaultFlux, 2}

  output_variables:
    Pressure, Saturations, TotalMasses

  extra:
    OrderedCollections.OrderedDict{Symbol, Any}()

</code></pre><p>We can see that the model contains primary variables, secondary variables (sometimes referred to as properties) and static parameters in addition to the system we already set up. These can be replaced or modified to alter the behavior of the system.</p><h3 id="Replace-the-density-function-with-our-custom-version"><a class="docs-heading-anchor" href="#Replace-the-density-function-with-our-custom-version">Replace the density function with our custom version</a><a id="Replace-the-density-function-with-our-custom-version-1"></a><a class="docs-heading-anchor-permalink" href="#Replace-the-density-function-with-our-custom-version" title="Permalink"></a></h3><p>Let us change the definition of phase mass densities for our model. We&#39;d like to model our liquid phase as weakly compressible and the vapor phase with more significant compressibility. A common approach is to define densities <span>$\rho_\alpha^s$</span> at some reference pressure <span>$p_r$</span> and use a phase compressibility <span>$c_\alpha$</span> to extrapolate around that known value.</p><p><span>$\rho_\alpha (p) = \rho_\alpha^s \exp((p - p_r)c_\alpha)$</span></p><p>This is already implement in Jutul and we simply need to instantiate the variable definition:</p><pre><code class="language-julia hljs">c = [1e-6/bar, 1e-4/bar]
ρ = ConstantCompressibilityDensities(p_ref = 1*bar, density_ref = rhoS, compressibility = c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstantCompressibilityDensities (ref_dens=[1000.0, 100.0] kg/m^3, ref_p=[1.0, 1.0] bar)</code></pre><p>Before replacing it in the model. This change will propagate to all submodels that have a definition given for PhaseMassDensities, including the wells. The facility, which does not know about densities, will ignore it.</p><pre><code class="language-julia hljs">replace_variables!(model, PhaseMassDensities = ρ);</code></pre><p>This concludes the setup of the model.</p><h2 id="Set-up-initial-state"><a class="docs-heading-anchor" href="#Set-up-initial-state">Set up initial state</a><a id="Set-up-initial-state-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-initial-state" title="Permalink"></a></h2><p>The model is time-dependent and requires initial conditions. For the immiscible model it is sufficient to specify the reference phase pressure and the saturations for both phases, summed up to one. These can be specified per cell or one for the entire grid. Specifying a single pressure for the entire model is not very realistic, but should be fine for our simple example. The initial conditions will equilibrate themselves from gravity fairly quickly.</p><pre><code class="language-julia hljs">state0 = setup_reservoir_state(model, Pressure = 150*bar, Saturations = [1.0, 0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Any, Any} with 4 entries:
  :Producer  =&gt; Dict{Symbol, Any}(:TotalMassFlux=&gt;[0.0, 0.0, 0.0, 0.0], :PhaseM…
  :Injector  =&gt; Dict{Symbol, Any}(:TotalMassFlux=&gt;[0.0], :PhaseMassDensities=&gt;[…
  :Reservoir =&gt; Dict{Symbol, Any}(:PhaseMassMobilities=&gt;[0.0 0.0 … 0.0 0.0; 0.0…
  :Facility  =&gt; Dict{Symbol, Any}(:TotalSurfaceMassRate=&gt;[0.0, 0.0], :WellGroup…</code></pre><h2 id="Set-up-report-time-steps-and-injection-rate"><a class="docs-heading-anchor" href="#Set-up-report-time-steps-and-injection-rate">Set up report time steps and injection rate</a><a id="Set-up-report-time-steps-and-injection-rate-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-report-time-steps-and-injection-rate" title="Permalink"></a></h2><p>We create a set of time-steps. These are report steps where the solution will be reported, but the simulator itself will do internal subdivision of time steps if these values are too coarse for the solvers. We also define an injection rate of a full pore-volume (at reference conditions) of gas.</p><pre><code class="language-julia hljs">dt = repeat([30.0]*day, 12*5)
pv = pore_volume(model, parameters)
inj_rate = sum(pv)/sum(dt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.19290123456790123</code></pre><h2 id="Set-up-well-controls"><a class="docs-heading-anchor" href="#Set-up-well-controls">Set up well controls</a><a id="Set-up-well-controls-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-well-controls" title="Permalink"></a></h2><p>We then set up a total rate target (positive value for injection) together with a corresponding injection control that specifies the mass fractions of the two components/phases for pure gas injection, with surface density given by the known gas density. The producer operates at a fixed bottom hole pressure. These are given as a <code>Dict</code> with keys that correspond to the well names.</p><pre><code class="language-julia hljs">rate_target = TotalRateTarget(inj_rate)
I_ctrl = InjectorControl(rate_target, [0.0, 1.0], density = rhoGS)
bhp_target = BottomHolePressureTarget(50*bar)
P_ctrl = ProducerControl(bhp_target)
controls = Dict()
controls[:Injector] = I_ctrl
controls[:Producer] = P_ctrl
# Set up the forces</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProducerControl{BottomHolePressureTarget{Float64}, Float64}(BottomHolePressureTarget with value 50.0 [bar], 1.0)</code></pre><p>Set up forces for the whole model. For this example, all other forces than the well controls are defaulted (amounting to no-flow for the reservoir). Jutul supports either a single set of forces for the entire simulation, or a vector of equal length to <code>dt</code> with varying forces. Reasonable operational limits for wells are also set up by default.</p><pre><code class="language-julia hljs">forces = setup_reservoir_forces(model, control = controls)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Any} with 4 entries:
  :Producer  =&gt; (mask = nothing,)
  :Injector  =&gt; (mask = nothing,)
  :Reservoir =&gt; (sources = nothing, bc = nothing)
  :Facility  =&gt; (control = Dict{Any, Any}(:Producer=&gt;ProducerControl{BottomHole…</code></pre><h2 id="Simulate-the-model"><a class="docs-heading-anchor" href="#Simulate-the-model">Simulate the model</a><a id="Simulate-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-the-model" title="Permalink"></a></h2><p>We are finally ready to simulate the model for the given initial state <code>state0</code>, report steps <code>dt</code>, <code>parameters</code> and forces. As the model is small, barring any compilation time, this should run in about 300 ms.</p><pre><code class="language-julia hljs">result = simulate_reservoir(state0, model, dt, parameters = parameters, forces = forces)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReservoirSimResult with 60 entries:

  wells (2 present):
    :Producer
    :Injector
    Results per well:
       :Surface total rate =&gt; Vector{Float64} of size (60,)
       :Surface oil rate =&gt; Vector{Float64} of size (60,)
       :Bottom hole pressure =&gt; Vector{Float64} of size (60,)
       :Surface gas rate =&gt; Vector{Float64} of size (60,)
       :Surface liquid rate (water + oil) =&gt; Vector{Float64} of size (60,)
       :Total surface mass rate =&gt; Vector{Float64} of size (60,)

  states (Vector with 60 entries, reservoir variables for each state)
    :Saturations =&gt; Matrix{Float64} of size (2, 100)
    :Pressure =&gt; Vector{Float64} of size (100,)
    :TotalMasses =&gt; Matrix{Float64} of size (2, 100)

  time (report time for each state)
     Vector{Float64} of length 60

  result (extended states, reports)
     SimResult with 60 entries

  extra
     Dict{Any, Any} with with no data.

  Completed at Feb. 07 2024 17:02 after 201 milliseconds, 726 microseconds, 1000 nanoseconds.</code></pre><h3 id="Unpacking-the-result"><a class="docs-heading-anchor" href="#Unpacking-the-result">Unpacking the result</a><a id="Unpacking-the-result-1"></a><a class="docs-heading-anchor-permalink" href="#Unpacking-the-result" title="Permalink"></a></h3><p>The result contains a lot of data. This can be unpacked to get the most typical desired outputs: Well responses, reservoir states and the time they correspond to.</p><pre><code class="language-julia hljs">wd, states, t = result</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReservoirSimResult with 60 entries:

  wells (2 present):
    :Producer
    :Injector
    Results per well:
       :Surface total rate =&gt; Vector{Float64} of size (60,)
       :Surface oil rate =&gt; Vector{Float64} of size (60,)
       :Bottom hole pressure =&gt; Vector{Float64} of size (60,)
       :Surface gas rate =&gt; Vector{Float64} of size (60,)
       :Surface liquid rate (water + oil) =&gt; Vector{Float64} of size (60,)
       :Total surface mass rate =&gt; Vector{Float64} of size (60,)

  states (Vector with 60 entries, reservoir variables for each state)
    :Saturations =&gt; Matrix{Float64} of size (2, 100)
    :Pressure =&gt; Vector{Float64} of size (100,)
    :TotalMasses =&gt; Matrix{Float64} of size (2, 100)

  time (report time for each state)
     Vector{Float64} of length 60

  result (extended states, reports)
     SimResult with 60 entries

  extra
     Dict{Any, Any} with with no data.

  Completed at Feb. 07 2024 17:02 after 201 milliseconds, 726 microseconds, 1000 nanoseconds.</code></pre><p>We could in fact equally well have written <code>wd, states, t = simulate_reservoir(...)</code> to arrive at the same result.</p><h2 id="Plot-the-producer-responses"><a class="docs-heading-anchor" href="#Plot-the-producer-responses">Plot the producer responses</a><a id="Plot-the-producer-responses-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-the-producer-responses" title="Permalink"></a></h2><p>We load a plotting package to plot the wells.</p><pre><code class="language-julia hljs">using CairoMakie</code></pre><h2 id="Plot-the-surface-rates-at-the-producer"><a class="docs-heading-anchor" href="#Plot-the-surface-rates-at-the-producer">Plot the surface rates at the producer</a><a id="Plot-the-surface-rates-at-the-producer-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-the-surface-rates-at-the-producer" title="Permalink"></a></h2><p>We observe that the total rate does not vary much, but the composition changes from liquid to gas as the front propagate through the domain and hits the producer well.</p><pre><code class="language-julia hljs">qg = wd[:Producer][Symbol(&quot;Surface gas rate&quot;)]
qt = wd[:Producer][Symbol(&quot;Surface total rate&quot;)]
ql = qt - qg
x = t/day
fig = Figure()
ax = Axis(fig[1, 1], xlabel = &quot;Time (days)&quot;,
                     ylabel = &quot;Rate (m³/day)&quot;,
                     title = &quot;Well production rates&quot;)
lines!(ax, x, abs.(qg).*day, label = &quot;Gas&quot;)
lines!(ax, x, abs.(ql).*day, label = &quot;Liquid&quot;)
lines!(ax, x, abs.(qt).*day, label = &quot;Total&quot;)
axislegend(position = :rb)
fig</code></pre><img src="928bfdc1.png" alt="Example block output"/><h2 id="Plot-bottom-hole-pressure-of-the-injector"><a class="docs-heading-anchor" href="#Plot-bottom-hole-pressure-of-the-injector">Plot bottom hole pressure of the injector</a><a id="Plot-bottom-hole-pressure-of-the-injector-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-bottom-hole-pressure-of-the-injector" title="Permalink"></a></h2><p>The pressure builds during injection, until the gas breaks through to the other well.</p><pre><code class="language-julia hljs">bh = wd[:Injector][Symbol(&quot;Bottom hole pressure&quot;)]
fig = Figure()
ax = Axis(fig[1, 1], xlabel = &quot;Time (days)&quot;,
                     ylabel = &quot;Bottom hole pressure (bar)&quot;,
                     title = &quot;Injector bottom hole pressure&quot;)
lines!(ax, x, bh./bar)
fig</code></pre><img src="39b70325.png" alt="Example block output"/><h2 id="Example-on-GitHub"><a class="docs-heading-anchor" href="#Example-on-GitHub">Example on GitHub</a><a id="Example-on-GitHub-1"></a><a class="docs-heading-anchor-permalink" href="#Example-on-GitHub" title="Permalink"></a></h2><p>If you would like to run this example yourself, it can be downloaded from <a href="https://github.com/sintefmath/JutulDarcy.jl/blob/main/examples/wells_intro.jl">the JutulDarcy.jl GitHub repository</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../two_phase_unstable_gravity/">« Gravity circulation with CPR preconditioner</a><a class="docs-footer-nextpage" href="../five_spot_ensemble/">Quarter-five-spot with variation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 7 February 2024 17:13">Wednesday 7 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
