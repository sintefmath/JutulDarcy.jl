import{_ as n,c as p,j as i,a as t,G as l,a5 as a,B as r,o}from"./chunks/framework.BgSDnNIf.js";const ge=JSON.parse('{"title":"Documentation from Jutul.jl","description":"","frontmatter":{},"headers":[],"relativePath":"ref/jutul.md","filePath":"ref/jutul.md","lastUpdated":null}'),u={name:"ref/jutul.md"},d={class:"jldocstring custom-block",open:""},h={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},J={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},z={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},U={class:"jldocstring custom-block",open:""},W={class:"jldocstring custom-block",open:""},H={class:"jldocstring custom-block",open:""},K={class:"jldocstring custom-block",open:""},Y={class:"jldocstring custom-block",open:""},$={class:"jldocstring custom-block",open:""},Z={class:"jldocstring custom-block",open:""},X={class:"jldocstring custom-block",open:""},Q={class:"jldocstring custom-block",open:""},ss={class:"jldocstring custom-block",open:""},is={class:"jldocstring custom-block",open:""},ts={class:"jldocstring custom-block",open:""},es={class:"jldocstring custom-block",open:""},ls={class:"jldocstring custom-block",open:""},as={class:"jldocstring custom-block",open:""},ns={class:"jldocstring custom-block",open:""},ps={class:"jldocstring custom-block",open:""},rs={class:"jldocstring custom-block",open:""},os={class:"jldocstring custom-block",open:""},us={class:"jldocstring custom-block",open:""},ds={class:"jldocstring custom-block",open:""},hs={class:"jldocstring custom-block",open:""},ks={class:"jldocstring custom-block",open:""},gs={class:"jldocstring custom-block",open:""},ys={class:"jldocstring custom-block",open:""},cs={class:"jldocstring custom-block",open:""},bs={class:"jldocstring custom-block",open:""},ms={class:"jldocstring custom-block",open:""},Es={class:"jldocstring custom-block",open:""},fs={class:"jldocstring custom-block",open:""},js={class:"jldocstring custom-block",open:""},vs={class:"jldocstring custom-block",open:""},Fs={class:"jldocstring custom-block",open:""},Cs={class:"jldocstring custom-block",open:""},Js={class:"jldocstring custom-block",open:""},As={class:"jldocstring custom-block",open:""},Ts={class:"jldocstring custom-block",open:""},xs={class:"jldocstring custom-block",open:""},Ds={class:"jldocstring custom-block",open:""},Ms={class:"jldocstring custom-block",open:""},_s={class:"jldocstring custom-block",open:""},Ls={class:"jldocstring custom-block",open:""},Bs={class:"jldocstring custom-block",open:""},ws={class:"jldocstring custom-block",open:""},Ss={class:"jldocstring custom-block",open:""},Os={class:"jldocstring custom-block",open:""},Vs={class:"jldocstring custom-block",open:""},qs={class:"jldocstring custom-block",open:""},zs={class:"jldocstring custom-block",open:""},Ps={class:"jldocstring custom-block",open:""},Gs={class:"jldocstring custom-block",open:""},Ns={class:"jldocstring custom-block",open:""},Rs={class:"jldocstring custom-block",open:""},Is={class:"jldocstring custom-block",open:""},Us={class:"jldocstring custom-block",open:""},Ws={class:"jldocstring custom-block",open:""},Hs={class:"jldocstring custom-block",open:""},Ks={class:"jldocstring custom-block",open:""},Ys={class:"jldocstring custom-block",open:""},$s={class:"jldocstring custom-block",open:""},Zs={class:"jldocstring custom-block",open:""},Xs={class:"jldocstring custom-block",open:""},Qs={class:"jldocstring custom-block",open:""},si={class:"jldocstring custom-block",open:""},ii={class:"jldocstring custom-block",open:""},ti={class:"jldocstring custom-block",open:""},ei={class:"jldocstring custom-block",open:""},li={class:"jldocstring custom-block",open:""},ai={class:"jldocstring custom-block",open:""},ni={class:"jldocstring custom-block",open:""},pi={class:"jldocstring custom-block",open:""},ri={class:"jldocstring custom-block",open:""},oi={class:"jldocstring custom-block",open:""},ui={class:"jldocstring custom-block",open:""},di={class:"jldocstring custom-block",open:""},hi={class:"jldocstring custom-block",open:""},ki={class:"jldocstring custom-block",open:""},gi={class:"jldocstring custom-block",open:""},yi={class:"jldocstring custom-block",open:""},ci={class:"jldocstring custom-block",open:""},bi={class:"jldocstring custom-block",open:""},mi={class:"jldocstring custom-block",open:""},Ei={class:"jldocstring custom-block",open:""},fi={class:"jldocstring custom-block",open:""},ji={class:"jldocstring custom-block",open:""},vi={class:"jldocstring custom-block",open:""},Fi={class:"jldocstring custom-block",open:""},Ci={class:"jldocstring custom-block",open:""},Ji={class:"jldocstring custom-block",open:""},Ai={class:"jldocstring custom-block",open:""},Ti={class:"jldocstring custom-block",open:""},xi={class:"jldocstring custom-block",open:""},Di={class:"jldocstring custom-block",open:""},Mi={class:"jldocstring custom-block",open:""},_i={class:"jldocstring custom-block",open:""},Li={class:"jldocstring custom-block",open:""},Bi={class:"jldocstring custom-block",open:""},wi={class:"jldocstring custom-block",open:""},Si={class:"jldocstring custom-block",open:""},Oi={class:"jldocstring custom-block",open:""},Vi={class:"jldocstring custom-block",open:""},qi={class:"jldocstring custom-block",open:""},zi={class:"jldocstring custom-block",open:""},Pi={class:"jldocstring custom-block",open:""},Gi={class:"jldocstring custom-block",open:""},Ni={class:"jldocstring custom-block",open:""},Ri={class:"jldocstring custom-block",open:""},Ii={class:"jldocstring custom-block",open:""},Ui={class:"jldocstring custom-block",open:""},Wi={class:"jldocstring custom-block",open:""},Hi={class:"jldocstring custom-block",open:""},Ki={class:"jldocstring custom-block",open:""},Yi={class:"jldocstring custom-block",open:""},$i={class:"jldocstring custom-block",open:""},Zi={class:"jldocstring custom-block",open:""},Xi={class:"jldocstring custom-block",open:""},Qi={class:"jldocstring custom-block",open:""},st={class:"jldocstring custom-block",open:""},it={class:"jldocstring custom-block",open:""},tt={class:"jldocstring custom-block",open:""},et={class:"jldocstring custom-block",open:""},lt={class:"jldocstring custom-block",open:""},at={class:"jldocstring custom-block",open:""},nt={class:"jldocstring custom-block",open:""},pt={class:"jldocstring custom-block",open:""},rt={class:"jldocstring custom-block",open:""},ot={class:"jldocstring custom-block",open:""},ut={class:"jldocstring custom-block",open:""},dt={class:"jldocstring custom-block",open:""},ht={class:"jldocstring custom-block",open:""},kt={class:"jldocstring custom-block",open:""},gt={class:"jldocstring custom-block",open:""},yt={class:"jldocstring custom-block",open:""},ct={class:"jldocstring custom-block",open:""},bt={class:"jldocstring custom-block",open:""},mt={class:"jldocstring custom-block",open:""},Et={class:"jldocstring custom-block",open:""},ft={class:"jldocstring custom-block",open:""},jt={class:"jldocstring custom-block",open:""},vt={class:"jldocstring custom-block",open:""},Ft={class:"jldocstring custom-block",open:""},Ct={class:"jldocstring custom-block",open:""},Jt={class:"jldocstring custom-block",open:""},At={class:"jldocstring custom-block",open:""},Tt={class:"jldocstring custom-block",open:""},xt={class:"jldocstring custom-block",open:""},Dt={class:"jldocstring custom-block",open:""},Mt={class:"jldocstring custom-block",open:""},_t={class:"jldocstring custom-block",open:""},Lt={class:"jldocstring custom-block",open:""},Bt={class:"jldocstring custom-block",open:""},wt={class:"jldocstring custom-block",open:""},St={class:"jldocstring custom-block",open:""},Ot={class:"jldocstring custom-block",open:""},Vt={class:"jldocstring custom-block",open:""},qt={class:"jldocstring custom-block",open:""},zt={class:"jldocstring custom-block",open:""},Pt={class:"jldocstring custom-block",open:""},Gt={class:"jldocstring custom-block",open:""},Nt={class:"jldocstring custom-block",open:""},Rt={class:"jldocstring custom-block",open:""},It={class:"jldocstring custom-block",open:""},Ut={class:"jldocstring custom-block",open:""},Wt={class:"jldocstring custom-block",open:""},Ht={class:"jldocstring custom-block",open:""},Kt={class:"jldocstring custom-block",open:""},Yt={class:"jldocstring custom-block",open:""},$t={class:"jldocstring custom-block",open:""},Zt={class:"jldocstring custom-block",open:""},Xt={class:"jldocstring custom-block",open:""},Qt={class:"jldocstring custom-block",open:""},se={class:"jldocstring custom-block",open:""},ie={class:"jldocstring custom-block",open:""},te={class:"jldocstring custom-block",open:""},ee={class:"jldocstring custom-block",open:""},le={class:"jldocstring custom-block",open:""},ae={class:"jldocstring custom-block",open:""},ne={class:"jldocstring custom-block",open:""};function pe(re,s,oe,ue,de,he){const e=r("Badge");return o(),p("div",null,[s[734]||(s[734]=i("h1",{id:"Documentation-from-Jutul.jl",tabindex:"-1"},[t("Documentation from Jutul.jl "),i("a",{class:"header-anchor",href:"#Documentation-from-Jutul.jl","aria-label":'Permalink to "Documentation from Jutul.jl {#Documentation-from-Jutul.jl}"'},"​")],-1)),s[735]||(s[735]=i("p",null,"JutulDarcy.jl builds upon Jutul.jl. You can use JutulDarcy.jl without knowing the inner workings of Jutul.jl, but if you want to dive under the hood these docstrings may be helpful.",-1)),i("details",d,[i("summary",null,[s[0]||(s[0]=i("a",{id:"Jutul.AMGPreconditioner",href:"#Jutul.AMGPreconditioner"},[i("span",{class:"jlbinding"},"Jutul.AMGPreconditioner")],-1)),s[1]||(s[1]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[2]||(s[2]=i("p",null,"AMG on CPU (Julia native)",-1)),s[3]||(s[3]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/linsolve/precond/amg.jl#L2-L4",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",h,[i("summary",null,[s[4]||(s[4]=i("a",{id:"Jutul.BlockMajorLayout",href:"#Jutul.BlockMajorLayout"},[i("span",{class:"jlbinding"},"Jutul.BlockMajorLayout")],-1)),s[5]||(s[5]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[6]||(s[6]=i("p",null,[t("Same as "),i("a",{href:"/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.EntityMajorLayout"},[i("code",null,"EntityMajorLayout")]),t(", but the system is a sparse matrix where each entry is a small dense matrix.")],-1)),s[7]||(s[7]=i("p",null,"For a test system with primary variables P, S and equations E1, E2 and two cells this will give a diagonal of length 2: [(∂E1/∂p)₁ (∂E1/∂S)₁ ; (∂E2/∂p)₁ (∂E2/∂S)₁] [(∂E1/∂p)₂ (∂E1/∂S)₂ ; (∂E2/∂p)₂ (∂E2/∂S)₂]",-1)),s[8]||(s[8]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L131-L139",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",k,[i("summary",null,[s[9]||(s[9]=i("a",{id:"Jutul.BoundaryFaces",href:"#Jutul.BoundaryFaces"},[i("span",{class:"jlbinding"},"Jutul.BoundaryFaces")],-1)),s[10]||(s[10]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[11]||(s[11]=i("p",null,[t("Entity for faces on the boundary (faces that are only connected to a single "),i("a",{href:"/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.Cells"},[i("code",null,"Cells")]),t(")")],-1)),s[12]||(s[12]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L463-L465",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",g,[i("summary",null,[s[13]||(s[13]=i("a",{id:"Jutul.Cells",href:"#Jutul.Cells"},[i("span",{class:"jlbinding"},"Jutul.Cells")],-1)),s[14]||(s[14]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[15]||(s[15]=i("p",null,"Entity for Cells (closed volumes with averaged properties for a finite-volume solver)",-1)),s[16]||(s[16]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L453-L455",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",y,[i("summary",null,[s[17]||(s[17]=i("a",{id:"Jutul.CoarseMesh-Tuple{Any, Any}",href:"#Jutul.CoarseMesh-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.CoarseMesh")],-1)),s[18]||(s[18]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[19]||(s[19]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoarseMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p)</span></span></code></pre></div><p>Construct a coarse mesh from a given <code>JutulMesh</code> that can be converted to an <code>UnstructuredMesh</code> instance. The second argument <code>p</code> should be a partition Vector with one entry per cell in the original grid that assigns that cell to a coarse block. Should be one-indexed and the numbering should be sequential and contain at least one fine cell for each coarse index. This is tested by the function.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/coarse.jl#L14-L23" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",c,[i("summary",null,[s[20]||(s[20]=i("a",{id:"Jutul.CompactAutoDiffCache",href:"#Jutul.CompactAutoDiffCache"},[i("span",{class:"jlbinding"},"Jutul.CompactAutoDiffCache")],-1)),s[21]||(s[21]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[22]||(s[22]=i("p",null,"Cache that holds an AD vector/matrix together with their positions.",-1)),s[23]||(s[23]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L659-L661",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",b,[i("summary",null,[s[24]||(s[24]=i("a",{id:"Jutul.DataDomain-Tuple{JutulDomain}",href:"#Jutul.DataDomain-Tuple{JutulDomain}"},[i("span",{class:"jlbinding"},"Jutul.DataDomain")],-1)),s[25]||(s[25]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[26]||(s[26]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; property1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1, property2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A wrapper around a domain that allows for storing of entity-associated data.</p><p>Example:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Grid with 6 cells and 7 interior faces</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cell_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#ok, same as:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cell_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#ok</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cell_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Faces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#not ok!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:face_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Faces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#ok!</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Can also add general arrays if last dimension == entity dimension</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cell_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#ok</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Can add general data too, but needs to be specified</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:not_on_face_or_cell</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># also ok</span></span></code></pre></div><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/domains.jl#L115-L134" target="_blank" rel="noreferrer">source</a></p>`,5))]),i("details",m,[i("summary",null,[s[27]||(s[27]=i("a",{id:"Jutul.DefaultContext",href:"#Jutul.DefaultContext"},[i("span",{class:"jlbinding"},"Jutul.DefaultContext")],-1)),s[28]||(s[28]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[29]||(s[29]=i("p",null,"Default context",-1)),s[30]||(s[30]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/contexts/default.jl#L2",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",E,[i("summary",null,[s[31]||(s[31]=i("a",{id:"Jutul.DiscretizedDomain",href:"#Jutul.DiscretizedDomain"},[i("span",{class:"jlbinding"},"Jutul.DiscretizedDomain")],-1)),s[32]||(s[32]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[33]||(s[33]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiscretizedDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain, disc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A type for a discretized domain of some other domain or mesh. May contain one or more discretizations as-needed to write equations.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/domains.jl#L40-L45" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",f,[i("summary",null,[s[34]||(s[34]=i("a",{id:"Jutul.EntityMajorLayout",href:"#Jutul.EntityMajorLayout"},[i("span",{class:"jlbinding"},"Jutul.EntityMajorLayout")],-1)),s[35]||(s[35]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[36]||(s[36]=i("p",null,"Equations are grouped by entity, listing all equations and derivatives for entity 1 before proceeding to entity 2 etc.",-1)),s[37]||(s[37]=i("p",null,"For a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E2/∂S)₁, (∂E1/∂p)₂, (∂E2/∂S)₂",-1)),s[38]||(s[38]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L115-L122",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",j,[i("summary",null,[s[39]||(s[39]=i("a",{id:"Jutul.EquationMajorLayout",href:"#Jutul.EquationMajorLayout"},[i("span",{class:"jlbinding"},"Jutul.EquationMajorLayout")],-1)),s[40]||(s[40]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[41]||(s[41]=i("p",null,"Equations are stored sequentially in rows, derivatives of same type in columns:",-1)),s[42]||(s[42]=i("p",null,"For a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E1/∂p)₂, (∂E2/∂S)₁, (∂E2/∂S)₂",-1)),s[43]||(s[43]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L102-L108",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",v,[i("summary",null,[s[44]||(s[44]=i("a",{id:"Jutul.EquationSet",href:"#Jutul.EquationSet"},[i("span",{class:"jlbinding"},"Jutul.EquationSet")],-1)),s[45]||(s[45]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[46]||(s[46]=i("p",null,"Set of a variable where equations are defined",-1)),s[47]||(s[47]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/dd.jl#L9",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",F,[i("summary",null,[s[48]||(s[48]=i("a",{id:"Jutul.FaceMap",href:"#Jutul.FaceMap"},[i("span",{class:"jlbinding"},"Jutul.FaceMap")],-1)),s[49]||(s[49]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[50]||(s[50]=i("p",null,"Struct that contains mappings for a set of faces that are made up of nodes and are part of cells.",-1)),s[51]||(s[51]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/unstructured/types.jl#L1-L4",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",C,[i("summary",null,[s[52]||(s[52]=i("a",{id:"Jutul.Faces",href:"#Jutul.Faces"},[i("span",{class:"jlbinding"},"Jutul.Faces")],-1)),s[53]||(s[53]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[54]||(s[54]=i("p",null,[t("Entity for Faces (intersection between pairs of "),i("a",{href:"/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.Cells"},[i("code",null,"Cells")]),t(")")],-1)),s[55]||(s[55]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L458-L460",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",J,[i("summary",null,[s[56]||(s[56]=i("a",{id:"Jutul.FlowDiscretization",href:"#Jutul.FlowDiscretization"},[i("span",{class:"jlbinding"},"Jutul.FlowDiscretization")],-1)),s[57]||(s[57]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[58]||(s[58]=i("p",null,"Discretization of kgradp + upwind",-1)),s[59]||(s[59]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L758",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",A,[i("summary",null,[s[60]||(s[60]=i("a",{id:"Jutul.FractionVariables",href:"#Jutul.FractionVariables"},[i("span",{class:"jlbinding"},"Jutul.FractionVariables")],-1)),s[61]||(s[61]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[62]||(s[62]=i("p",null,"Abstract type for fraction variables (vector variables that sum up to unity over each entity).",-1)),s[63]||(s[63]=i("p",null,[t("By default, these are limited to the [0, 1] range through "),i("a",{href:"/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.maximum_value-Tuple{JutulVariables}"},[i("code",null,"maximum_value")]),t(" and "),i("a",{href:"/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.minimum_value-Tuple{JutulVariables}"},[i("code",null,"minimum_value")]),t(" default implementations.")],-1)),s[64]||(s[64]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L69-L75",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",T,[i("summary",null,[s[65]||(s[65]=i("a",{id:"Jutul.GlobalSet",href:"#Jutul.GlobalSet"},[i("span",{class:"jlbinding"},"Jutul.GlobalSet")],-1)),s[66]||(s[66]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[67]||(s[67]=i("p",null,"The global set of variables",-1)),s[68]||(s[68]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/dd.jl#L3",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",x,[i("summary",null,[s[69]||(s[69]=i("a",{id:"Jutul.GroupWisePreconditioner",href:"#Jutul.GroupWisePreconditioner"},[i("span",{class:"jlbinding"},"Jutul.GroupWisePreconditioner")],-1)),s[70]||(s[70]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[71]||(s[71]=i("p",null,"Multi-model preconditioners",-1)),s[72]||(s[72]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/linsolve/precond/various.jl#L48-L50",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",D,[i("summary",null,[s[73]||(s[73]=i("a",{id:"Jutul.HalfFaces",href:"#Jutul.HalfFaces"},[i("span",{class:"jlbinding"},"Jutul.HalfFaces")],-1)),s[74]||(s[74]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[75]||(s[75]=i("p",null,[t("Entity for half-faces (face associated with a single "),i("a",{href:"/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.Cells"},[i("code",null,"Cells")]),t(")")],-1)),s[76]||(s[76]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L468-L470",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",M,[i("summary",null,[s[77]||(s[77]=i("a",{id:"Jutul.HelperSimulator-Union{Tuple{E}, Tuple{M}, Tuple{M, Any}} where {M, E}",href:"#Jutul.HelperSimulator-Union{Tuple{E}, Tuple{M}, Tuple{M, Any}} where {M, E}"},[i("span",{class:"jlbinding"},"Jutul.HelperSimulator")],-1)),s[78]||(s[78]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[79]||(s[79]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HelperSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">M</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float64; state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model), executor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">E</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Jutul</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">default_executor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {M, E}</span></span></code></pre></div><p>Construct a helper simulator that can be used to compute the residuals and/or accumulation terms for a given type T. Useful for coupling Jutul to other solvers and types of automatic differentiation.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/helper.jl#L9-L15" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",_,[i("summary",null,[s[80]||(s[80]=i("a",{id:"Jutul.ILUZeroPreconditioner",href:"#Jutul.ILUZeroPreconditioner"},[i("span",{class:"jlbinding"},"Jutul.ILUZeroPreconditioner")],-1)),s[81]||(s[81]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[82]||(s[82]=i("p",null,"ILU(0) preconditioner on CPU",-1)),s[83]||(s[83]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/linsolve/precond/ilu.jl#L2-L4",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",L,[i("summary",null,[s[84]||(s[84]=i("a",{id:"Jutul.IndirectionMap",href:"#Jutul.IndirectionMap"},[i("span",{class:"jlbinding"},"Jutul.IndirectionMap")],-1)),s[85]||(s[85]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[86]||(s[86]=a('<p>IndirectionMap(vals::Vector{V}, pos::Vector{Int}) where V</p><p>Create a indirection map that encodes a variable length dense vector.</p><p><code>pos</code> is assumed to be a Vector{Int} of length n+1 where n is the number of dense vectors that is encoded. The <code>vals</code> array holds the entries for vector i in the range <code>pos[i]:(pos[i+1]-1)</code> for fast lookup. Indexing into the indirection map with index <code>k</code> will give a view into the values for vector <code>k</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L1050-L1059" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",B,[i("summary",null,[s[87]||(s[87]=i("a",{id:"Jutul.JacobiPreconditioner",href:"#Jutul.JacobiPreconditioner"},[i("span",{class:"jlbinding"},"Jutul.JacobiPreconditioner")],-1)),s[88]||(s[88]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[89]||(s[89]=i("p",null,"Damped Jacobi preconditioner on CPU",-1)),s[90]||(s[90]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/linsolve/precond/jacobi.jl#L2-L4",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",w,[i("summary",null,[s[91]||(s[91]=i("a",{id:"Jutul.JutulAutoDiffCache",href:"#Jutul.JutulAutoDiffCache"},[i("span",{class:"jlbinding"},"Jutul.JutulAutoDiffCache")],-1)),s[92]||(s[92]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[93]||(s[93]=i("p",null,"An AutoDiffCache is a type that holds both a set of AD values and a map into some global Jacobian.",-1)),s[94]||(s[94]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L654-L657",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",S,[i("summary",null,[s[95]||(s[95]=i("a",{id:"Jutul.JutulCase",href:"#Jutul.JutulCase"},[i("span",{class:"jlbinding"},"Jutul.JutulCase")],-1)),s[96]||(s[96]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[97]||(s[97]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model); state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up a structure that holds the complete specification of a simulation case.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L836-L840" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",O,[i("summary",null,[s[98]||(s[98]=i("a",{id:"Jutul.JutulConfig",href:"#Jutul.JutulConfig"},[i("span",{class:"jlbinding"},"Jutul.JutulConfig")],-1)),s[99]||(s[99]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[100]||(s[100]=i("p",null,"JutulConfig(name = nothing)",-1)),s[101]||(s[101]=i("p",null,[t("A configuration object that acts like a "),i("code",null,"Dict{Symbol,Any}"),t(" but contains additional data to limit the valid keys and values to those added by "),i("a",{href:"/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.add_option!"},[i("code",null,"add_option!")])],-1)),s[102]||(s[102]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/types.jl#L117-L122",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",V,[i("summary",null,[s[103]||(s[103]=i("a",{id:"Jutul.JutulContext",href:"#Jutul.JutulContext"},[i("span",{class:"jlbinding"},"Jutul.JutulContext")],-1)),s[104]||(s[104]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[105]||(s[105]=i("p",null,"Abstract type for the context Jutul should execute in (matrix formats, memory allocation, etc.)",-1)),s[106]||(s[106]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L83-L85",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",q,[i("summary",null,[s[107]||(s[107]=i("a",{id:"Jutul.JutulDiscretization",href:"#Jutul.JutulDiscretization"},[i("span",{class:"jlbinding"},"Jutul.JutulDiscretization")],-1)),s[108]||(s[108]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[109]||(s[109]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> disc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Ask discretization for entry <code>i</code> when discretizing some equation on the chosen entity (e.g. <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.Cells"><code>Cells</code></a>)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L26-L31" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",z,[i("summary",null,[s[110]||(s[110]=i("a",{id:"Jutul.JutulDiscretization-2",href:"#Jutul.JutulDiscretization-2"},[i("span",{class:"jlbinding"},"Jutul.JutulDiscretization")],-1)),s[111]||(s[111]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[112]||(s[112]=i("p",null,"Abstract type for a Jutul discretization",-1)),s[113]||(s[113]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L21-L23",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",P,[i("summary",null,[s[114]||(s[114]=i("a",{id:"Jutul.JutulDomain",href:"#Jutul.JutulDomain"},[i("span",{class:"jlbinding"},"Jutul.JutulDomain")],-1)),s[115]||(s[115]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[116]||(s[116]=i("p",null,"Abstract type for domains where equations can be defined",-1)),s[117]||(s[117]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/domains.jl#L1-L3",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",G,[i("summary",null,[s[118]||(s[118]=i("a",{id:"Jutul.JutulEntity",href:"#Jutul.JutulEntity"},[i("span",{class:"jlbinding"},"Jutul.JutulEntity")],-1)),s[119]||(s[119]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[120]||(s[120]=i("p",null,[t("Super-type for all entities where "),i("a",{href:"/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.JutulVariables"},[i("code",null,"JutulVariables")]),t(" can be defined.")],-1)),s[121]||(s[121]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L448-L450",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",N,[i("summary",null,[s[122]||(s[122]=i("a",{id:"Jutul.JutulEquation",href:"#Jutul.JutulEquation"},[i("span",{class:"jlbinding"},"Jutul.JutulEquation")],-1)),s[123]||(s[123]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[124]||(s[124]=i("p",null,"Abstract type for all residual equations",-1)),s[125]||(s[125]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L229-L231",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",R,[i("summary",null,[s[126]||(s[126]=i("a",{id:"Jutul.JutulForce",href:"#Jutul.JutulForce"},[i("span",{class:"jlbinding"},"Jutul.JutulForce")],-1)),s[127]||(s[127]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[128]||(s[128]=i("p",null,"Abstract type for driving forces",-1)),s[129]||(s[129]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L78-L80",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",I,[i("summary",null,[s[130]||(s[130]=i("a",{id:"Jutul.JutulMatrixLayout",href:"#Jutul.JutulMatrixLayout"},[i("span",{class:"jlbinding"},"Jutul.JutulMatrixLayout")],-1)),s[131]||(s[131]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[132]||(s[132]=i("p",null,"Abstract type for matrix layouts. A layout determines how primary variables and equations are ordered in a sparse matrix representation. Note that this is different from the matrix format itself as it concerns the ordering itself: For example, if all equations for a single cell come in sequence, or if a single equation is given for all entities before the next equation is written.",-1)),s[133]||(s[133]=i("p",null,"Different layouts does not change the solution of the system, but different linear solvers support different layouts.",-1)),s[134]||(s[134]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L91-L100",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",U,[i("summary",null,[s[135]||(s[135]=i("a",{id:"Jutul.JutulMesh",href:"#Jutul.JutulMesh"},[i("span",{class:"jlbinding"},"Jutul.JutulMesh")],-1)),s[136]||(s[136]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[137]||(s[137]=i("p",null,"A mesh is a type of domain that has been discretized. Abstract subtype.",-1)),s[138]||(s[138]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L442-L444",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",W,[i("summary",null,[s[139]||(s[139]=i("a",{id:"Jutul.JutulSystem",href:"#Jutul.JutulSystem"},[i("span",{class:"jlbinding"},"Jutul.JutulSystem")],-1)),s[140]||(s[140]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[141]||(s[141]=i("p",null,"Abstract type for the physical system to be solved.",-1)),s[142]||(s[142]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L16-L18",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",H,[i("summary",null,[s[143]||(s[143]=i("a",{id:"Jutul.JutulVariables",href:"#Jutul.JutulVariables"},[i("span",{class:"jlbinding"},"Jutul.JutulVariables")],-1)),s[144]||(s[144]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[145]||(s[145]=a('<p>Abstract type for all variables in Jutul.</p><p>A variable is associated with a <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.JutulEntity"><code>JutulEntity</code></a> through the <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.associated_entity-Tuple{JutulEquation}"><code>associated_entity</code></a> function. A variable is local to that entity, and cannot depend on other entities. Variables are used by models to define:</p><ul><li><p>primary variables: Sometimes referred to as degrees of freedom, primary unknowns or solution variables</p></li><li><p>parameters: Static quantities that impact the solution</p></li><li><p>secondary variables: Can be computed from a combination of other primary and secondary variables and parameters.</p></li></ul><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L45-L56" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",K,[i("summary",null,[s[146]||(s[146]=i("a",{id:"Jutul.LUPreconditioner",href:"#Jutul.LUPreconditioner"},[i("span",{class:"jlbinding"},"Jutul.LUPreconditioner")],-1)),s[147]||(s[147]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[148]||(s[148]=i("p",null,"Full LU factorization as preconditioner (intended for smaller subsystems)",-1)),s[149]||(s[149]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/linsolve/precond/various.jl#L8-L10",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Y,[i("summary",null,[s[150]||(s[150]=i("a",{id:"Jutul.LUSolver",href:"#Jutul.LUSolver"},[i("span",{class:"jlbinding"},"Jutul.LUSolver")],-1)),s[151]||(s[151]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[152]||(s[152]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LUSolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; reuse_memory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, check </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, max_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Direct solver that calls <code>lu</code> directly. Direct solvers are highly accurate, but are costly in terms of memory usage and execution speed for larger systems.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/linsolve/scalar_cpu.jl#L2-L7" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",$,[i("summary",null,[s[153]||(s[153]=i("a",{id:"Jutul.MRSTWrapMesh",href:"#Jutul.MRSTWrapMesh"},[i("span",{class:"jlbinding"},"Jutul.MRSTWrapMesh")],-1)),s[154]||(s[154]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[155]||(s[155]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MRSTWrapMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G, N </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Mesh that adapts an exported MRST mesh to the Jutul interface. <code>G</code> is assumed to be read directly from file using <code>MAT.matread</code>. The raw exported grid can be found under the <code>data</code> field.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/mrst.jl#L9-L15" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Z,[i("summary",null,[s[156]||(s[156]=i("a",{id:"Jutul.MultiModel",href:"#Jutul.MultiModel"},[i("span",{class:"jlbinding"},"Jutul.MultiModel")],-1)),s[157]||(s[157]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[158]||(s[158]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MultiModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(models)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MultiModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(models, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:SomeLabel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A model variant that is made up of many named submodels, each a fully realized <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.SimulationModel-Tuple{Any, Any}"><code>SimulationModel</code></a>.</p><p><code>models</code> should be a <code>NamedTuple</code> or <code>Dict{Symbol, JutulModel}</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L941-L948" target="_blank" rel="noreferrer">source</a></p>`,4))]),i("details",X,[i("summary",null,[s[159]||(s[159]=i("a",{id:"Jutul.NoEntity",href:"#Jutul.NoEntity"},[i("span",{class:"jlbinding"},"Jutul.NoEntity")],-1)),s[160]||(s[160]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[161]||(s[161]=i("p",null,"An entity for something that isn't associated with an entity",-1)),s[162]||(s[162]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L478-L480",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Q,[i("summary",null,[s[163]||(s[163]=i("a",{id:"Jutul.Nodes",href:"#Jutul.Nodes"},[i("span",{class:"jlbinding"},"Jutul.Nodes")],-1)),s[164]||(s[164]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[165]||(s[165]=i("p",null,[t("Entity for Nodes (intersection between multiple "),i("a",{href:"/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.Faces"},[i("code",null,"Faces")]),t(")")],-1)),s[166]||(s[166]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L473-L475",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ss,[i("summary",null,[s[167]||(s[167]=i("a",{id:"Jutul.ParallelCSRContext",href:"#Jutul.ParallelCSRContext"},[i("span",{class:"jlbinding"},"Jutul.ParallelCSRContext")],-1)),s[168]||(s[168]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[169]||(s[169]=i("p",null,"A context that uses a CSR sparse matrix format together with threads. Experimental.",-1)),s[170]||(s[170]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/contexts/csr.jl#L2",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",is,[i("summary",null,[s[171]||(s[171]=i("a",{id:"Jutul.SPAI0Preconditioner",href:"#Jutul.SPAI0Preconditioner"},[i("span",{class:"jlbinding"},"Jutul.SPAI0Preconditioner")],-1)),s[172]||(s[172]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[173]||(s[173]=i("p",null,"Sparse Approximate Inverse preconditioner of lowest order – SPAI(0)",-1)),s[174]||(s[174]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/linsolve/precond/spai.jl#L1-L3",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ts,[i("summary",null,[s[175]||(s[175]=i("a",{id:"Jutul.SPU",href:"#Jutul.SPU"},[i("span",{class:"jlbinding"},"Jutul.SPU")],-1)),s[176]||(s[176]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[177]||(s[177]=i("p",null,"Single-point upwinding.",-1)),s[178]||(s[178]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/conservation/flux.jl#L31-L33",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",es,[i("summary",null,[s[179]||(s[179]=i("a",{id:"Jutul.ScalarVariable",href:"#Jutul.ScalarVariable"},[i("span",{class:"jlbinding"},"Jutul.ScalarVariable")],-1)),s[180]||(s[180]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[181]||(s[181]=i("p",null,"Abstract type for scalar variables (one entry per entity, e.g. pressure or temperature in each cell of a model)",-1)),s[182]||(s[182]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L59-L62",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ls,[i("summary",null,[s[183]||(s[183]=i("a",{id:"Jutul.SimulationModel-Tuple{Any, Any}",href:"#Jutul.SimulationModel-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.SimulationModel")],-1)),s[184]||(s[184]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[185]||(s[185]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain, system; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Instantiate a model for a given <code>system</code> discretized on the <code>domain</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L259-L263" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",as,[i("summary",null,[s[186]||(s[186]=i("a",{id:"Jutul.SimulationModel-Tuple{JutulMesh, Any}",href:"#Jutul.SimulationModel-Tuple{JutulMesh, Any}"},[i("span",{class:"jlbinding"},"Jutul.SimulationModel")],-1)),s[187]||(s[187]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[188]||(s[188]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, system; discretization </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Type that defines a simulation model - everything needed to solve the discrete equations.</p><p>The minimal setup requires a <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.JutulMesh"><code>JutulMesh</code></a> that defines topology together with a <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.JutulSystem"><code>JutulSystem</code></a> that imposes physical laws.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L486-L494" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",ns,[i("summary",null,[s[189]||(s[189]=i("a",{id:"Jutul.Simulator-Tuple{Any}",href:"#Jutul.Simulator-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.Simulator")],-1)),s[190]||(s[190]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[191]||(s[191]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Simulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up a simulator object for a <code>model</code> that can be used by <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>. To avoid manually instantiating the simulator, the non-mutating <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}"><code>simulate</code></a> interface can be used instead.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/types.jl#L19-L25" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",ps,[i("summary",null,[s[192]||(s[192]=i("a",{id:"Jutul.SparsityTracingWrapper-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}",href:"#Jutul.SparsityTracingWrapper-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"},[i("span",{class:"jlbinding"},"Jutul.SparsityTracingWrapper")],-1)),s[193]||(s[193]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[194]||(s[194]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SparsityTracingWrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{T, N}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T, N}</span></span></code></pre></div><p>Create a sparsity tracing wrapper for a numeric array. This wrapped array produces outputs that have the same value as the wrapped type, but contains a SparsityTracing seeded value with seed equal to the column index (if matrix) or linear index (if vector).</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/sparsity.jl#L22-L29" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",rs,[i("summary",null,[s[195]||(s[195]=i("a",{id:"Jutul.TPFA",href:"#Jutul.TPFA"},[i("span",{class:"jlbinding"},"Jutul.TPFA")],-1)),s[196]||(s[196]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[197]||(s[197]=i("p",null,"Two-point flux approximation.",-1)),s[198]||(s[198]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/conservation/flux.jl#L12-L14",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",os,[i("summary",null,[s[199]||(s[199]=i("a",{id:"Jutul.TwoPointFiniteVolumeGeometry",href:"#Jutul.TwoPointFiniteVolumeGeometry"},[i("span",{class:"jlbinding"},"Jutul.TwoPointFiniteVolumeGeometry")],-1)),s[200]||(s[200]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[201]||(s[201]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TwoPointFiniteVolumeGeometry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(neighbors, areas, volumes, normals, cell_centers, face_centers)</span></span></code></pre></div><p>Store two-point geometry information for a given list of <code>neighbors</code> specified as a <code>2</code> by <code>n</code> matrix where <code>n</code> is the number of faces such that face <code>i</code> connectes cells <code>N[1, i]</code> and <code>N[2, i]</code>.</p><p>The two-point finite-volume geometry contains the minimal set of geometry information required to compute standard finite-volume discretizations.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/meshes.jl#L19-L27" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",us,[i("summary",null,[s[202]||(s[202]=i("a",{id:"Jutul.UnstructuredMesh-Tuple{CartesianMesh}",href:"#Jutul.UnstructuredMesh-Tuple{CartesianMesh}"},[i("span",{class:"jlbinding"},"Jutul.UnstructuredMesh")],-1)),s[203]||(s[203]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[204]||(s[204]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnstructuredMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert <code>CartesianMesh</code> instance to unstructured grid. Note that the mesh must be 2D and 3D for a 1-to-1 conversion. 1D meshes are implicitly converted to 2D.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/unstructured/types.jl#L289-L294" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",ds,[i("summary",null,[s[205]||(s[205]=i("a",{id:"Jutul.VariableSet",href:"#Jutul.VariableSet"},[i("span",{class:"jlbinding"},"Jutul.VariableSet")],-1)),s[206]||(s[206]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[207]||(s[207]=i("p",null,"Set of a variable where variables are defined",-1)),s[208]||(s[208]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/dd.jl#L6",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",hs,[i("summary",null,[s[209]||(s[209]=i("a",{id:"Jutul.VectorVariables",href:"#Jutul.VectorVariables"},[i("span",{class:"jlbinding"},"Jutul.VectorVariables")],-1)),s[210]||(s[210]=t()),l(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[211]||(s[211]=i("p",null,"Abstract type for vector variables (more than one entry per entity, for example saturations or displacements)",-1)),s[212]||(s[212]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L64-L67",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ks,[i("summary",null,[s[213]||(s[213]=i("a",{id:"Jutul.absolute_increment_limit-Tuple{JutulVariables}",href:"#Jutul.absolute_increment_limit-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.absolute_increment_limit")],-1)),s[214]||(s[214]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[215]||(s[215]=i("p",null,"Absolute allowable change for variable during a nonlinear update.",-1)),s[216]||(s[216]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L86-L88",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",gs,[i("summary",null,[s[217]||(s[217]=i("a",{id:"Jutul.add_option!",href:"#Jutul.add_option!"},[i("span",{class:"jlbinding"},"Jutul.add_option!")],-1)),s[218]||(s[218]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[219]||(s[219]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_option!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opts</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:my_cool_option</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My option has this brief description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add an option to existing <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.JutulConfig"><code>JutulConfig</code></a> structure. Additional currently undocumented keyword arguments can be used to restrict valid types and values.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/config.jl#L3-L8" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",ys,[i("summary",null,[s[220]||(s[220]=i("a",{id:"Jutul.align_to_jacobian!-NTuple{4, Any}",href:"#Jutul.align_to_jacobian!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.align_to_jacobian!")],-1)),s[221]||(s[221]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[222]||(s[222]=i("p",null,"Update an equation so that it knows where to store its derivatives in the Jacobian representation.",-1)),s[223]||(s[223]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L423-L426",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",cs,[i("summary",null,[s[224]||(s[224]=i("a",{id:"Jutul.align_to_jacobian!-Tuple{ConservationLawTPFAStorage, ConservationLaw, Any, Any, Cells}",href:"#Jutul.align_to_jacobian!-Tuple{ConservationLawTPFAStorage, ConservationLaw, Any, Any, Cells}"},[i("span",{class:"jlbinding"},"Jutul.align_to_jacobian!")],-1)),s[225]||(s[225]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[226]||(s[226]=i("p",null,"Update positions of law's derivatives in global Jacobian",-1)),s[227]||(s[227]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/conservation/conservation.jl#L82",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",bs,[i("summary",null,[s[228]||(s[228]=i("a",{id:"Jutul.allocate_array_ad-Tuple{AbstractMatrix}",href:"#Jutul.allocate_array_ad-Tuple{AbstractMatrix}"},[i("span",{class:"jlbinding"},"Jutul.allocate_array_ad")],-1)),s[229]||(s[229]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[230]||(s[230]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert matrix to AD matrix.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L346-L349" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",ms,[i("summary",null,[s[231]||(s[231]=i("a",{id:"Jutul.allocate_array_ad-Tuple{AbstractVector}",href:"#Jutul.allocate_array_ad-Tuple{AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.allocate_array_ad")],-1)),s[232]||(s[232]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[233]||(s[233]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert vector to AD vector.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L336-L339" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Es,[i("summary",null,[s[234]||(s[234]=i("a",{id:"Jutul.allocate_array_ad-Union{Tuple{Vararg{R}}, Tuple{R}} where R<:Integer",href:"#Jutul.allocate_array_ad-Union{Tuple{Vararg{R}}, Tuple{R}} where R<:Integer"},[i("span",{class:"jlbinding"},"Jutul.allocate_array_ad")],-1)),s[235]||(s[235]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[236]||(s[236]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n[, m]; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Allocate vector or matrix as AD with optionally provided context and a specified non-zero on the diagonal.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Integer</code>: number of entries in vector, or number of rows if <code>m</code> is given.</p></li><li><p><code>m::Integer</code>: number of rows (optional)</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>npartials = 1</code>: Number of partials derivatives to allocate for each element</p></li><li><p><code>diag_pos = nothing</code>: Indices of where to put entities on the diagonal (if any)</p></li></ul><p>Other keyword arguments are passed onto <code>get_ad_entity_scalar</code>.</p><p><strong>Examples:</strong></p><p>Allocate a vector with a single partial:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element Vector{ForwardDiff</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Dual{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Float64, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Allocate a vector with two partials, and set the first to one:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, diag_pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, npartials </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element Vector{ForwardDiff</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Dual{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Float64, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up a matrix with two partials, where the first column has partials [1, 0] and the second [0, 1]:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, diag_pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], npartials </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">×</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Matrix{ForwardDiff</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Dual{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Float64, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L278-L316" target="_blank" rel="noreferrer">source</a></p>`,15))]),i("details",fs,[i("summary",null,[s[237]||(s[237]=i("a",{id:"Jutul.apply_forces!-NTuple{4, Any}",href:"#Jutul.apply_forces!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.apply_forces!")],-1)),s[238]||(s[238]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[239]||(s[239]=i("p",null,"Apply a set of forces to all equations. Equations that don't support a given force will just ignore them, thanks to the power of multiple dispatch.",-1)),s[240]||(s[240]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L850-L853",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",js,[i("summary",null,[s[241]||(s[241]=i("a",{id:"Jutul.apply_forces_to_equation!-NTuple{7, Any}",href:"#Jutul.apply_forces_to_equation!-NTuple{7, Any}"},[i("span",{class:"jlbinding"},"Jutul.apply_forces_to_equation!")],-1)),s[242]||(s[242]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[243]||(s[243]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">apply_forces_to_equation!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diag_part, storage, model, eq, eq_s, force, time)</span></span></code></pre></div><p>Update an equation with the effect of a force. The default behavior for any force we do not know about is to assume that the force does not impact this particular equation.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L570-L576" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",vs,[i("summary",null,[s[244]||(s[244]=i("a",{id:"Jutul.as_value-Tuple{AbstractArray}",href:"#Jutul.as_value-Tuple{AbstractArray}"},[i("span",{class:"jlbinding"},"Jutul.as_value")],-1)),s[245]||(s[245]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[246]||(s[246]=i("p",null,"Create a mapped array that produces only the values when indexed.",-1)),s[247]||(s[247]=i("p",null,"Only useful for AD arrays, otherwise it does nothing.",-1)),s[248]||(s[248]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L421-L425",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Fs,[i("summary",null,[s[249]||(s[249]=i("a",{id:"Jutul.associated_entity-Tuple{JutulEquation}",href:"#Jutul.associated_entity-Tuple{JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.associated_entity")],-1)),s[250]||(s[250]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[251]||(s[251]=i("p",null,"Return the domain entity the equation is associated with",-1)),s[252]||(s[252]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L255-L257",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Cs,[i("summary",null,[s[253]||(s[253]=i("a",{id:"Jutul.associated_entity-Tuple{JutulVariables}",href:"#Jutul.associated_entity-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.associated_entity")],-1)),s[254]||(s[254]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[255]||(s[255]=i("p",null,"The entity a variable is associated with, and can hold partial derivatives with respect to.",-1)),s[256]||(s[256]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L9-L11",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Js,[i("summary",null,[s[257]||(s[257]=i("a",{id:"Jutul.cell_dims-Tuple{Any, Any}",href:"#Jutul.cell_dims-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.cell_dims")],-1)),s[258]||(s[258]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[259]||(s[259]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cell_dims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, pos)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span></span></code></pre></div><p>Get physical cell dimensions of cell with index <code>pos</code> for grid <code>g</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/cart.jl#L121-L125" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",As,[i("summary",null,[s[260]||(s[260]=i("a",{id:"Jutul.cell_index-Tuple{Any, Tuple}",href:"#Jutul.cell_index-Tuple{Any, Tuple}"},[i("span",{class:"jlbinding"},"Jutul.cell_index")],-1)),s[261]||(s[261]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[262]||(s[262]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cell_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, pos)</span></span></code></pre></div><p>Get linear (scalar) index of mesh cell from provided IJK tuple <code>pos</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/cart.jl#L99-L103" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ts,[i("summary",null,[s[263]||(s[263]=i("a",{id:"Jutul.check_amgcl_availability-Tuple{}",href:"#Jutul.check_amgcl_availability-Tuple{}"},[i("span",{class:"jlbinding"},"Jutul.check_amgcl_availability")],-1)),s[264]||(s[264]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[265]||(s[265]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_amgcl_availability</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; throw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if AMGCLWrap extension is available. If <code>throw=true</code> this wil be an error, otherwise a Boolean indicating if the extension is available will be returned.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ext/amgclwrap_ext.jl#L20-L25" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",xs,[i("summary",null,[s[266]||(s[266]=i("a",{id:"Jutul.compress_timesteps",href:"#Jutul.compress_timesteps"},[i("span",{class:"jlbinding"},"Jutul.compress_timesteps")],-1)),s[267]||(s[267]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[268]||(s[268]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compress_timesteps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timesteps, forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; max_step </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Inf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compress a set of timesteps and forces to the largest possible steps that still covers the same interval and changes forces at exactly the same points in time, while being limited to a maximum size of <code>max_step</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/timesteps.jl#L201-L207" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ds,[i("summary",null,[s[269]||(s[269]=i("a",{id:"Jutul.compress_timesteps-Tuple{JutulCase}",href:"#Jutul.compress_timesteps-Tuple{JutulCase}"},[i("span",{class:"jlbinding"},"Jutul.compress_timesteps")],-1)),s[270]||(s[270]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[271]||(s[271]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compress_timesteps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(case</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; max_step </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Inf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compress time steps for a Jutul case. See <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.compress_timesteps"><code>compress_timesteps</code></a> for the general case.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/timesteps.jl#L258-L263" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ms,[i("summary",null,[s[272]||(s[272]=i("a",{id:"Jutul.compute_boundary_trans-Tuple{DataDomain, Any}",href:"#Jutul.compute_boundary_trans-Tuple{DataDomain, Any}"},[i("span",{class:"jlbinding"},"Jutul.compute_boundary_trans")],-1)),s[273]||(s[273]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[274]||(s[274]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_boundary_trans</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, perm)</span></span></code></pre></div><p>Compute the boundary half face transmissibilities for perm. The input <code>perm</code> can either be the symbol of some data defined on <code>Cells()</code>, a vector of numbers for each cell or a matrix with number of columns equal to the number of cells.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/discretization/finite-volume.jl#L230-L237" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",_s,[i("summary",null,[s[275]||(s[275]=i("a",{id:"Jutul.compute_face_trans-Tuple{DataDomain, Vararg{Any}}",href:"#Jutul.compute_face_trans-Tuple{DataDomain, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.compute_face_trans")],-1)),s[276]||(s[276]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[277]||(s[277]=i("p",null,"compute_face_trans(g::DataDomain, perm)",-1)),s[278]||(s[278]=i("p",null,[t("Compute face trans for the interior faces. The input "),i("code",null,"perm"),t(" can either be the symbol of some data defined on "),i("code",null,"Cells()"),t(", a vector of numbers for each cell or a matrix with number of columns equal to the number of cells.")],-1)),s[279]||(s[279]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/discretization/finite-volume.jl#L213-L219",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Ls,[i("summary",null,[s[280]||(s[280]=i("a",{id:"Jutul.compute_half_face_trans-Tuple{DataDomain, Any}",href:"#Jutul.compute_half_face_trans-Tuple{DataDomain, Any}"},[i("span",{class:"jlbinding"},"Jutul.compute_half_face_trans")],-1)),s[281]||(s[281]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[282]||(s[282]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_half_face_trans</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, perm)</span></span></code></pre></div><p>Compute half-face trans for the interior faces. The input <code>perm</code> can either be the symbol of some data defined on <code>Cells()</code>, a vector of numbers for each cell or a matrix with number of columns equal to the number of cells.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/discretization/finite-volume.jl#L8-L14" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Bs,[i("summary",null,[s[283]||(s[283]=i("a",{id:"Jutul.convergence_criterion-Tuple{Any, Any, JutulEquation, Any, Any}",href:"#Jutul.convergence_criterion-Tuple{Any, Any, JutulEquation, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.convergence_criterion")],-1)),s[284]||(s[284]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[285]||(s[285]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">convergence_criterion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, storage, eq, eq_s, r; dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the convergence criterion values for a given equation. Can be checked against the corresponding tolerances.</p><p><strong>Arguments</strong></p><ul><li><p><code>model</code>: model that generated the current equation.</p></li><li><p><code>storage</code>: global simulator storage.</p></li><li><p><code>eq::JutulEquation</code>: equation implementation currently being checked</p></li><li><p><code>eq_s</code>: storage for <code>eq</code> where values are contained.</p></li><li><p><code>r</code>: the local residual part corresponding to this model, as a matrix with column index equaling entity index</p></li></ul><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L581-L592" target="_blank" rel="noreferrer">source</a></p>',5))]),i("details",ws,[i("summary",null,[s[286]||(s[286]=i("a",{id:"Jutul.convert_from_si-Tuple{Any, String}",href:"#Jutul.convert_from_si-Tuple{Any, String}"},[i("span",{class:"jlbinding"},"Jutul.convert_from_si")],-1)),s[287]||(s[287]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[288]||(s[288]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">convert_from_si</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, unit_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Symbol, String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert <code>value</code> from SI representation to the unit in <code>unit_symbol</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> convert_from_si</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3600.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:hour</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get 3600 s represented as hours</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span></span></code></pre></div><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/units/interface.jl#L29-L39" target="_blank" rel="noreferrer">source</a></p>`,5))]),i("details",Ss,[i("summary",null,[s[289]||(s[289]=i("a",{id:"Jutul.convert_state_ad",href:"#Jutul.convert_state_ad"},[i("span",{class:"jlbinding"},"Jutul.convert_state_ad")],-1)),s[290]||(s[290]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[291]||(s[291]=i("p",null,"Convert a state containing variables as arrays of doubles to a state where those arrays contain the same value as Dual types. The dual type is currently taken from ForwardDiff.",-1)),s[292]||(s[292]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L217-L221",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Os,[i("summary",null,[s[293]||(s[293]=i("a",{id:"Jutul.convert_to_si-Tuple{Any, String}",href:"#Jutul.convert_to_si-Tuple{Any, String}"},[i("span",{class:"jlbinding"},"Jutul.convert_to_si")],-1)),s[294]||(s[294]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[295]||(s[295]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">convert_to_si</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, unit_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert <code>value</code> to SI representation from value in the unit given by <code>unit_symbol</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> convert_to_si</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:hour</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get 1 hour represented as seconds</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3600.0</span></span></code></pre></div><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/units/interface.jl#L1-L12" target="_blank" rel="noreferrer">source</a></p>`,5))]),i("details",Vs,[i("summary",null,[s[296]||(s[296]=i("a",{id:"Jutul.coord_offset-Tuple{Any, AbstractFloat}",href:"#Jutul.coord_offset-Tuple{Any, AbstractFloat}"},[i("span",{class:"jlbinding"},"Jutul.coord_offset")],-1)),s[297]||(s[297]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[298]||(s[298]=i("p",null,"Lower corner for one dimension, without any transforms applied",-1)),s[299]||(s[299]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/cart.jl#L93-L95",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",qs,[i("summary",null,[s[300]||(s[300]=i("a",{id:"Jutul.data_domain_to_parameters_gradient-Tuple{Any, Any}",href:"#Jutul.data_domain_to_parameters_gradient-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.data_domain_to_parameters_gradient")],-1)),s[301]||(s[301]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[302]||(s[302]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data_domain_to_parameters_gradient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, parameter_gradient; dp_dd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Make a data_domain copy that contains the gradient of some objective with respect to the fields in the data_domain, assuming that the parameters were initialized directly from the data_domain via (<code>setup_parameters</code>)[@ref].</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/vectorization.jl#L202-L208" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",zs,[i("summary",null,[s[303]||(s[303]=i("a",{id:"Jutul.declare_pattern-Tuple{Any, Any, Any, Any, Vararg{Any}}",href:"#Jutul.declare_pattern-Tuple{Any, Any, Any, Any, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.declare_pattern")],-1)),s[304]||(s[304]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[305]||(s[305]=i("p",null,"Give out source, target arrays of equal length for a given equation attached to the given model.",-1)),s[306]||(s[306]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L389-L392",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Ps,[i("summary",null,[s[307]||(s[307]=i("a",{id:"Jutul.declare_sparsity",href:"#Jutul.declare_sparsity"},[i("span",{class:"jlbinding"},"Jutul.declare_sparsity")],-1)),s[308]||(s[308]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[309]||(s[309]=i("p",null,"Give out I, J arrays of equal length for a given equation attached to the given model.",-1)),s[310]||(s[310]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L302-L305",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Gs,[i("summary",null,[s[311]||(s[311]=i("a",{id:"Jutul.degrees_of_freedom_per_entity-Tuple{Any, ScalarVariable}",href:"#Jutul.degrees_of_freedom_per_entity-Tuple{Any, ScalarVariable}"},[i("span",{class:"jlbinding"},"Jutul.degrees_of_freedom_per_entity")],-1)),s[312]||(s[312]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[313]||(s[313]=i("p",null,"Number of independent primary variables / degrees of freedom per computational entity.",-1)),s[314]||(s[314]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L73-L75",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Ns,[i("summary",null,[s[315]||(s[315]=i("a",{id:"Jutul.descalarize_primary_variable!-Tuple{Any, Any, Any, ScalarVariable, Any}",href:"#Jutul.descalarize_primary_variable!-Tuple{Any, Any, Any, ScalarVariable, Any}"},[i("span",{class:"jlbinding"},"Jutul.descalarize_primary_variable!")],-1)),s[316]||(s[316]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[317]||(s[317]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">descalarize_primary_variable!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dest_array, model, V, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Jutul.ScalarVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index)</span></span></code></pre></div><p>Descalarize a primary variable, overwriting dest_array at entity <code>index</code>. The AD status of entries in <code>dest_array</code> will be retained.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/scalarization.jl#L49-L54" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Rs,[i("summary",null,[s[318]||(s[318]=i("a",{id:"Jutul.descalarize_primary_variables!",href:"#Jutul.descalarize_primary_variables!"},[i("span",{class:"jlbinding"},"Jutul.descalarize_primary_variables!")],-1)),s[319]||(s[319]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[320]||(s[320]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">descalarize_primary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, model, V, pvars</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pairs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">primary_variables)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), ind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eachindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(V))</span></span></code></pre></div><p>Replace valeus in <code>state</code> by the scalarized values found in V.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/scalarization.jl#L130-L134" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Is,[i("summary",null,[s[321]||(s[321]=i("a",{id:"Jutul.dim-Tuple{JutulMesh}",href:"#Jutul.dim-Tuple{JutulMesh}"},[i("span",{class:"jlbinding"},"Jutul.dim")],-1)),s[322]||(s[322]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[323]||(s[323]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span></span></code></pre></div><p>Get the dimension of a mesh.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/meshes.jl#L136-L140" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Us,[i("summary",null,[s[324]||(s[324]=i("a",{id:"Jutul.expand_to_ministeps-Tuple{Any, Any}",href:"#Jutul.expand_to_ministeps-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.expand_to_ministeps")],-1)),s[325]||(s[325]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[326]||(s[326]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">substates, dt, report_index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> expand_to_ministeps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(states, reports)</span></span></code></pre></div><p>Get states and timesteps at the finest stored resolution. Output lengths depend on if <code>output_substates</code> option to simulator was enabled.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/utils.jl#L748-L753" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ws,[i("summary",null,[s[327]||(s[327]=i("a",{id:"Jutul.expand_to_ministeps-Tuple{Jutul.SimResult}",href:"#Jutul.expand_to_ministeps-Tuple{Jutul.SimResult}"},[i("span",{class:"jlbinding"},"Jutul.expand_to_ministeps")],-1)),s[328]||(s[328]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[329]||(s[329]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">substates, dt, report_index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> expand_to_ministeps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get states and timesteps at the finest stored resolution. Output lengths depend on if <code>output_substates</code> option to simulator was enabled.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/utils.jl#L737-L742" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Hs,[i("summary",null,[s[330]||(s[330]=i("a",{id:"Jutul.extra_debug_output!-NTuple{6, Any}",href:"#Jutul.extra_debug_output!-NTuple{6, Any}"},[i("span",{class:"jlbinding"},"Jutul.extra_debug_output!")],-1)),s[331]||(s[331]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[332]||(s[332]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extra_debug_output!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(report, storage, model, config, iteration, dt)</span></span></code></pre></div><p>Add extra debug output to report during a nonlinear iteration.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/simulator.jl#L747-L751" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ks,[i("summary",null,[s[333]||(s[333]=i("a",{id:"Jutul.extract_submesh-Tuple{UnstructuredMesh, Any}",href:"#Jutul.extract_submesh-Tuple{UnstructuredMesh, Any}"},[i("span",{class:"jlbinding"},"Jutul.extract_submesh")],-1)),s[334]||(s[334]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[335]||(s[335]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extract_submesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnstructuredMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cells)</span></span></code></pre></div><p>Extract a subgrid for a given mesh and a iterable of <code>cells</code> to keep.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/unstructured/utils.jl#L27-L31" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ys,[i("summary",null,[s[336]||(s[336]=i("a",{id:"Jutul.find_enclosing_cell-Union{Tuple{T}, Tuple{D}, Tuple{UnstructuredMesh{D}, StaticArraysCore.SVector{D, T}, Vararg{AbstractArray{StaticArraysCore.SVector{D, T}, 1}, 4}}, Tuple{UnstructuredMesh{D}, StaticArraysCore.SVector{D, T}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, Any}} where {D, T}",href:"#Jutul.find_enclosing_cell-Union{Tuple{T}, Tuple{D}, Tuple{UnstructuredMesh{D}, StaticArraysCore.SVector{D, T}, Vararg{AbstractArray{StaticArraysCore.SVector{D, T}, 1}, 4}}, Tuple{UnstructuredMesh{D}, StaticArraysCore.SVector{D, T}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, Any}} where {D, T}"},[i("span",{class:"jlbinding"},"Jutul.find_enclosing_cell")],-1)),s[337]||(s[337]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[338]||(s[338]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_enclosing_cell</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnstructuredMesh{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SVector{D, T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    normals</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{SVector{D, T}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    face_centroids</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{SVector{D, T}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundary_normals</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{SVector{D, T}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundary_centroids</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{SVector{D, T}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cells </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {D, T}</span></span></code></pre></div><p>Find enclosing cell of a point. This can be a bit expensive for larger meshes. Recommended to use the more high level <code>find_enclosing_cells</code> instead.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/trajectories.jl#L94-L105" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",$s,[i("summary",null,[s[339]||(s[339]=i("a",{id:"Jutul.find_enclosing_cells-Tuple{Any, Any}",href:"#Jutul.find_enclosing_cells-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.find_enclosing_cells")],-1)),s[340]||(s[340]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[341]||(s[341]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_enclosing_cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G, traj; geometry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tpfv_geometry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G), n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find the cell indices of cells in the mesh <code>G</code> that are intersected by a given trajectory <code>traj</code>. <code>traj</code> can be either a matrix with equal number of columns as dimensions in G (i.e. three columns for 3D) or a <code>Vector</code> of <code>SVector</code> instances with the same length.</p><p>The optional argument <code>geometry</code> is used to define the centroids and normals used in the calculations. You can precompute this if you need to perform many searches. The keyword argument <code>n</code> can be used to set the number of discretizations in each segment.</p><p>Examples:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 3D mesh</span></span>
<span class="line"><span>G = CartesianMesh((4, 4, 5), (100.0, 100.0, 100.0))</span></span>
<span class="line"><span>trajectory = [</span></span>
<span class="line"><span>    50.0 25.0 1;</span></span>
<span class="line"><span>    55 35.0 25;</span></span>
<span class="line"><span>    65.0 40.0 50.0;</span></span>
<span class="line"><span>    70.0 70.0 90.0</span></span>
<span class="line"><span>]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>cells = Jutul.find_enclosing_cells(G, trajectory)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Optional plotting, requires Makie:</span></span>
<span class="line"><span>fig, ax, plt = Jutul.plot_mesh_edges(G)</span></span>
<span class="line"><span>plot_mesh!(ax, G, cells = cells, alpha = 0.5, transparency = true)</span></span>
<span class="line"><span>lines!(ax, trajectory, linewidth = 10)</span></span>
<span class="line"><span>fig</span></span>
<span class="line"><span># 2D mesh</span></span>
<span class="line"><span>G = CartesianMesh((50, 50), (1.0, 2.0))</span></span>
<span class="line"><span>trajectory = [</span></span>
<span class="line"><span>    0.1 0.1;</span></span>
<span class="line"><span>    0.2 0.4;</span></span>
<span class="line"><span>    0.3 1.2</span></span>
<span class="line"><span>]</span></span>
<span class="line"><span>fig, ax, plt = Jutul.plot_mesh_edges(G)</span></span>
<span class="line"><span>cells = Jutul.find_enclosing_cells(G, trajectory)</span></span>
<span class="line"><span># Plotting, needs Makie</span></span>
<span class="line"><span>fig, ax, plt = Jutul.plot_mesh_edges(G)</span></span>
<span class="line"><span>plot_mesh!(ax, G, cells = cells, alpha = 0.5, transparency = true)</span></span>
<span class="line"><span>lines!(ax, trajectory[:, 1], trajectory[:, 2], linewidth = 3)</span></span>
<span class="line"><span>fig</span></span></code></pre></div><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/trajectories.jl#L12-L58" target="_blank" rel="noreferrer">source</a></p>`,6))]),i("details",Zs,[i("summary",null,[s[342]||(s[342]=i("a",{id:"Jutul.full_cell-Tuple{Any, Any}",href:"#Jutul.full_cell-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.full_cell")],-1)),s[343]||(s[343]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[344]||(s[344]=i("p",null,"Inner cell to local cell (full set)",-1)),s[345]||(s[345]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/trivial_map.jl#L35",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Xs,[i("summary",null,[s[346]||(s[346]=i("a",{id:"Jutul.get_1d_interpolator-Tuple{Any, Any}",href:"#Jutul.get_1d_interpolator-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_1d_interpolator")],-1)),s[347]||(s[347]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[348]||(s[348]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_1d_interpolator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xs, ys; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get a 1D interpolator <code>F(x) ≈ y</code> for a table <code>xs, ys</code> that by default does constant extrapolation</p><p><strong>Arguments</strong></p><ul><li><p><code>xs</code>: sorted list of parameter points.</p></li><li><p><code>ys</code>: list of function values with equal length to <code>xs</code></p></li><li><p><code>method=LinearInterpolant</code>: constructor for the interpolation. Defaults to <code>LinearInterpolant</code> which does simple linear interpolation.</p></li><li><p><code>cap_endpoints = true</code>: Add values so that the endpoints are capped (constant extrapolation). Otherwise, the extrapolation will match the method.</p></li><li><p><code>cap_start = cap_endpoints</code>: Fine-grained version of cap_endpoints for the start of the interval only (extrapolation for <code>x &lt; xs[1]</code>)</p></li><li><p><code>cap_end = cap_endpoints</code>:Fine-grained version of cap_endpoints for the end of the interval only (extrapolation for <code>x &gt; xs[end]</code>)</p></li></ul><p>Additional keyword arguments are passed onto the interpolator constructor.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/interpolation.jl#L96-L111" target="_blank" rel="noreferrer">source</a></p>',6))]),i("details",Qs,[i("summary",null,[s[349]||(s[349]=i("a",{id:"Jutul.get_2d_interpolator-Tuple{Any, Any, Any}",href:"#Jutul.get_2d_interpolator-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_2d_interpolator")],-1)),s[350]||(s[350]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[351]||(s[351]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_2d_interpolator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xs, ys, fs; method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BilinearInterpolant, cap_endpoints </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>For <code>xs</code> of length <code>nx</code> and <code>ys</code> of length <code>ny</code> generate a 2D interpolation for values given as a <code>nx</code> by <code>ny</code> matrix. By default <code>cap_endpoints=true</code>, and constant extrapolation is used. Fine-grined control over extrapolation can be achieved by setting the keywords arguments <code>cap_x = (cap_low_x, cap_high_x)</code> and analogously for <code>cap_y</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/interpolation.jl#L207-L215" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",si,[i("summary",null,[s[352]||(s[352]=i("a",{id:"Jutul.get_ad_entity_scalar-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real",href:"#Jutul.get_ad_entity_scalar-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real"},[i("span",{class:"jlbinding"},"Jutul.get_ad_entity_scalar")],-1)),s[353]||(s[353]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[354]||(s[354]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_ad_entity_scalar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, npartials, diag_pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword_arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get scalar with partial derivatives as AD instance.</p><p><strong>Arguments</strong></p><ul><li><p><code>v::Real</code>: Value of AD variable.</p></li><li><p><code>npartials</code>: Number of partial derivatives each AD instance holds.</p></li><li><p><code>diag_pos</code> = nothing: Position(s) of where to set 1 as the partial derivative instead of zero.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>tag = nothing</code>: Tag for AD instance. Two AD values of the different tag cannot interoperate to avoid perturbation confusion (see ForwardDiff documentation).</li></ul><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L356-L368" target="_blank" rel="noreferrer">source</a></p>',7))]),i("details",ii,[i("summary",null,[s[355]||(s[355]=i("a",{id:"Jutul.get_dependencies-Tuple{Any, Any}",href:"#Jutul.get_dependencies-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_dependencies")],-1)),s[356]||(s[356]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[357]||(s[357]=i("p",null,"Get dependencies of variable when viewed as a secondary variable. Normally autogenerated with @jutul_secondary",-1)),s[358]||(s[358]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variable_evaluation.jl#L199-L201",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ti,[i("summary",null,[s[359]||(s[359]=i("a",{id:"Jutul.get_diagonal_entries-Tuple{JutulEquation, Any}",href:"#Jutul.get_diagonal_entries-Tuple{JutulEquation, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_diagonal_entries")],-1)),s[360]||(s[360]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[361]||(s[361]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_diagonal_entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulEquation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, eq_s)</span></span></code></pre></div><p>Get the diagonal entries of a cache, i.e. the entries where entity type and index equals that of the governing equation.</p><p>Note: Be very careful about modifications to this array, as this is a view into the internal AD buffers and it is very easy to create inconsistent Jacobians.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L609-L616" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",ei,[i("summary",null,[s[362]||(s[362]=i("a",{id:"Jutul.get_entity_tag-Tuple{Any, Any}",href:"#Jutul.get_entity_tag-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_entity_tag")],-1)),s[363]||(s[363]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[364]||(s[364]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_entity_tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basetag, entity)</span></span></code></pre></div><p>Combine a base tag (which can be nothing) with a entity to get a tag that captures base tag + entity tag for use with AD initialization.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L438-L443" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",li,[i("summary",null,[s[365]||(s[365]=i("a",{id:"Jutul.get_entries-Tuple{CompactAutoDiffCache}",href:"#Jutul.get_entries-Tuple{CompactAutoDiffCache}"},[i("span",{class:"jlbinding"},"Jutul.get_entries")],-1)),s[366]||(s[366]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[367]||(s[367]=i("p",null,"Get entries of autodiff cache. Entries are AD vectors that hold values and derivatives.",-1)),s[368]||(s[368]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/compact.jl#L1-L3",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ai,[i("summary",null,[s[369]||(s[369]=i("a",{id:"Jutul.get_entries-Tuple{JutulEquation}",href:"#Jutul.get_entries-Tuple{JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.get_entries")],-1)),s[370]||(s[370]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[371]||(s[371]=i("p",null,"Get the entries of the main autodiff cache for an equation.",-1)),s[372]||(s[372]=i("p",null,"Note: This only gets the .equation field's entries.",-1)),s[373]||(s[373]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L19-L23",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ni,[i("summary",null,[s[374]||(s[374]=i("a",{id:"Jutul.get_mesh_entity_tag-Tuple{JutulMesh, Vararg{Any}}",href:"#Jutul.get_mesh_entity_tag-Tuple{JutulMesh, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.get_mesh_entity_tag")],-1)),s[375]||(s[375]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[376]||(s[376]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_mesh_entity_tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(met</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, entity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulEntity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tag_group</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tag_value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; throw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the indices tagged for <code>entity</code> in group <code>tag_group</code>, optionally for the specific <code>tag_value</code>. If <code>ismissing(tag_value)</code>, the Dict containing the tag group will be returned.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L1227-L1233" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",pi,[i("summary",null,[s[377]||(s[377]=i("a",{id:"Jutul.get_parameters-Tuple{SimulationModel}",href:"#Jutul.get_parameters-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_parameters")],-1)),s[378]||(s[378]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[379]||(s[379]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the parameter definitions (as <code>OrderedDict</code>) for a given <code>model</code>.</p><p>Parameters are defined as static values in a forward simulation that combine with the primary variables to compute secondary variables and model equations.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L42-L49" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",ri,[i("summary",null,[s[380]||(s[380]=i("a",{id:"Jutul.get_primary_variable_ordered_entities-Tuple{SimulationModel}",href:"#Jutul.get_primary_variable_ordered_entities-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_primary_variable_ordered_entities")],-1)),s[381]||(s[381]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[382]||(s[382]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_primary_variable_ordered_entities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get only the entities where primary variables are present, sorted by their order in the primary variables.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L184-L188" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",oi,[i("summary",null,[s[383]||(s[383]=i("a",{id:"Jutul.get_primary_variables-Tuple{SimulationModel}",href:"#Jutul.get_primary_variables-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_primary_variables")],-1)),s[384]||(s[384]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[385]||(s[385]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_primary_variables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the primary variable definitions (as <code>OrderedDict</code>) for a given <code>model</code>.</p><p>Primary variables are sometimes referred to as solution variables or primary unknowns. The set of primary variables completely determines the state of the system together with the <code>parameters</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L5-L13" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",ui,[i("summary",null,[s[386]||(s[386]=i("a",{id:"Jutul.get_secondary_variables-Tuple{SimulationModel}",href:"#Jutul.get_secondary_variables-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_secondary_variables")],-1)),s[387]||(s[387]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[388]||(s[388]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_secondary_variables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the secondary variable definitions (as <code>OrderedDict</code>) for a given <code>model</code>.</p><p>Secondary variables are variables that can be computed from the primary variables together with the parameters.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L18-L25" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",di,[i("summary",null,[s[389]||(s[389]=i("a",{id:"Jutul.get_sparse_arguments-Tuple{Any, Any}",href:"#Jutul.get_sparse_arguments-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_sparse_arguments")],-1)),s[390]||(s[390]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[391]||(s[391]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_sparse_arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model)</span></span></code></pre></div><p>Get the [<code>SparsePattern</code>]@ref for the Jacobian matrix of a given simulator storage and corresponding model.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L551-L555" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",hi,[i("summary",null,[s[392]||(s[392]=i("a",{id:"Jutul.get_tstr",href:"#Jutul.get_tstr"},[i("span",{class:"jlbinding"},"Jutul.get_tstr")],-1)),s[393]||(s[393]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[394]||(s[394]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_tstr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dT, lim </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get formatted time string of <code>dT</code> given in seconds, limited to <code>lim</code> number of units.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/utils.jl#L1-L5" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",ki,[i("summary",null,[s[395]||(s[395]=i("a",{id:"Jutul.get_variable-Tuple{SimulationModel, Symbol}",href:"#Jutul.get_variable-Tuple{SimulationModel, Symbol}"},[i("span",{class:"jlbinding"},"Jutul.get_variable")],-1)),s[396]||(s[396]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[397]||(s[397]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_variable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get implementation of variable or parameter with name <code>name</code> for the model.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L69-L73" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",gi,[i("summary",null,[s[398]||(s[398]=i("a",{id:"Jutul.get_variables-Tuple{SimulationModel}",href:"#Jutul.get_variables-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_variables")],-1)),s[399]||(s[399]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[400]||(s[400]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_variables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get all variable definitions (as <code>OrderedDict</code>) for a given <code>model</code>.</p><p>This is the union of <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.get_secondary_variables-Tuple{SimulationModel}"><code>get_secondary_variables</code></a> and <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.get_primary_variables-Tuple{SimulationModel}"><code>get_primary_variables</code></a>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L31-L37" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",yi,[i("summary",null,[s[401]||(s[401]=i("a",{id:"Jutul.global_cell-Tuple{Any, Any}",href:"#Jutul.global_cell-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.global_cell")],-1)),s[402]||(s[402]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[403]||(s[403]=i("p",null,"Local cell -> global cell (full set)",-1)),s[404]||(s[404]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/trivial_map.jl#L23",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ci,[i("summary",null,[s[405]||(s[405]=i("a",{id:"Jutul.global_face-Tuple{Any, Any}",href:"#Jutul.global_face-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.global_face")],-1)),s[406]||(s[406]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[407]||(s[407]=i("p",null,"Local face -> global face (full set)",-1)),s[408]||(s[408]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/trivial_map.jl#L21",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",bi,[i("summary",null,[s[409]||(s[409]=i("a",{id:"Jutul.initialize_context!-NTuple{4, Any}",href:"#Jutul.initialize_context!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.initialize_context!")],-1)),s[410]||(s[410]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[411]||(s[411]=i("p",null,"Initialize context when setting up a model",-1)),s[412]||(s[412]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/context.jl#L62-L64",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",mi,[i("summary",null,[s[413]||(s[413]=i("a",{id:"Jutul.initialize_extra_state_fields!-Tuple{Any, JutulModel}",href:"#Jutul.initialize_extra_state_fields!-Tuple{Any, JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.initialize_extra_state_fields!")],-1)),s[414]||(s[414]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[415]||(s[415]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_extra_state_fields!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add model-dependent changing variables that need to be in state, but are never AD variables themselves (for example status flags).</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L267-L272" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ei,[i("summary",null,[s[416]||(s[416]=i("a",{id:"Jutul.initialize_storage!-Tuple{Any, JutulModel}",href:"#Jutul.initialize_storage!-Tuple{Any, JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.initialize_storage!")],-1)),s[417]||(s[417]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[418]||(s[418]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_storage!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; initialize_state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialize the already allocated storage at the beginning of a simulation. Use this to e.g. set up extra stuff in state0 needed for initializing the simulation loop.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L387-L392" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",fi,[i("summary",null,[s[419]||(s[419]=i("a",{id:"Jutul.initialize_variable_value-Tuple{Any, VectorVariables, AbstractVector}",href:"#Jutul.initialize_variable_value-Tuple{Any, VectorVariables, AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.initialize_variable_value")],-1)),s[420]||(s[420]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[421]||(s[421]=i("p",null,"Initializer for the value of non-scalar primary variables",-1)),s[422]||(s[422]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L322-L324",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ji,[i("summary",null,[s[423]||(s[423]=i("a",{id:"Jutul.interior_cell-Tuple{Any, Any}",href:"#Jutul.interior_cell-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.interior_cell")],-1)),s[424]||(s[424]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[425]||(s[425]=i("p",null,"Local cell in full set -> inner cell (or zero)",-1)),s[426]||(s[426]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/trivial_map.jl#L32",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",vi,[i("summary",null,[s[427]||(s[427]=i("a",{id:"Jutul.interpolation_constant_lookup",href:"#Jutul.interpolation_constant_lookup"},[i("span",{class:"jlbinding"},"Jutul.interpolation_constant_lookup")],-1)),s[428]||(s[428]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[429]||(s[429]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">interpolation_constant_lookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X, constant_dx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate a lookup table for linear interpolation when dx is evenly spaced.</p><p>Note: Setting <code>constant_dx=true</code> can lead to incorrect interpolations if the data is not evenly spaced.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/interpolation.jl#L43-L50" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",Fi,[i("summary",null,[s[430]||(s[430]=i("a",{id:"Jutul.jutul_output_path",href:"#Jutul.jutul_output_path"},[i("span",{class:"jlbinding"},"Jutul.jutul_output_path")],-1)),s[431]||(s[431]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[432]||(s[432]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> jutul_output_path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; subfolder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;jutul&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, basedir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, create </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get path for output. The final path will be found in /basedir/&lt;subfolder/name. If <code>subfolder=missing</code>, the path will be set to /basedir/name instead. <code>name</code> will be autogenerated if not provided.</p><p>Pass the optional input <code>create = false</code> to avoid making the directory. To globally set the default output dir, set <code>ENV[&quot;JUTUL_OUTPUT_PATH&quot;]``to your desired</code>basedir``.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/utils.jl#L931-L940" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",Ci,[i("summary",null,[s[433]||(s[433]=i("a",{id:"Jutul.linear_timestep_selection",href:"#Jutul.linear_timestep_selection"},[i("span",{class:"jlbinding"},"Jutul.linear_timestep_selection")],-1)),s[434]||(s[434]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[435]||(s[435]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">linear_timestep_selection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, x0, x1, dt0, dt1)</span></span></code></pre></div><p>Produce linear estimate of timestep <code>dt</code> for some value <code>x</code> from observed observations. If the observations have the same <code>x</code> or <code>dt</code> values, a simple scaling based on the <code>x1</code> value is used.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/timesteps.jl#L179-L185" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ji,[i("summary",null,[s[436]||(s[436]=i("a",{id:"Jutul.load_balanced_endpoint-Tuple{Any, Any, Any}",href:"#Jutul.load_balanced_endpoint-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.load_balanced_endpoint")],-1)),s[437]||(s[437]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[438]||(s[438]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">load_balanced_endpoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block_index, nvals, nblocks)</span></span></code></pre></div><p>Endpoint for interval <code>block_index</code> that subdivides <code>nvals</code> into <code>nblocks</code> in a load balanced manner. This is done by adding one element to the first set of blocks whenever possible.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/partitioning.jl#L209-L215" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ai,[i("summary",null,[s[439]||(s[439]=i("a",{id:"Jutul.load_balanced_interval-Tuple{Any, Any, Any}",href:"#Jutul.load_balanced_interval-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.load_balanced_interval")],-1)),s[440]||(s[440]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[441]||(s[441]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">load_balanced_interval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b, n, m)</span></span></code></pre></div><p>Create UnitRange for block b ∈ [1, m] for interval of total length n</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/partitioning.jl#L226-L230" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ti,[i("summary",null,[s[442]||(s[442]=i("a",{id:"Jutul.local_ad-Tuple{Any, Any, Any}",href:"#Jutul.local_ad-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.local_ad")],-1)),s[443]||(s[443]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[444]||(s[444]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">local_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">I</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ad_tag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:∂T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ∂T}</span></span></code></pre></div><p>Create local_ad for state for index I of AD tag of type ad_tag</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/local_ad.jl#L157-L161" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",xi,[i("summary",null,[s[445]||(s[445]=i("a",{id:"Jutul.local_cell-Tuple{Any, Any}",href:"#Jutul.local_cell-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.local_cell")],-1)),s[446]||(s[446]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[447]||(s[447]=i("p",null,"Global cell -> local cell (full set)",-1)),s[448]||(s[448]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/trivial_map.jl#L26",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Di,[i("summary",null,[s[449]||(s[449]=i("a",{id:"Jutul.local_face-Tuple{Any, Any}",href:"#Jutul.local_face-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.local_face")],-1)),s[450]||(s[450]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[451]||(s[451]=i("p",null,"Global face -> local face (full set)",-1)),s[452]||(s[452]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/trivial_map.jl#L30",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Mi,[i("summary",null,[s[453]||(s[453]=i("a",{id:"Jutul.local_residual_view-NTuple{4, Any}",href:"#Jutul.local_residual_view-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.local_residual_view")],-1)),s[454]||(s[454]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[455]||(s[455]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">local_residual_view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r_buf, model, eq, equation_offset)</span></span></code></pre></div><p>Get a matrix view of the residual so that, independent of ordering, the column index corresponds to the entity index for the given equation <code>eq</code> starting at <code>equation_offset</code> in the global residual buffer <code>r_buf</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L750-L756" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",_i,[i("summary",null,[s[456]||(s[456]=i("a",{id:"Jutul.maximum_value-Tuple{JutulVariables}",href:"#Jutul.maximum_value-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.maximum_value")],-1)),s[457]||(s[457]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[458]||(s[458]=i("p",null,"Upper (inclusive) limit for variable.",-1)),s[459]||(s[459]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L98-L100",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Li,[i("summary",null,[s[460]||(s[460]=i("a",{id:"Jutul.merge_step_report_errors-Tuple{Any}",href:"#Jutul.merge_step_report_errors-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.merge_step_report_errors")],-1)),s[461]||(s[461]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[462]||(s[462]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">merge_step_report_errors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data; fn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max)</span></span></code></pre></div><p>Merge step reports errors of the same type using a pair wise reduction (default: max)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/utils.jl#L1001-L1005" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Bi,[i("summary",null,[s[463]||(s[463]=i("a",{id:"Jutul.minimum_value-Tuple{JutulVariables}",href:"#Jutul.minimum_value-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.minimum_value")],-1)),s[464]||(s[464]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[465]||(s[465]=i("p",null,"Lower (inclusive) limit for variable.",-1)),s[466]||(s[466]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L103-L105",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",wi,[i("summary",null,[s[467]||(s[467]=i("a",{id:"Jutul.model_accumulation!",href:"#Jutul.model_accumulation!"},[i("span",{class:"jlbinding"},"Jutul.model_accumulation!")],-1)),s[468]||(s[468]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[469]||(s[469]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">model_accumulation!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(acc, sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HelperSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    update_secondary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the accumulation term into Vector acc.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/helper.jl#L106-L114" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",Si,[i("summary",null,[s[470]||(s[470]=i("a",{id:"Jutul.model_residual!",href:"#Jutul.model_residual!"},[i("span",{class:"jlbinding"},"Jutul.model_residual!")],-1)),s[471]||(s[471]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[472]||(s[472]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">model_residual!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, sim, x, x0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    include_accumulation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Fill in the model residual into Vector r.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/helper.jl#L60-L68" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",Oi,[i("summary",null,[s[473]||(s[473]=i("a",{id:"Jutul.model_residual-Union{Tuple{T}, Tuple{HelperSimulator{<:Any, <:Any, <:Any, T}, Any, Vararg{Any}}} where T",href:"#Jutul.model_residual-Union{Tuple{T}, Tuple{HelperSimulator{<:Any, <:Any, <:Any, T}, Any, Vararg{Any}}} where T"},[i("span",{class:"jlbinding"},"Jutul.model_residual")],-1)),s[474]||(s[474]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[475]||(s[475]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">model_residual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HelperSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Out of place version of <code>model_residual!</code></p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/helper.jl#L47-L51" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Vi,[i("summary",null,[s[476]||(s[476]=i("a",{id:"Jutul.number_of_cells-Tuple{JutulMesh}",href:"#Jutul.number_of_cells-Tuple{JutulMesh}"},[i("span",{class:"jlbinding"},"Jutul.number_of_cells")],-1)),s[477]||(s[477]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[478]||(s[478]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span></span></code></pre></div><p>Get the number of cells in a mesh.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/meshes.jl#L143-L147" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",qi,[i("summary",null,[s[479]||(s[479]=i("a",{id:"Jutul.number_of_degrees_of_freedom-Tuple{JutulModel}",href:"#Jutul.number_of_degrees_of_freedom-Tuple{JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.number_of_degrees_of_freedom")],-1)),s[480]||(s[480]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[481]||(s[481]=i("p",null,"Total number of degrees of freedom for a model, over all primary variables and all entities.",-1)),s[482]||(s[482]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L14-L16",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",zi,[i("summary",null,[s[483]||(s[483]=i("a",{id:"Jutul.number_of_entities-Tuple{Any, JutulEquation}",href:"#Jutul.number_of_entities-Tuple{Any, JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[484]||(s[484]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[485]||(s[485]=i("p",null,"Get the number of entities (e.g. the number of cells) that the equation is defined on.",-1)),s[486]||(s[486]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L280-L282",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Pi,[i("summary",null,[s[487]||(s[487]=i("a",{id:"Jutul.number_of_entities-Tuple{Any, JutulVariables}",href:"#Jutul.number_of_entities-Tuple{Any, JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[488]||(s[488]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[489]||(s[489]=i("p",null,"Number of entities (e.g. Cells, Faces) a variable is defined on. By default, each primary variable exists on all cells of a discretized domain",-1)),s[490]||(s[490]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L2-L6",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Gi,[i("summary",null,[s[491]||(s[491]=i("a",{id:"Jutul.number_of_entities-Tuple{JutulAutoDiffCache}",href:"#Jutul.number_of_entities-Tuple{JutulAutoDiffCache}"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[492]||(s[492]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[493]||(s[493]=i("p",null,"Get number of entities a cache is defined on.",-1)),s[494]||(s[494]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L3-L5",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Ni,[i("summary",null,[s[495]||(s[495]=i("a",{id:"Jutul.number_of_entities-Tuple{T} where T<:(AbstractVector)",href:"#Jutul.number_of_entities-Tuple{T} where T<:(AbstractVector)"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[496]||(s[496]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[497]||(s[497]=i("p",null,"Number of entities for vector stored in state (just the number of elements)",-1)),s[498]||(s[498]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L9-L11",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Ri,[i("summary",null,[s[499]||(s[499]=i("a",{id:"Jutul.number_of_entities-Tuple{T} where T<:AbstractArray",href:"#Jutul.number_of_entities-Tuple{T} where T<:AbstractArray"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[500]||(s[500]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[501]||(s[501]=i("p",null,"Number of entities for matrix stored in state (convention is number of columns)",-1)),s[502]||(s[502]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L14-L16",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Ii,[i("summary",null,[s[503]||(s[503]=i("a",{id:"Jutul.number_of_equations-Tuple{Any, JutulEquation}",href:"#Jutul.number_of_equations-Tuple{Any, JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.number_of_equations")],-1)),s[504]||(s[504]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[505]||(s[505]=i("p",null,"Get the total number of equations on the domain of model.",-1)),s[506]||(s[506]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L287-L289",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Ui,[i("summary",null,[s[507]||(s[507]=i("a",{id:"Jutul.number_of_equations_per_entity-Tuple{JutulModel, JutulEquation}",href:"#Jutul.number_of_equations_per_entity-Tuple{JutulModel, JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.number_of_equations_per_entity")],-1)),s[508]||(s[508]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[509]||(s[509]=i("p",null,"Get the number of equations per entity. For example, mass balance of two components will have two equations per grid cell (= entity)",-1)),s[510]||(s[510]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L263-L266",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Wi,[i("summary",null,[s[511]||(s[511]=i("a",{id:"Jutul.number_of_faces-Tuple{Any}",href:"#Jutul.number_of_faces-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.number_of_faces")],-1)),s[512]||(s[512]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[513]||(s[513]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_faces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span></span></code></pre></div><p>Get the number of faces in a mesh.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/meshes.jl#L150-L154" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Hi,[i("summary",null,[s[514]||(s[514]=i("a",{id:"Jutul.number_of_partials_per_entity-Tuple{SimulationModel, JutulEntity}",href:"#Jutul.number_of_partials_per_entity-Tuple{SimulationModel, JutulEntity}"},[i("span",{class:"jlbinding"},"Jutul.number_of_partials_per_entity")],-1)),s[515]||(s[515]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[516]||(s[516]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_partials_per_entity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, entity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulEntity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the number of local partial derivatives per entity in a <code>model</code> for a given <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.JutulEntity"><code>JutulEntity</code></a>. This is the sum of <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.degrees_of_freedom_per_entity-Tuple{Any, ScalarVariable}"><code>degrees_of_freedom_per_entity</code></a> for all primary variables defined on <code>entity</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L207-L212" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ki,[i("summary",null,[s[517]||(s[517]=i("a",{id:"Jutul.number_of_values",href:"#Jutul.number_of_values"},[i("span",{class:"jlbinding"},"Jutul.number_of_values")],-1)),s[518]||(s[518]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[519]||(s[519]=i("p",null,"Total number of values for a model, for a given type of variables over all entities",-1)),s[520]||(s[520]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L34-L36",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Yi,[i("summary",null,[s[521]||(s[521]=i("a",{id:"Jutul.numerical_eltype-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T",href:"#Jutul.numerical_eltype-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"},[i("span",{class:"jlbinding"},"Jutul.numerical_eltype")],-1)),s[522]||(s[522]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[523]||(s[523]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">numerical_eltype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span></code></pre></div><p>Get the numerical eltype (i.e. the inner type of the element type that could potentially be AD)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/local_ad.jl#L105-L110" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",$i,[i("summary",null,[s[524]||(s[524]=i("a",{id:"Jutul.numerical_type-Tuple{T} where T<:Real",href:"#Jutul.numerical_type-Tuple{T} where T<:Real"},[i("span",{class:"jlbinding"},"Jutul.numerical_type")],-1)),s[525]||(s[525]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[526]||(s[526]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">numerical_type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span></code></pre></div><p>Get the numerical eltype (i.e. the inner type of the element type that could potentially be AD). This function should be overloaded if you have a custom type that wraps a numeric/potentially AD type.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/local_ad.jl#L119-L125" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Zi,[i("summary",null,[s[527]||(s[527]=i("a",{id:"Jutul.parameters_jacobian_wrt_data_domain-Tuple{Any}",href:"#Jutul.parameters_jacobian_wrt_data_domain-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.parameters_jacobian_wrt_data_domain")],-1)),s[528]||(s[528]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[529]||(s[529]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parameters_jacobian_wrt_data_domain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model; copy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the (sparse) Jacobian of parameters with respect to data_domain values (i.e. floating point values). Optionally, <code>config</code> can be passed to allow <code>vectorize_variables</code> to only include a subset of the parameters.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/vectorization.jl#L177-L183" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Xi,[i("summary",null,[s[530]||(s[530]=i("a",{id:"Jutul.partition",href:"#Jutul.partition"},[i("span",{class:"jlbinding"},"Jutul.partition")],-1)),s[531]||(s[531]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[532]||(s[532]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, num_coarse, weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); partitioner </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MetisPartitioner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), groups </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> maximum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N), group_by_weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, buffer_group </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Partition based on neighborship (with optional groups kept contigious after partitioning)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/partitioning.jl#L137-L142" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Qi,[i("summary",null,[s[533]||(s[533]=i("a",{id:"Jutul.partition_hypergraph",href:"#Jutul.partition_hypergraph"},[i("span",{class:"jlbinding"},"Jutul.partition_hypergraph")],-1)),s[534]||(s[534]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[535]||(s[535]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">partition_hypergraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, partitioner </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MetisPartitioner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); expand </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Partition a hypergraph from <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.setup_partitioner_hypergraph-Tuple{Matrix{Int64}}"><code>setup_partitioner_hypergraph</code></a> using a given partitioner. If the optional <code>expand</code> parameter is set to true the result will be expanded to the full graph (i.e. where groups are not condensed).</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/partitioning.jl#L331-L337" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",st,[i("summary",null,[s[536]||(s[536]=i("a",{id:"Jutul.physical_representation-Tuple{Any}",href:"#Jutul.physical_representation-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.physical_representation")],-1)),s[537]||(s[537]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[538]||(s[538]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">physical_representation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span></code></pre></div><p>Get the physical representation of an object. The physical representation is usually some kind of mesh or domain that represents a physical domain.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/domains.jl#L7-L12" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",it,[i("summary",null,[s[539]||(s[539]=i("a",{id:"Jutul.physical_representation-Tuple{DataDomain}",href:"#Jutul.physical_representation-Tuple{DataDomain}"},[i("span",{class:"jlbinding"},"Jutul.physical_representation")],-1)),s[540]||(s[540]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[541]||(s[541]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">physical_representation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the underlying physical representation (domain or mesh) that is wrapped.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/domains.jl#L71-L75" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",tt,[i("summary",null,[s[542]||(s[542]=i("a",{id:"Jutul.physical_representation-Tuple{DiscretizedDomain}",href:"#Jutul.physical_representation-Tuple{DiscretizedDomain}"},[i("span",{class:"jlbinding"},"Jutul.physical_representation")],-1)),s[543]||(s[543]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[544]||(s[544]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">physical_representation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiscretizedDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the underlying physical representation (domain or mesh) that was discretized.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/domains.jl#L23-L27" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",et,[i("summary",null,[s[545]||(s[545]=i("a",{id:"Jutul.physical_representation-Tuple{SimulationModel}",href:"#Jutul.physical_representation-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.physical_representation")],-1)),s[546]||(s[546]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[547]||(s[547]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">physical_representation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the underlying physical representation for the model (domain or mesh)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/core_types/core_types.jl#L319-L323" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",lt,[i("summary",null,[s[548]||(s[548]=i("a",{id:"Jutul.pick_next_timestep-Tuple{IterationTimestepSelector, Vararg{Any, 9}}",href:"#Jutul.pick_next_timestep-Tuple{IterationTimestepSelector, Vararg{Any, 9}}"},[i("span",{class:"jlbinding"},"Jutul.pick_next_timestep")],-1)),s[549]||(s[549]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[550]||(s[550]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pick_next_timestep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IterationTimestepSelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sim, config, dt_prev, dT, forces, reports, current_reports, step_index, new_step)</span></span></code></pre></div><p>Pick the next time-step for <code>IterationTimestepSelector</code>. This function uses the number of iterations from previous timesteps to estimate the relationship between the last and the new time step.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/timesteps.jl#L61-L67" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",at,[i("summary",null,[s[551]||(s[551]=i("a",{id:"Jutul.prepare_step_storage-Tuple{Any, Any, Missing}",href:"#Jutul.prepare_step_storage-Tuple{Any, Any, Missing}"},[i("span",{class:"jlbinding"},"Jutul.prepare_step_storage")],-1)),s[552]||(s[552]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[553]||(s[553]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prepare_step_storage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialize storage for prepare_step_handler.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/simulator.jl#L58-L62" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",nt,[i("summary",null,[s[554]||(s[554]=i("a",{id:"Jutul.read_results-Tuple{Any}",href:"#Jutul.read_results-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.read_results")],-1)),s[555]||(s[555]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[556]||(s[556]=i("p",null,"states, reports = read_results(pth; read_states = true, read_reports = true)",-1)),s[557]||(s[557]=i("p",null,[t("Read results from a given "),i("code",null,"output_path"),t(" provded to "),i("code",null,"simulate"),t(" or "),i("code",null,"simulator_config"),t(".")],-1)),s[558]||(s[558]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/utils.jl#L608-L612",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",pt,[i("summary",null,[s[559]||(s[559]=i("a",{id:"Jutul.relative_increment_limit-Tuple{JutulVariables}",href:"#Jutul.relative_increment_limit-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.relative_increment_limit")],-1)),s[560]||(s[560]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[561]||(s[561]=i("p",null,"Relative allowable change for variable during a nonlinear update. A variable with value |x| and relative limit 0.2 cannot change more than |x|*0.2.",-1)),s[562]||(s[562]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L91-L95",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",rt,[i("summary",null,[s[563]||(s[563]=i("a",{id:"Jutul.replace_variables!-Tuple{Any}",href:"#Jutul.replace_variables!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.replace_variables!")],-1)),s[564]||(s[564]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[565]||(s[565]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">replace_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, throw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, varname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef, varname2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef2)</span></span></code></pre></div><p>Replace one or more variables that already exists (primary, secondary or parameters).</p><p><strong>Arguments</strong></p><ul><li><p><code>model</code>: instance where variables is to be replaced</p></li><li><p><code>varname=vardef::JutulVariables</code>: replace variable with <code>varname</code> by <code>vardef</code></p></li><li><p><code>throw=true</code>: throw an error if the named variable definition is not found in primary or secondary, otherwise silently return</p></li></ul><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L137-L146" target="_blank" rel="noreferrer">source</a></p>',5))]),i("details",ot,[i("summary",null,[s[566]||(s[566]=i("a",{id:"Jutul.scalarize_primary_variable-Tuple{Any, Any, ScalarVariable, Any}",href:"#Jutul.scalarize_primary_variable-Tuple{Any, Any, ScalarVariable, Any}"},[i("span",{class:"jlbinding"},"Jutul.scalarize_primary_variable")],-1)),s[567]||(s[567]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[568]||(s[568]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scalarize_primary_variable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, source_vec, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Jutul.ScalarVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index)</span></span></code></pre></div><p>Scalarize a primary variable. For scalars, this means getting the value itself.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/scalarization.jl#L40-L44" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",ut,[i("summary",null,[s[569]||(s[569]=i("a",{id:"Jutul.scalarize_primary_variables",href:"#Jutul.scalarize_primary_variables"},[i("span",{class:"jlbinding"},"Jutul.scalarize_primary_variables")],-1)),s[570]||(s[570]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[571]||(s[571]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scalarize_primary_variables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, state, pvars </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">primary_variables)</span></span></code></pre></div><p>Create a vector where each entry corresponds to a tuple of values that minimally defines the given variables. All variables must belong to the same type of entity. This is checked by this function.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/scalarization.jl#L91-L97" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",dt,[i("summary",null,[s[572]||(s[572]=i("a",{id:"Jutul.scalarize_primary_variables!-Union{Tuple{T}, Tuple{Array{Jutul.ScalarizedJutulVariables{T}, 1}, Any, Any, NamedTuple}} where T",href:"#Jutul.scalarize_primary_variables!-Union{Tuple{T}, Tuple{Array{Jutul.ScalarizedJutulVariables{T}, 1}, Any, Any, NamedTuple}} where T"},[i("span",{class:"jlbinding"},"Jutul.scalarize_primary_variables!")],-1)),s[573]||(s[573]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[574]||(s[574]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scalarize_primary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model, state, pvars</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span></code></pre></div><p>Scalarize into array. See <a href="./@ref">scalarize_primary_variables</a> for more details.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/scalarization.jl#L115-L119" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",ht,[i("summary",null,[s[575]||(s[575]=i("a",{id:"Jutul.scalarized_primary_variable_type-Tuple{Any, ScalarVariable}",href:"#Jutul.scalarized_primary_variable_type-Tuple{Any, ScalarVariable}"},[i("span",{class:"jlbinding"},"Jutul.scalarized_primary_variable_type")],-1)),s[576]||(s[576]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[577]||(s[577]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scalarized_primary_variable_type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Jutul.ScalarVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the type of a scalarized numerical variable (=Float64 for variables that are already represented as scalars)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/scalarization.jl#L17-L22" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",kt,[i("summary",null,[s[578]||(s[578]=i("a",{id:"Jutul.set_default_tolerances-Tuple{Any}",href:"#Jutul.set_default_tolerances-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.set_default_tolerances")],-1)),s[579]||(s[579]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[580]||(s[580]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_default_tolerances</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model)</span></span></code></pre></div><p>Set default tolerances for the nonlinear convergence check of the governing equations.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L768-L772" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",gt,[i("summary",null,[s[581]||(s[581]=i("a",{id:"Jutul.set_parameters!-Tuple{Any}",href:"#Jutul.set_parameters!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.set_parameters!")],-1)),s[582]||(s[582]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[583]||(s[583]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_parameters!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, parname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pardef)</span></span></code></pre></div><p>Set a parameter with name <code>varname</code> to the definition <code>vardef</code> (adding if it does not exist)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L119-L123" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",yt,[i("summary",null,[s[584]||(s[584]=i("a",{id:"Jutul.set_primary_variables!-Tuple{Any}",href:"#Jutul.set_primary_variables!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.set_primary_variables!")],-1)),s[585]||(s[585]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[586]||(s[586]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_primary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, varname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_primary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, varname1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef1, varname2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef2)</span></span></code></pre></div><p>Set a primary variable with name <code>varname</code> to the definition <code>vardef</code> (adding if it does not exist)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L96-L101" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",ct,[i("summary",null,[s[587]||(s[587]=i("a",{id:"Jutul.set_secondary_variables!-Tuple{Any}",href:"#Jutul.set_secondary_variables!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.set_secondary_variables!")],-1)),s[588]||(s[588]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[589]||(s[589]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_secondary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, varname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_secondary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, varname1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef1, varname2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef2)</span></span></code></pre></div><p>Set a secondary variable with name <code>varname</code> to the definition <code>vardef</code> (adding if it does not exist)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L107-L113" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",bt,[i("summary",null,[s[590]||(s[590]=i("a",{id:"Jutul.setup_adjoint_storage-Tuple{Any}",href:"#Jutul.setup_adjoint_storage-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.setup_adjoint_storage")],-1)),s[591]||(s[591]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[592]||(s[592]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_adjoint_storage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model; state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model), parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model))</span></span></code></pre></div><p>Set up storage for use with <code>solve_adjoint_sensitivities!</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/gradients.jl#L100-L104" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",mt,[i("summary",null,[s[593]||(s[593]=i("a",{id:"Jutul.setup_forces-Tuple{JutulModel}",href:"#Jutul.setup_forces-Tuple{JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.setup_forces")],-1)),s[594]||(s[594]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[595]||(s[595]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; force_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> force_value)</span></span></code></pre></div><p>Set up forces for a given model. Keyword arguments varies depending on what the model supports.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L873-L878" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Et,[i("summary",null,[s[596]||(s[596]=i("a",{id:"Jutul.setup_parameter_optimization-Tuple{Any, Any, Any, Any, Any, Any, Vararg{Any}}",href:"#Jutul.setup_parameter_optimization-Tuple{Any, Any, Any, Any, Any, Any, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.setup_parameter_optimization")],-1)),s[597]||(s[597]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[598]||(s[598]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_parameter_optimization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, state0, param, dt, forces, G, opt_cfg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> optimization_config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, param);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                        grad_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :adjoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                        config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                        print </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                        copy_case </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                        param_obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                        kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up function handles for optimizing the case defined by the inputs to <code>simulate</code> together with a per-timestep objective function <code>G</code>.</p><p>Generally calling either of the functions will mutate the data Dict. The options are: F_o(x) -&gt; evaluate objective dF_o(dFdx, x) -&gt; evaluate gradient of objective, mutating dFdx (may trigger evaluation of F_o) F_and_dF(F, dFdx, x) -&gt; evaluate F and/or dF. Value of nothing will mean that the corresponding entry is skipped.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/optimization.jl#L17-L34" target="_blank" rel="noreferrer">source</a></p>`,4))]),i("details",ft,[i("summary",null,[s[599]||(s[599]=i("a",{id:"Jutul.setup_parameters-Tuple{DataDomain, JutulModel}",href:"#Jutul.setup_parameters-Tuple{DataDomain, JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.setup_parameters")],-1)),s[600]||(s[600]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[601]||(s[601]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value)</span></span></code></pre></div><p>Set up a parameter storage for a given model with values for the parameter defined in the model.</p><p><strong>Arguments</strong></p><ul><li><code>name=value</code>: The name of the parameter together with the value(s) of the parameter.</li></ul><p>A scalar (or short vector of the right size for <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) will be repeated over the entire domain, while a vector (or matrix for <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) with length (number of columns for <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) equal to the entity count (for example, number of cells for a cell variable) will be used directly.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L290-L300" target="_blank" rel="noreferrer">source</a></p>',6))]),i("details",jt,[i("summary",null,[s[602]||(s[602]=i("a",{id:"Jutul.setup_partitioner_hypergraph-Tuple{Matrix{Int64}}",href:"#Jutul.setup_partitioner_hypergraph-Tuple{Matrix{Int64}}"},[i("span",{class:"jlbinding"},"Jutul.setup_partitioner_hypergraph")],-1)),s[603]||(s[603]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[604]||(s[604]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_partitioner_hypergraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Matrix{Int}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    num_nodes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> maximum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    num_edges</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    node_weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{Int}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Int, num_nodes),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    edge_weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{Int}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Int, num_edges),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    groups </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Int[]]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up a hypergraph structure for a given neighborship matrix. <code>N</code> should be a matrix with two rows, with one pair of cells in each column. Optionally node and edge weights can be provided. If a list of groups are provided, these nodes will be accumulated together in the hypergraph.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/partitioning.jl#L237-L250" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",vt,[i("summary",null,[s[605]||(s[605]=i("a",{id:"Jutul.setup_state!",href:"#Jutul.setup_state!"},[i("span",{class:"jlbinding"},"Jutul.setup_state!")],-1)),s[606]||(s[606]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[607]||(s[607]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_state!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, init_values</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDict</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Initialize primary variables and other state fields, given initial values as a Dict</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L252-L256" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ft,[i("summary",null,[s[608]||(s[608]=i("a",{id:"Jutul.setup_state-Tuple{JutulModel, Vararg{Any}}",href:"#Jutul.setup_state-Tuple{JutulModel, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.setup_state")],-1)),s[609]||(s[609]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[610]||(s[610]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value1, name2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value2)</span></span></code></pre></div><p>Set up a state for a given model with values for the primary variables defined in the model. Normally all primary variables must be initialized in this way.</p><p><strong>Arguments</strong></p><ul><li><code>name=value</code>: The name of the primary variable together with the value(s) used to initialize the primary variable.</li></ul><p>A scalar (or short vector of the right size for <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) will be repeated over the entire domain, while a vector (or matrix for <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) with length (number of columns for <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) equal to the entity count (for example, number of cells for a cell variable) will be used directly.</p><p>Note: You likely want to overload [<code>setup_state!</code>]@ref for a custom model instead of <code>setup_state</code></p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L224-L237" target="_blank" rel="noreferrer">source</a></p>',7))]),i("details",Ct,[i("summary",null,[s[611]||(s[611]=i("a",{id:"Jutul.setup_state_and_parameters-Tuple{DataDomain, JutulModel, AbstractDict}",href:"#Jutul.setup_state_and_parameters-Tuple{DataDomain, JutulModel, AbstractDict}"},[i("span",{class:"jlbinding"},"Jutul.setup_state_and_parameters")],-1)),s[612]||(s[612]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[613]||(s[613]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state, prm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state_and_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, init)</span></span></code></pre></div><p>Simultaneously set up state and parameters from a single <code>init</code> file (typically a <code>Dict</code> containing values that might either be initial values or parameters)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L324-L329" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Jt,[i("summary",null,[s[614]||(s[614]=i("a",{id:"Jutul.setup_storage!-Tuple{Any, JutulModel}",href:"#Jutul.setup_storage!-Tuple{Any, JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.setup_storage!")],-1)),s[615]||(s[615]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[616]||(s[616]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_storage!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; setup_linearized_system </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                setup_equations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                tag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                state0_ad </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                state_ad </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Allocate storage for a given model. The storage consists of all dynamic quantities used in the simulation. The default implementation allocates properties, equations and linearized system.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L404-L416" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",At,[i("summary",null,[s[617]||(s[617]=i("a",{id:"Jutul.setup_storage-Tuple{JutulModel}",href:"#Jutul.setup_storage-Tuple{JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.setup_storage")],-1)),s[618]||(s[618]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[619]||(s[619]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_storage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Allocate storage for the model. You should overload setup_storage! if you have a custom definition.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L375-L380" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Tt,[i("summary",null,[s[620]||(s[620]=i("a",{id:"Jutul.si_unit-Tuple{Symbol}",href:"#Jutul.si_unit-Tuple{Symbol}"},[i("span",{class:"jlbinding"},"Jutul.si_unit")],-1)),s[621]||(s[621]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[622]||(s[622]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">si_unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{String, Symbol}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the multiplicative SI unit conversion factor for a single unit. The return value is given so that <code>x*si_unit(:name)</code> will convert <code>x</code> to the SI representation of the unit with the given name.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> si_unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:day</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get days represented as seconds</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">86400.0</span></span></code></pre></div><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/units/interface.jl#L73-L85" target="_blank" rel="noreferrer">source</a></p>`,5))]),i("details",xt,[i("summary",null,[s[623]||(s[623]=i("a",{id:"Jutul.si_units-Tuple",href:"#Jutul.si_units-Tuple"},[i("span",{class:"jlbinding"},"Jutul.si_units")],-1)),s[624]||(s[624]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[625]||(s[625]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">si_units</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u1, arg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get multiplicative SI unit conversion factors for multiple units simultaneously. The return value will be a <code>Tuple</code> of values, one for each input argument. Each input arguments can be either a <code>String</code> a <code>Symbol</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> meter, hour </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> si_units</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:meter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:hour</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3600.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/units/interface.jl#L56-L68" target="_blank" rel="noreferrer">source</a></p>`,5))]),i("details",Dt,[i("summary",null,[s[626]||(s[626]=i("a",{id:"Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}",href:"#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.simulate!")],-1)),s[627]||(s[627]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[628]||(s[628]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, timesteps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    initialize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    restart </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Non-allocating (or perhaps less allocating) version of <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>initialize=true</code>: Perform internal updates as if this is the first time</li></ul><p>See also <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}"><code>simulate</code></a> for additional supported input arguments.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/simulator.jl#L125-L142" target="_blank" rel="noreferrer">source</a></p>`,6))]),i("details",Mt,[i("summary",null,[s[629]||(s[629]=i("a",{id:"Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}",href:"#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.simulate")],-1)),s[630]||(s[630]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[631]||(s[631]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state0, model, timesteps, parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state0, model, timesteps, info_level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state0, model, timesteps; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Simulate a set of <code>timesteps</code> with <code>model</code> for the given initial <code>state0</code> and optionally specific parameters. Additional keyword arguments are passed onto <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulator_config-Tuple{Any}"><code>simulator_config</code></a> and <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>. This interface is primarily for convenience, as all storage for the simulator is allocated upon use and discared upon return. If you want to perform multiple simulations with the same model it is advised to instead instantiate <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.Simulator-Tuple{Any}"><code>Simulator</code></a> and combine it with <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>state0::Dict</code>: initial state, typically created using <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.setup_state-Tuple{JutulModel, Vararg{Any}}"><code>setup_state</code></a> for the <code>model</code> in use.</p></li><li><p><code>model::JutulModel</code>: model that describes the discretized system to solve, for example <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.SimulationModel-Tuple{Any, Any}"><code>SimulationModel</code></a> or <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.MultiModel"><code>MultiModel</code></a>.</p></li><li><p><code>timesteps::AbstractVector</code>: Vector of desired report steps. The simulator will perform time integration until <code>sum(timesteps)</code> is reached, providing outputs at the end of each report step.</p></li><li><p><code>parameters=setup_parameters(model)</code>: Optional overrides the default parameters for the model.</p></li><li><p><code>forces=nothing</code>: Either <code>nothing</code> (for no forces), a single set of forces from <code>setup_forces(model)</code> or a <code>Vector</code> of such forces with equal length to <code>timesteps</code>.</p></li><li><p><code>restart=nothing</code>: If an integer is provided, the simulation will attempt to restart from that step. Requires that <code>output_path</code> is provided here or in the <code>config</code>.</p></li><li><p><code>config=simulator_config(model)</code>: Configuration <code>Dict</code> that holds many fine grained settings for output, linear solver, time-steps, outputs etc.</p></li></ul><p>Additional arguments are passed onto <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulator_config-Tuple{Any}"><code>simulator_config</code></a>.</p><p>See also <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>, <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.Simulator-Tuple{Any}"><code>Simulator</code></a>, <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.SimulationModel-Tuple{Any, Any}"><code>SimulationModel</code></a>, <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulator_config-Tuple{Any}"><code>simulator_config</code></a>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/simulator.jl#L78-L103" target="_blank" rel="noreferrer">source</a></p>`,7))]),i("details",_t,[i("summary",null,[s[632]||(s[632]=i("a",{id:"Jutul.simulate-Tuple{Any, JutulSimulator, AbstractVector}",href:"#Jutul.simulate-Tuple{Any, JutulSimulator, AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.simulate")],-1)),s[633]||(s[633]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[634]||(s[634]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state0, sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, timesteps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Simulate a set of <code>timesteps</code> with <code>simulator</code> for the given initial <code>state0</code> and optionally specific parameters.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/simulator.jl#L114-L118" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Lt,[i("summary",null,[s[635]||(s[635]=i("a",{id:"Jutul.simulator_config-Tuple{Any}",href:"#Jutul.simulator_config-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.simulator_config")],-1)),s[636]||(s[636]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[637]||(s[637]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulator_config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim; info_level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, linear_solver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GenericKrylov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Set up a simulator configuration object that can be passed onto <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>.</p><p>There are many options available to configure a given simulator. The best way to get an overview of these possible configuration options is to instatiate the config without any arguments and inspecting the resulting table by calling <code>simulator_config(sim)</code> in the REPL.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/config.jl#L95-L105" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",Bt,[i("summary",null,[s[638]||(s[638]=i("a",{id:"Jutul.solve_adjoint_sensitivities!-NTuple{6, Any}",href:"#Jutul.solve_adjoint_sensitivities!-NTuple{6, Any}"},[i("span",{class:"jlbinding"},"Jutul.solve_adjoint_sensitivities!")],-1)),s[639]||(s[639]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[640]||(s[640]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solve_adjoint_sensitivities!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(∇G, storage, states, state0, timesteps, G; forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model))</span></span></code></pre></div><p>Non-allocating version of <code>solve_adjoint_sensitivities</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/gradients.jl#L206-L210" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",wt,[i("summary",null,[s[641]||(s[641]=i("a",{id:"Jutul.solve_adjoint_sensitivities-NTuple{4, Any}",href:"#Jutul.solve_adjoint_sensitivities-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.solve_adjoint_sensitivities")],-1)),s[642]||(s[642]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[643]||(s[643]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solve_adjoint_sensitivities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, states, reports_or_timesteps, G; extra_timing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model), forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model), raw_output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute sensitivities of <code>model</code> parameter with name <code>target</code> for objective function <code>G</code>.</p><p>The objective function is at the moment assumed to be a sum over all states on the form: <code>obj = Σₙ G(model, state, dt_n, n, forces_for_step_n)</code></p><p>Solves the adjoint equations: For model equations F the gradient with respect to parameters p is ∇ₚG = Σₙ (∂Fₙ / ∂p)ᵀ λₙ where n ∈ [1, N]. Given Lagrange multipliers λₙ from the adjoint equations (∂Fₙ / ∂xₙ)ᵀ λₙ = - (∂J / ∂xₙ)ᵀ - (∂Fₙ₊₁ / ∂xₙ)ᵀ λₙ₊₁ where the last term is omitted for step n = N and G is the objective function.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/gradients.jl#L3-L16" target="_blank" rel="noreferrer">source</a></p>',5))]),i("details",St,[i("summary",null,[s[644]||(s[644]=i("a",{id:"Jutul.solve_numerical_sensitivities-NTuple{5, Any}",href:"#Jutul.solve_numerical_sensitivities-NTuple{5, Any}"},[i("span",{class:"jlbinding"},"Jutul.solve_numerical_sensitivities")],-1)),s[645]||(s[645]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[646]||(s[646]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solve_numerical_sensitivities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, states, reports, G, target;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                            forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                            state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                            parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                            epsilon </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1e-8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute sensitivities of <code>model</code> parameter with name <code>target</code> for objective function <code>G</code>.</p><p>This method uses numerical perturbation and is primarily intended for testing of <code>solve_adjoint_sensitivities</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/gradients.jl#L579-L589" target="_blank" rel="noreferrer">source</a></p>`,4))]),i("details",Ot,[i("summary",null,[s[647]||(s[647]=i("a",{id:"Jutul.solve_timestep!-NTuple{5, Any}",href:"#Jutul.solve_timestep!-NTuple{5, Any}"},[i("span",{class:"jlbinding"},"Jutul.solve_timestep!")],-1)),s[648]||(s[648]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[649]||(s[649]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solve_timestep!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim, dT, forces, max_its, config; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Internal function for solving a single time-step with fixed driving forces.</p><p><strong>Arguments</strong></p><ul><li><p><code>sim</code>: <code>Simulator</code> instance.</p></li><li><p><code>dT</code>: time-step to be solved</p></li><li><p><code>forces</code>: Driving forces for the time-step</p></li><li><p><code>max_its</code>: Maximum number of steps/Newton iterations.</p></li><li><p><code>config</code>: Configuration for solver (typically output from <code>simulator_config</code>).</p></li></ul><p>Note: This function is exported for fine-grained simulation workflows. The general <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}"><code>simulate</code></a> interface is both easier to use and performs additional validation.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/simulator/simulator.jl#L247-L261" target="_blank" rel="noreferrer">source</a></p>',6))]),i("details",Vt,[i("summary",null,[s[650]||(s[650]=i("a",{id:"Jutul.subvariable-Tuple{Any, Any}",href:"#Jutul.subvariable-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.subvariable")],-1)),s[651]||(s[651]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[652]||(s[652]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">subvariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(var, map)</span></span></code></pre></div><p>Get subvariable of Jutul variable</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/dd/submodels.jl#L144-L148" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",qt,[i("summary",null,[s[653]||(s[653]=i("a",{id:"Jutul.successful_reports",href:"#Jutul.successful_reports"},[i("span",{class:"jlbinding"},"Jutul.successful_reports")],-1)),s[654]||(s[654]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[655]||(s[655]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">successful_reports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(old_reports, current_reports, step_index, n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the <code>n</code> last successful solve reports from all previous reports (old_reports) and the current ministep set.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/timesteps.jl#L151-L156" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",zt,[i("summary",null,[s[656]||(s[656]=i("a",{id:"Jutul.synchronize-Tuple{JutulContext}",href:"#Jutul.synchronize-Tuple{JutulContext}"},[i("span",{class:"jlbinding"},"Jutul.synchronize")],-1)),s[657]||(s[657]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[658]||(s[658]=i("p",null,"Synchronize backend after allocations.",-1)),s[659]||(s[659]=i("p",null,"Some backends may require notification that storage has been allocated.",-1)),s[660]||(s[660]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/context.jl#L66-L71",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Pt,[i("summary",null,[s[661]||(s[661]=i("a",{id:"Jutul.tpfv_geometry",href:"#Jutul.tpfv_geometry"},[i("span",{class:"jlbinding"},"Jutul.tpfv_geometry")],-1)),s[662]||(s[662]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[663]||(s[663]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tpfv_geometry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span></span></code></pre></div><p>Generate two-point finite-volume geometry for a given grid, if supported.</p><p>See also <a href="/JutulDarcy.jl/previews/PR62/ref/jutul#Jutul.TwoPointFiniteVolumeGeometry"><code>TwoPointFiniteVolumeGeometry</code></a>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/meshes/meshes.jl#L10-L16" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",Gt,[i("summary",null,[s[664]||(s[664]=i("a",{id:"Jutul.transfer-Tuple{Any, Any}",href:"#Jutul.transfer-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.transfer")],-1)),s[665]||(s[665]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[666]||(s[666]=i("p",null,"Transfer v to the representation expected by a given context.",-1)),s[667]||(s[667]=i("p",null,"For the defalt context, the transfer function does nothing. For other context such as the CUDA version, it may convert integers and floats to other types (e.g. Float32) and Arrays to CuArrays.",-1)),s[668]||(s[668]=i("p",null,"You will likely have to implement some transfer operators for your own types if you want to simulate with a non-default context.",-1)),s[669]||(s[669]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/context.jl#L1-L10",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Nt,[i("summary",null,[s[670]||(s[670]=i("a",{id:"Jutul.two_point_potential_drop-NTuple{5, Real}",href:"#Jutul.two_point_potential_drop-NTuple{5, Real}"},[i("span",{class:"jlbinding"},"Jutul.two_point_potential_drop")],-1)),s[671]||(s[671]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[672]||(s[672]=i("p",null,"Two-point potential drop with gravity (generic)",-1)),s[673]||(s[673]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/conservation/flux.jl#L293-L295",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Rt,[i("summary",null,[s[674]||(s[674]=i("a",{id:"Jutul.unsafe_reinterpret-Tuple{Any, Any, Any}",href:"#Jutul.unsafe_reinterpret-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.unsafe_reinterpret")],-1)),s[675]||(s[675]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[676]||(s[676]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unsafe_reinterpret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Vt, v, n)</span></span></code></pre></div><p>Unsafely reinterpret v as a n length vector of value type Vt</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/linsolve/utils.jl#L95-L99" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",It,[i("summary",null,[s[677]||(s[677]=i("a",{id:"Jutul.update_before_step!-NTuple{4, Any}",href:"#Jutul.update_before_step!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_before_step!")],-1)),s[678]||(s[678]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[679]||(s[679]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L927-L929",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Ut,[i("summary",null,[s[680]||(s[680]=i("a",{id:"Jutul.update_equation!-Tuple{Any, JutulEquation, Any, Any, Any}",href:"#Jutul.update_equation!-Tuple{Any, JutulEquation, Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_equation!")],-1)),s[681]||(s[681]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[682]||(s[682]=i("p",null,"Update equation based on currently stored properties",-1)),s[683]||(s[683]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L512-L514",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Wt,[i("summary",null,[s[684]||(s[684]=i("a",{id:"Jutul.update_equations!",href:"#Jutul.update_equations!"},[i("span",{class:"jlbinding"},"Jutul.update_equations!")],-1)),s[685]||(s[685]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[686]||(s[686]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_equations!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model, dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Update the governing equations using the current set of primary variables, parameters and secondary variables. Does not fill linearized system.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L707-L711" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Ht,[i("summary",null,[s[687]||(s[687]=i("a",{id:"Jutul.update_equations_and_apply_forces!-NTuple{4, Any}",href:"#Jutul.update_equations_and_apply_forces!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_equations_and_apply_forces!")],-1)),s[688]||(s[688]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[689]||(s[689]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_equations_and_apply_forces!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model, dt, forces; time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NaN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Update the model equations and apply boundary conditions and forces. Does not fill linearized system.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L689-L693" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Kt,[i("summary",null,[s[690]||(s[690]=i("a",{id:"Jutul.update_linearized_system!",href:"#Jutul.update_linearized_system!"},[i("span",{class:"jlbinding"},"Jutul.update_linearized_system!")],-1)),s[691]||(s[691]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[692]||(s[692]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_linearized_system!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Update the linearized system with the current set of equations.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L722-L726" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Yt,[i("summary",null,[s[693]||(s[693]=i("a",{id:"Jutul.update_linearized_system_equation!-Tuple{AbstractArray, Any, Any, JutulEquation, CompactAutoDiffCache}",href:"#Jutul.update_linearized_system_equation!-Tuple{AbstractArray, Any, Any, JutulEquation, CompactAutoDiffCache}"},[i("span",{class:"jlbinding"},"Jutul.update_linearized_system_equation!")],-1)),s[694]||(s[694]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[695]||(s[695]=i("p",null,"Update a linearized system based on the values and derivatives in the equation.",-1)),s[696]||(s[696]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/equations.jl#L490-L492",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",$t,[i("summary",null,[s[697]||(s[697]=i("a",{id:"Jutul.update_parameter_before_step!-NTuple{6, Any}",href:"#Jutul.update_parameter_before_step!-NTuple{6, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_parameter_before_step!")],-1)),s[698]||(s[698]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[699]||(s[699]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_parameter_before_step!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prm_val, prm, storage, model, dt, forces)</span></span></code></pre></div><p>Update parameters before time-step. Used for hysteretic parameters.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L973-L977" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",Zt,[i("summary",null,[s[700]||(s[700]=i("a",{id:"Jutul.update_secondary_variable!",href:"#Jutul.update_secondary_variable!"},[i("span",{class:"jlbinding"},"Jutul.update_secondary_variable!")],-1)),s[701]||(s[701]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[702]||(s[702]=i("p",null,"Update a secondary variable. Normally autogenerated with @jutul_secondary",-1)),s[703]||(s[703]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variable_evaluation.jl#L207-L209",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",Xt,[i("summary",null,[s[704]||(s[704]=i("a",{id:"Jutul.update_state_dependents!-Tuple{Any, JutulModel, Any, Any}",href:"#Jutul.update_state_dependents!-Tuple{Any, JutulModel, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_state_dependents!")],-1)),s[705]||(s[705]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[706]||(s[706]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_state_dependents!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model, dt, forces; time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NaN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, update_secondary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Perform updates of everything that depends on the state: A full linearization for the current primary variables.</p><p>This includes properties, governing equations and the linearized system itself.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/models.jl#L674-L680" target="_blank" rel="noreferrer">source</a></p>',4))]),i("details",Qt,[i("summary",null,[s[707]||(s[707]=i("a",{id:"Jutul.update_values!-Tuple{AbstractArray, AbstractArray}",href:"#Jutul.update_values!-Tuple{AbstractArray, AbstractArray}"},[i("span",{class:"jlbinding"},"Jutul.update_values!")],-1)),s[708]||(s[708]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[709]||(s[709]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_values!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, dx)</span></span></code></pre></div><p>Replace values (for non-Real types, direct assignment)</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L389-L393" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",se,[i("summary",null,[s[710]||(s[710]=i("a",{id:"Jutul.update_values!-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}}",href:"#Jutul.update_values!-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}}"},[i("span",{class:"jlbinding"},"Jutul.update_values!")],-1)),s[711]||(s[711]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[712]||(s[712]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_values!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, dx)</span></span></code></pre></div><p>Replace values of <code>x</code> in-place by <code>y</code>, leaving <code>x</code> with the values of y and the partials of <code>x</code>.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L379-L383" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",ie,[i("summary",null,[s[713]||(s[713]=i("a",{id:"Jutul.value-Tuple{AbstractDict}",href:"#Jutul.value-Tuple{AbstractDict}"},[i("span",{class:"jlbinding"},"Jutul.value")],-1)),s[714]||(s[714]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[715]||(s[715]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Call value on all elements of some Dict.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L409-L412" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",te,[i("summary",null,[s[716]||(s[716]=i("a",{id:"Jutul.value-Tuple{Any}",href:"#Jutul.value-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.value")],-1)),s[717]||(s[717]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[718]||(s[718]=i("p",null,"Take value of AD.",-1)),s[719]||(s[719]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/ad/ad.jl#L398-L400",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ee,[i("summary",null,[s[720]||(s[720]=i("a",{id:"Jutul.values_per_entity-Tuple{Any, JutulVariables}",href:"#Jutul.values_per_entity-Tuple{Any, JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.values_per_entity")],-1)),s[721]||(s[721]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[722]||(s[722]=i("p",null,"Number of values held by a primary variable. Normally this is equal to the number of degrees of freedom, but some special primary variables are most conveniently defined by having N values and N-1 independent variables.",-1)),s[723]||(s[723]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L79-L82",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",le,[i("summary",null,[s[724]||(s[724]=i("a",{id:"Jutul.variable_scale-Tuple{JutulVariables}",href:"#Jutul.variable_scale-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.variable_scale")],-1)),s[725]||(s[725]=t()),l(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[726]||(s[726]=i("p",null,'Define a "typical" numerical value for a variable to scale the linear system entries.',-1)),s[727]||(s[727]=i("p",null,[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variables/utils.jl#L190-L192",target:"_blank",rel:"noreferrer"},"source")],-1))]),i("details",ae,[i("summary",null,[s[728]||(s[728]=i("a",{id:"Jutul.write_reports_to_mat_format",href:"#Jutul.write_reports_to_mat_format"},[i("span",{class:"jlbinding"},"Jutul.write_reports_to_mat_format")],-1)),s[729]||(s[729]=t()),l(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[730]||(s[730]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_reports_to_mat_format</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> jutul_output_path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;report&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, verbose </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Write the reports to MAT files named &quot;report_1&quot;, &quot;report_2&quot;, ... to the given path.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/utils.jl#L1090-L1094" target="_blank" rel="noreferrer">source</a></p>',3))]),i("details",ne,[i("summary",null,[s[731]||(s[731]=i("a",{id:"Jutul.@jutul_secondary-Tuple{Any}",href:"#Jutul.@jutul_secondary-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.@jutul_secondary")],-1)),s[732]||(s[732]=t()),l(e,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),s[733]||(s[733]=a(`<p>Designate the function as updating a secondary variable.</p><p>A generic evaluator is then defined, together with a function for getting the dependencies of that function upon the state. This is most easily documented with an example. If we define the following function annotated with the macro when updating the array containing the values of <code>MyVarType</code> realized for some model:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@jutul_secondary</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> some_fn!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyVarType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model, a, b, c, ix)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ix</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c[i]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The purpose of the macro is to translate this into two functions. The first defines for the dependencies of the function with respect to the fields of the state (primary variables, secondary variables and parameters):</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyVarType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The second function defines a generic version that takes in state, and automatically expands the set of dependencies into <code>getfield</code> calls.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> update_secondary_variable!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array_target, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyVarType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model, state, ix)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    some_fn!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array_target, var, model, state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a, state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b, state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c, ix)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>Note that the input names of arguments 4 to end-1 matter, as these will be fetched from state, exactly as written.</p><p><a href="https://github.com/sintefmath/Jutul.jl/blob/v0.2.37/src/variable_evaluation.jl#L4-L37" target="_blank" rel="noreferrer">source</a></p>`,9))])])}const ye=n(u,[["render",pe]]);export{ge as __pageData,ye as default};
