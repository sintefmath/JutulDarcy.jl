import{_ as o,C as r,c as p,o as u,az as n,j as i,G as e,a as l,w as a}from"./chunks/framework.BY38s0nK.js";const pl=JSON.parse('{"title":"Documentation from Jutul.jl","description":"","frontmatter":{},"headers":[],"relativePath":"ref/jutul.md","filePath":"ref/jutul.md","lastUpdated":null}'),d={name:"ref/jutul.md"},h={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},J={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},z={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},U={class:"jldocstring custom-block",open:""},W={class:"jldocstring custom-block",open:""},H={class:"jldocstring custom-block",open:""},K={class:"jldocstring custom-block",open:""},Y={class:"jldocstring custom-block",open:""},$={class:"jldocstring custom-block",open:""},Z={class:"jldocstring custom-block",open:""},X={class:"jldocstring custom-block",open:""},Q={class:"jldocstring custom-block",open:""},ss={class:"jldocstring custom-block",open:""},is={class:"jldocstring custom-block",open:""},ts={class:"jldocstring custom-block",open:""},es={class:"jldocstring custom-block",open:""},ls={class:"jldocstring custom-block",open:""},as={class:"jldocstring custom-block",open:""},ns={class:"jldocstring custom-block",open:""},os={class:"jldocstring custom-block",open:""},rs={class:"jldocstring custom-block",open:""},ps={class:"jldocstring custom-block",open:""},us={class:"jldocstring custom-block",open:""},ds={class:"jldocstring custom-block",open:""},hs={class:"jldocstring custom-block",open:""},ks={class:"jldocstring custom-block",open:""},gs={class:"jldocstring custom-block",open:""},ys={class:"jldocstring custom-block",open:""},cs={class:"jldocstring custom-block",open:""},bs={class:"jldocstring custom-block",open:""},ms={class:"jldocstring custom-block",open:""},Es={class:"jldocstring custom-block",open:""},fs={class:"jldocstring custom-block",open:""},_s={class:"jldocstring custom-block",open:""},js={class:"jldocstring custom-block",open:""},vs={class:"jldocstring custom-block",open:""},Cs={class:"jldocstring custom-block",open:""},Ts={class:"jldocstring custom-block",open:""},Fs={class:"jldocstring custom-block",open:""},As={class:"jldocstring custom-block",open:""},Js={class:"jldocstring custom-block",open:""},xs={class:"jldocstring custom-block",open:""},Ds={class:"jldocstring custom-block",open:""},Ss={class:"jldocstring custom-block",open:""},Ms={class:"jldocstring custom-block",open:""},Bs={class:"jldocstring custom-block",open:""},Ls={class:"jldocstring custom-block",open:""},Vs={class:"jldocstring custom-block",open:""},ws={class:"jldocstring custom-block",open:""},Ps={class:"jldocstring custom-block",open:""},Is={class:"jldocstring custom-block",open:""},Os={class:"jldocstring custom-block",open:""},Ns={class:"jldocstring custom-block",open:""},Rs={class:"jldocstring custom-block",open:""},qs={class:"jldocstring custom-block",open:""},zs={class:"jldocstring custom-block",open:""},Gs={class:"jldocstring custom-block",open:""},Us={class:"jldocstring custom-block",open:""},Ws={class:"jldocstring custom-block",open:""},Hs={class:"jldocstring custom-block",open:""},Ks={class:"jldocstring custom-block",open:""},Ys={class:"jldocstring custom-block",open:""},$s={class:"jldocstring custom-block",open:""},Zs={class:"jldocstring custom-block",open:""},Xs={class:"jldocstring custom-block",open:""},Qs={class:"jldocstring custom-block",open:""},si={class:"jldocstring custom-block",open:""},ii={class:"jldocstring custom-block",open:""},ti={class:"jldocstring custom-block",open:""},ei={class:"jldocstring custom-block",open:""},li={class:"jldocstring custom-block",open:""},ai={class:"jldocstring custom-block",open:""},ni={class:"jldocstring custom-block",open:""},oi={class:"jldocstring custom-block",open:""},ri={class:"jldocstring custom-block",open:""},pi={class:"jldocstring custom-block",open:""},ui={class:"jldocstring custom-block",open:""},di={class:"jldocstring custom-block",open:""},hi={class:"jldocstring custom-block",open:""},ki={class:"jldocstring custom-block",open:""},gi={class:"jldocstring custom-block",open:""},yi={class:"jldocstring custom-block",open:""},ci={class:"jldocstring custom-block",open:""},bi={class:"jldocstring custom-block",open:""},mi={class:"jldocstring custom-block",open:""},Ei={class:"jldocstring custom-block",open:""},fi={class:"jldocstring custom-block",open:""},_i={class:"jldocstring custom-block",open:""},ji={class:"jldocstring custom-block",open:""},vi={class:"jldocstring custom-block",open:""},Ci={class:"jldocstring custom-block",open:""},Ti={class:"jldocstring custom-block",open:""},Fi={class:"jldocstring custom-block",open:""},Ai={class:"jldocstring custom-block",open:""},Ji={class:"jldocstring custom-block",open:""},xi={class:"jldocstring custom-block",open:""},Di={class:"jldocstring custom-block",open:""},Si={class:"jldocstring custom-block",open:""},Mi={class:"jldocstring custom-block",open:""},Bi={class:"jldocstring custom-block",open:""},Li={class:"jldocstring custom-block",open:""},Vi={class:"jldocstring custom-block",open:""},wi={class:"jldocstring custom-block",open:""},Pi={class:"jldocstring custom-block",open:""},Ii={class:"jldocstring custom-block",open:""},Oi={class:"jldocstring custom-block",open:""},Ni={class:"jldocstring custom-block",open:""},Ri={class:"jldocstring custom-block",open:""},qi={class:"jldocstring custom-block",open:""},zi={class:"jldocstring custom-block",open:""},Gi={class:"jldocstring custom-block",open:""},Ui={class:"jldocstring custom-block",open:""},Wi={class:"jldocstring custom-block",open:""},Hi={class:"jldocstring custom-block",open:""},Ki={class:"jldocstring custom-block",open:""},Yi={class:"jldocstring custom-block",open:""},$i={class:"jldocstring custom-block",open:""},Zi={class:"jldocstring custom-block",open:""},Xi={class:"jldocstring custom-block",open:""},Qi={class:"jldocstring custom-block",open:""},st={class:"jldocstring custom-block",open:""},it={class:"jldocstring custom-block",open:""},tt={class:"jldocstring custom-block",open:""},et={class:"jldocstring custom-block",open:""},lt={class:"jldocstring custom-block",open:""},at={class:"jldocstring custom-block",open:""},nt={class:"jldocstring custom-block",open:""},ot={class:"jldocstring custom-block",open:""},rt={class:"jldocstring custom-block",open:""},pt={class:"jldocstring custom-block",open:""},ut={class:"jldocstring custom-block",open:""},dt={class:"jldocstring custom-block",open:""},ht={class:"jldocstring custom-block",open:""},kt={class:"jldocstring custom-block",open:""},gt={class:"jldocstring custom-block",open:""},yt={class:"jldocstring custom-block",open:""},ct={class:"jldocstring custom-block",open:""},bt={class:"jldocstring custom-block",open:""},mt={class:"jldocstring custom-block",open:""},Et={class:"jldocstring custom-block",open:""},ft={class:"jldocstring custom-block",open:""},_t={class:"jldocstring custom-block",open:""},jt={class:"jldocstring custom-block",open:""},vt={class:"jldocstring custom-block",open:""},Ct={class:"jldocstring custom-block",open:""},Tt={class:"jldocstring custom-block",open:""},Ft={class:"jldocstring custom-block",open:""},At={class:"jldocstring custom-block",open:""},Jt={class:"jldocstring custom-block",open:""},xt={class:"jldocstring custom-block",open:""},Dt={class:"jldocstring custom-block",open:""},St={class:"jldocstring custom-block",open:""},Mt={class:"jldocstring custom-block",open:""},Bt={class:"jldocstring custom-block",open:""},Lt={class:"jldocstring custom-block",open:""},Vt={class:"jldocstring custom-block",open:""},wt={class:"jldocstring custom-block",open:""},Pt={class:"jldocstring custom-block",open:""},It={class:"jldocstring custom-block",open:""},Ot={class:"jldocstring custom-block",open:""},Nt={class:"jldocstring custom-block",open:""},Rt={class:"jldocstring custom-block",open:""},qt={class:"jldocstring custom-block",open:""},zt={class:"jldocstring custom-block",open:""},Gt={class:"jldocstring custom-block",open:""},Ut={class:"jldocstring custom-block",open:""},Wt={class:"jldocstring custom-block",open:""},Ht={class:"jldocstring custom-block",open:""},Kt={class:"jldocstring custom-block",open:""},Yt={class:"jldocstring custom-block",open:""},$t={class:"jldocstring custom-block",open:""},Zt={class:"jldocstring custom-block",open:""},Xt={class:"jldocstring custom-block",open:""},Qt={class:"jldocstring custom-block",open:""},se={class:"jldocstring custom-block",open:""},ie={class:"jldocstring custom-block",open:""},te={class:"jldocstring custom-block",open:""},ee={class:"jldocstring custom-block",open:""},le={class:"jldocstring custom-block",open:""},ae={class:"jldocstring custom-block",open:""},ne={class:"jldocstring custom-block",open:""},oe={class:"jldocstring custom-block",open:""},re={class:"jldocstring custom-block",open:""},pe={class:"jldocstring custom-block",open:""},ue={class:"jldocstring custom-block",open:""},de={class:"jldocstring custom-block",open:""},he={class:"jldocstring custom-block",open:""},ke={class:"jldocstring custom-block",open:""},ge={class:"jldocstring custom-block",open:""},ye={class:"jldocstring custom-block",open:""},ce={class:"jldocstring custom-block",open:""},be={class:"jldocstring custom-block",open:""},me={class:"jldocstring custom-block",open:""},Ee={class:"jldocstring custom-block",open:""},fe={class:"jldocstring custom-block",open:""},_e={class:"jldocstring custom-block",open:""},je={class:"jldocstring custom-block",open:""},ve={class:"jldocstring custom-block",open:""},Ce={class:"jldocstring custom-block",open:""},Te={class:"jldocstring custom-block",open:""},Fe={class:"jldocstring custom-block",open:""},Ae={class:"jldocstring custom-block",open:""},Je={class:"jldocstring custom-block",open:""},xe={class:"jldocstring custom-block",open:""},De={class:"jldocstring custom-block",open:""},Se={class:"jldocstring custom-block",open:""},Me={class:"jldocstring custom-block",open:""},Be={class:"jldocstring custom-block",open:""},Le={class:"jldocstring custom-block",open:""},Ve={class:"jldocstring custom-block",open:""},we={class:"jldocstring custom-block",open:""},Pe={class:"jldocstring custom-block",open:""},Ie={class:"jldocstring custom-block",open:""},Oe={class:"jldocstring custom-block",open:""},Ne={class:"jldocstring custom-block",open:""},Re={class:"jldocstring custom-block",open:""},qe={class:"jldocstring custom-block",open:""},ze={class:"jldocstring custom-block",open:""},Ge={class:"jldocstring custom-block",open:""},Ue={class:"jldocstring custom-block",open:""},We={class:"jldocstring custom-block",open:""},He={class:"jldocstring custom-block",open:""},Ke={class:"jldocstring custom-block",open:""},Ye={class:"jldocstring custom-block",open:""},$e={class:"jldocstring custom-block",open:""},Ze={class:"jldocstring custom-block",open:""},Xe={class:"jldocstring custom-block",open:""},Qe={class:"jldocstring custom-block",open:""},sl={class:"jldocstring custom-block",open:""},il={class:"jldocstring custom-block",open:""};function tl(el,s,ll,al,nl,ol){const t=r("Badge");return u(),p("div",null,[s[1052]||(s[1052]=n('<h1 id="Documentation-from-Jutul.jl" tabindex="-1">Documentation from Jutul.jl <a class="header-anchor" href="#Documentation-from-Jutul.jl" aria-label="Permalink to &quot;Documentation from Jutul.jl {#Documentation-from-Jutul.jl}&quot;">​</a></h1><p><code>JutulDarcy.jl</code> builds upon <code>Jutul.jl</code>, which takes care of the heavy lifting in terms of meshes, discretizations and solvers. You can use <code>JutulDarcy.jl</code> without knowing the inner workings of <code>Jutul.jl</code>, but if you want to dive under the hood the <a href="https://sintefmath.github.io/Jutul.jl/dev/" target="_blank" rel="noreferrer">Jutul.jl manual</a> and <a href="https://sintefmath.github.io/Jutul.jl/dev/docstrings/" target="_blank" rel="noreferrer">Jutul.jl docstrings</a> may be useful.</p><p>We include the docstrings here for your convenience:</p>',3)),i("details",h,[i("summary",null,[s[0]||(s[0]=i("a",{id:"Jutul.AMGPreconditioner",href:"#Jutul.AMGPreconditioner"},[i("span",{class:"jlbinding"},"Jutul.AMGPreconditioner")],-1)),s[1]||(s[1]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[3]||(s[3]=i("p",null,"AMG on CPU (Julia native)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[2]||(s[2]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/precond/amg.jl#L2-L4",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",k,[i("summary",null,[s[4]||(s[4]=i("a",{id:"Jutul.AbstractGlobalObjective",href:"#Jutul.AbstractGlobalObjective"},[i("span",{class:"jlbinding"},"Jutul.AbstractGlobalObjective")],-1)),s[5]||(s[5]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[7]||(s[7]=n('<p>Abstract type for objective as a global objective function on the form:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>F(model, state0, states, step_infos, forces, input_data)</span></span></code></pre></div><p>Note that if substeps are enabled by setting <code>output_substates=true</code> in the simulator setup, the length of forces and states will be dynamic and of equal length to <code>step_infos</code>. If you want to recover the state at a specific step, you can reason about <code>:step</code> field of the corresponding entry in the <code>step_infos</code> array.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[6]||(s[6]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L1487-L1497",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",g,[i("summary",null,[s[8]||(s[8]=i("a",{id:"Jutul.AbstractJutulObjective",href:"#Jutul.AbstractJutulObjective"},[i("span",{class:"jlbinding"},"Jutul.AbstractJutulObjective")],-1)),s[9]||(s[9]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[11]||(s[11]=i("p",null,"Abstract type for Jutul objectives.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[10]||(s[10]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L1472-L1474",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",y,[i("summary",null,[s[12]||(s[12]=i("a",{id:"Jutul.AbstractSumObjective",href:"#Jutul.AbstractSumObjective"},[i("span",{class:"jlbinding"},"Jutul.AbstractSumObjective")],-1)),s[13]||(s[13]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[15]||(s[15]=n('<p>Abstract type for objective as a sum of function values on the form:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>F(model, state, dt, step_info, forces)</span></span></code></pre></div><p>evaluated for each step. This means that the objective is a sum of all of these values. If you want to only depend on a single step, you can look up</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[14]||(s[14]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L1477-L1484",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",c,[i("summary",null,[s[16]||(s[16]=i("a",{id:"Jutul.BlockMajorLayout",href:"#Jutul.BlockMajorLayout"},[i("span",{class:"jlbinding"},"Jutul.BlockMajorLayout")],-1)),s[17]||(s[17]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[19]||(s[19]=i("p",null,[l("Same as "),i("a",{href:"/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.EntityMajorLayout"},[i("code",null,"EntityMajorLayout")]),l(", but the system is a sparse matrix where each entry is a small dense matrix.")],-1)),s[20]||(s[20]=i("p",null,"For a test system with primary variables P, S and equations E1, E2 and two cells this will give a diagonal of length 2: [(∂E1/∂p)₁ (∂E1/∂S)₁ ; (∂E2/∂p)₁ (∂E2/∂S)₁] [(∂E1/∂p)₂ (∂E1/∂S)₂ ; (∂E2/∂p)₂ (∂E2/∂S)₂]",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[18]||(s[18]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L131-L139",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",b,[i("summary",null,[s[21]||(s[21]=i("a",{id:"Jutul.BoundaryFaces",href:"#Jutul.BoundaryFaces"},[i("span",{class:"jlbinding"},"Jutul.BoundaryFaces")],-1)),s[22]||(s[22]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[24]||(s[24]=i("p",null,[l("Entity for faces on the boundary (faces that are only connected to a single "),i("a",{href:"/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.Cells"},[i("code",null,"Cells")]),l(")")],-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[23]||(s[23]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L490-L492",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",m,[i("summary",null,[s[25]||(s[25]=i("a",{id:"Jutul.CartesianMesh",href:"#Jutul.CartesianMesh"},[i("span",{class:"jlbinding"},"Jutul.CartesianMesh")],-1)),s[26]||(s[26]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[28]||(s[28]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dims, [Δ, [origin]])</span></span></code></pre></div><p>Create a Cartesian mesh with dimensions specified by the <code>Tuple</code> <code>dims</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>dims::Tuple</code>: Number of grid cells in each direction. For example, <code>(nx, ny)</code> will give a 2D grids with <code>nx</code> cells in the x-direction.</p></li><li><p><code>Δ::Tuple=Tuple(ones(length(dims)))</code>: Equal length to <code>dims</code>. First option: A</p></li></ul><p><code>Tuple</code> of scalars where each entry is the length of each cell in that direction. For example, specifying <code>(Δx, Δy) for a uniform grid with each grid cell having area of</code>Δx*Δy<code>. Second option: A</code>Tuple\` of vectors where each entry contains the cell sizes in the direction.</p><ul><li><code>origin=zeros(length(dims))</code>: The origin of the first corner in the grid.</li></ul><p><strong>Examples</strong></p><p>Generate a uniform 3D mesh that discretizes a domain of 2 by 3 by 5 units with 3 by 5 by 2 cells:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CartesianMesh (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D) with </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x5x2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cells</span></span></code></pre></div><p>Generate a non-uniform 2D mesh:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), ([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CartesianMesh (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D) with </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x3x1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cells</span></span></code></pre></div>`,11)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[27]||(s[27]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/cart.jl#L3-L29",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",E,[i("summary",null,[s[29]||(s[29]=i("a",{id:"Jutul.Cells",href:"#Jutul.Cells"},[i("span",{class:"jlbinding"},"Jutul.Cells")],-1)),s[30]||(s[30]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[32]||(s[32]=i("p",null,"Entity for Cells (closed volumes with averaged properties for a finite-volume solver)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[31]||(s[31]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L480-L482",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",f,[i("summary",null,[s[33]||(s[33]=i("a",{id:"Jutul.CoarseMesh-Tuple{Any, Any}",href:"#Jutul.CoarseMesh-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.CoarseMesh")],-1)),s[34]||(s[34]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[36]||(s[36]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoarseMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p)</span></span></code></pre></div><p>Construct a coarse mesh from a given <code>JutulMesh</code> that can be converted to an <code>UnstructuredMesh</code> instance. The second argument <code>p</code> should be a partition Vector with one entry per cell in the original grid that assigns that cell to a coarse block. Should be one-indexed and the numbering should be sequential and contain at least one fine cell for each coarse index. This is tested by the function.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[35]||(s[35]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/coarse.jl#L14-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_,[i("summary",null,[s[37]||(s[37]=i("a",{id:"Jutul.CompactAutoDiffCache",href:"#Jutul.CompactAutoDiffCache"},[i("span",{class:"jlbinding"},"Jutul.CompactAutoDiffCache")],-1)),s[38]||(s[38]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[40]||(s[40]=i("p",null,"Cache that holds an AD vector/matrix together with their positions.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[39]||(s[39]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L693-L695",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",j,[i("summary",null,[s[41]||(s[41]=i("a",{id:"Jutul.DataDomain-Tuple{JutulDomain}",href:"#Jutul.DataDomain-Tuple{JutulDomain}"},[i("span",{class:"jlbinding"},"Jutul.DataDomain")],-1)),s[42]||(s[42]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[44]||(s[44]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; property1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1, property2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A wrapper around a domain that allows for storing of entity-associated data.</p><p>Example:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Grid with 6 cells and 7 interior faces</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cell_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#ok, same as:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cell_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#ok</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cell_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Faces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#not ok!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:face_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Faces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#ok!</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Can also add general arrays if last dimension == entity dimension</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cell_vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#ok</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Can add general data too, but needs to be specified</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:not_on_face_or_cell</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># also ok</span></span></code></pre></div>`,4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[43]||(s[43]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/domains.jl#L119-L138",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",v,[i("summary",null,[s[45]||(s[45]=i("a",{id:"Jutul.DefaultContext",href:"#Jutul.DefaultContext"},[i("span",{class:"jlbinding"},"Jutul.DefaultContext")],-1)),s[46]||(s[46]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[48]||(s[48]=i("p",null,"Default context",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[47]||(s[47]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/contexts/default.jl#L2",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",C,[i("summary",null,[s[49]||(s[49]=i("a",{id:"Jutul.DiscretizedDomain",href:"#Jutul.DiscretizedDomain"},[i("span",{class:"jlbinding"},"Jutul.DiscretizedDomain")],-1)),s[50]||(s[50]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[52]||(s[52]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiscretizedDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain, disc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A type for a discretized domain of some other domain or mesh. May contain one or more discretizations as-needed to write equations.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[51]||(s[51]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/domains.jl#L40-L45",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",T,[i("summary",null,[s[53]||(s[53]=i("a",{id:"Jutul.EntityMajorLayout",href:"#Jutul.EntityMajorLayout"},[i("span",{class:"jlbinding"},"Jutul.EntityMajorLayout")],-1)),s[54]||(s[54]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[56]||(s[56]=i("p",null,"Equations are grouped by entity, listing all equations and derivatives for entity 1 before proceeding to entity 2 etc.",-1)),s[57]||(s[57]=i("p",null,"For a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E2/∂S)₁, (∂E1/∂p)₂, (∂E2/∂S)₂",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[55]||(s[55]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L115-L122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",F,[i("summary",null,[s[58]||(s[58]=i("a",{id:"Jutul.EquationMajorLayout",href:"#Jutul.EquationMajorLayout"},[i("span",{class:"jlbinding"},"Jutul.EquationMajorLayout")],-1)),s[59]||(s[59]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[61]||(s[61]=i("p",null,"Equations are stored sequentially in rows, derivatives of same type in columns:",-1)),s[62]||(s[62]=i("p",null,"For a test system with primary variables P, S and equations E1, E2 and two cells this will give the following ordering on the diagonal: (∂E1/∂p)₁, (∂E1/∂p)₂, (∂E2/∂S)₁, (∂E2/∂S)₂",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[60]||(s[60]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L102-L108",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",A,[i("summary",null,[s[63]||(s[63]=i("a",{id:"Jutul.EquationSet",href:"#Jutul.EquationSet"},[i("span",{class:"jlbinding"},"Jutul.EquationSet")],-1)),s[64]||(s[64]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[66]||(s[66]=i("p",null,"Set of a variable where equations are defined",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[65]||(s[65]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/dd.jl#L9",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",J,[i("summary",null,[s[67]||(s[67]=i("a",{id:"Jutul.FaceMap",href:"#Jutul.FaceMap"},[i("span",{class:"jlbinding"},"Jutul.FaceMap")],-1)),s[68]||(s[68]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[70]||(s[70]=i("p",null,"Struct that contains mappings for a set of faces that are made up of nodes and are part of cells.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[69]||(s[69]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/unstructured/types.jl#L1-L4",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",x,[i("summary",null,[s[71]||(s[71]=i("a",{id:"Jutul.Faces",href:"#Jutul.Faces"},[i("span",{class:"jlbinding"},"Jutul.Faces")],-1)),s[72]||(s[72]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[74]||(s[74]=i("p",null,[l("Entity for Faces (intersection between pairs of "),i("a",{href:"/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.Cells"},[i("code",null,"Cells")]),l(")")],-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[73]||(s[73]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L485-L487",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",D,[i("summary",null,[s[75]||(s[75]=i("a",{id:"Jutul.FlowDiscretization",href:"#Jutul.FlowDiscretization"},[i("span",{class:"jlbinding"},"Jutul.FlowDiscretization")],-1)),s[76]||(s[76]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[78]||(s[78]=i("p",null,"Discretization of kgradp + upwind",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[77]||(s[77]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L792",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",S,[i("summary",null,[s[79]||(s[79]=i("a",{id:"Jutul.FractionVariables",href:"#Jutul.FractionVariables"},[i("span",{class:"jlbinding"},"Jutul.FractionVariables")],-1)),s[80]||(s[80]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[82]||(s[82]=i("p",null,"Abstract type for fraction variables (vector variables that sum up to unity over each entity).",-1)),s[83]||(s[83]=i("p",null,[l("By default, these are limited to the [0, 1] range through "),i("a",{href:"/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.maximum_value-Tuple{JutulVariables}"},[i("code",null,"maximum_value")]),l(" and "),i("a",{href:"/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.minimum_value-Tuple{JutulVariables}"},[i("code",null,"minimum_value")]),l(" default implementations.")],-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[81]||(s[81]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L69-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",M,[i("summary",null,[s[84]||(s[84]=i("a",{id:"Jutul.GenericKrylov",href:"#Jutul.GenericKrylov"},[i("span",{class:"jlbinding"},"Jutul.GenericKrylov")],-1)),s[85]||(s[85]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[87]||(s[87]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GenericKrylov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(solver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :gmres</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; preconditioner </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Solver that wraps <code>Krylov.jl</code> with support for preconditioning.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[86]||(s[86]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/krylov.jl#L29-L33",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",B,[i("summary",null,[s[88]||(s[88]=i("a",{id:"Jutul.GlobalSet",href:"#Jutul.GlobalSet"},[i("span",{class:"jlbinding"},"Jutul.GlobalSet")],-1)),s[89]||(s[89]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[91]||(s[91]=i("p",null,"The global set of variables",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[90]||(s[90]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/dd.jl#L3",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",L,[i("summary",null,[s[92]||(s[92]=i("a",{id:"Jutul.GroupWisePreconditioner",href:"#Jutul.GroupWisePreconditioner"},[i("span",{class:"jlbinding"},"Jutul.GroupWisePreconditioner")],-1)),s[93]||(s[93]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[95]||(s[95]=i("p",null,"Multi-model preconditioners",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[94]||(s[94]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/precond/various.jl#L58-L60",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",V,[i("summary",null,[s[96]||(s[96]=i("a",{id:"Jutul.HalfFaces",href:"#Jutul.HalfFaces"},[i("span",{class:"jlbinding"},"Jutul.HalfFaces")],-1)),s[97]||(s[97]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[99]||(s[99]=i("p",null,[l("Entity for half-faces (face associated with a single "),i("a",{href:"/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.Cells"},[i("code",null,"Cells")]),l(")")],-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[98]||(s[98]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L495-L497",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",w,[i("summary",null,[s[100]||(s[100]=i("a",{id:"Jutul.HelperSimulator-Union{Tuple{E}, Tuple{M}, Tuple{M, Any}} where {M, E}",href:"#Jutul.HelperSimulator-Union{Tuple{E}, Tuple{M}, Tuple{M, Any}} where {M, E}"},[i("span",{class:"jlbinding"},"Jutul.HelperSimulator")],-1)),s[101]||(s[101]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[103]||(s[103]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HelperSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">M</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float64; state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model), executor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">E</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Jutul</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">default_executor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {M, E}</span></span></code></pre></div><p>Construct a helper simulator that can be used to compute the residuals and/or accumulation terms for a given type T. Useful for coupling Jutul to other solvers and types of automatic differentiation.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[102]||(s[102]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/helper.jl#L9-L15",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",P,[i("summary",null,[s[104]||(s[104]=i("a",{id:"Jutul.ILUZeroPreconditioner",href:"#Jutul.ILUZeroPreconditioner"},[i("span",{class:"jlbinding"},"Jutul.ILUZeroPreconditioner")],-1)),s[105]||(s[105]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[107]||(s[107]=i("p",null,"ILU(0) preconditioner on CPU",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[106]||(s[106]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/precond/ilu.jl#L1-L3",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",I,[i("summary",null,[s[108]||(s[108]=i("a",{id:"Jutul.IndirectionMap",href:"#Jutul.IndirectionMap"},[i("span",{class:"jlbinding"},"Jutul.IndirectionMap")],-1)),s[109]||(s[109]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[111]||(s[111]=n("<p>IndirectionMap(vals::Vector{V}, pos::Vector{Int}) where V</p><p>Create a indirection map that encodes a variable length dense vector.</p><p><code>pos</code> is assumed to be a Vector{Int} of length n+1 where n is the number of dense vectors that is encoded. The <code>vals</code> array holds the entries for vector i in the range <code>pos[i]:(pos[i+1]-1)</code> for fast lookup. Indexing into the indirection map with index <code>k</code> will give a view into the values for vector <code>k</code>.</p>",3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[110]||(s[110]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L1102-L1111",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",O,[i("summary",null,[s[112]||(s[112]=i("a",{id:"Jutul.IndirectionMap-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T",href:"#Jutul.IndirectionMap-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T"},[i("span",{class:"jlbinding"},"Jutul.IndirectionMap")],-1)),s[113]||(s[113]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[115]||(s[115]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">imap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> IndirectionMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vec_of_vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{V}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> V</span></span></code></pre></div><p>Create indirection map for a variable length dense vector that is represented as a Vector of Vectors.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[114]||(s[114]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L1123-L1128",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",N,[i("summary",null,[s[116]||(s[116]=i("a",{id:"Jutul.JacobiPreconditioner",href:"#Jutul.JacobiPreconditioner"},[i("span",{class:"jlbinding"},"Jutul.JacobiPreconditioner")],-1)),s[117]||(s[117]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[119]||(s[119]=i("p",null,"Damped Jacobi preconditioner on CPU",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[118]||(s[118]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/precond/jacobi.jl#L2-L4",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",R,[i("summary",null,[s[120]||(s[120]=i("a",{id:"Jutul.JutulAutoDiffCache",href:"#Jutul.JutulAutoDiffCache"},[i("span",{class:"jlbinding"},"Jutul.JutulAutoDiffCache")],-1)),s[121]||(s[121]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[123]||(s[123]=i("p",null,"An AutoDiffCache is a type that holds both a set of AD values and a map into some global Jacobian.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[122]||(s[122]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L688-L691",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",q,[i("summary",null,[s[124]||(s[124]=i("a",{id:"Jutul.JutulCase",href:"#Jutul.JutulCase"},[i("span",{class:"jlbinding"},"Jutul.JutulCase")],-1)),s[125]||(s[125]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[127]||(s[127]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model); state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up a structure that holds the complete specification of a simulation case.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[126]||(s[126]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L870-L874",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",z,[i("summary",null,[s[128]||(s[128]=i("a",{id:"Jutul.JutulConfig",href:"#Jutul.JutulConfig"},[i("span",{class:"jlbinding"},"Jutul.JutulConfig")],-1)),s[129]||(s[129]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[131]||(s[131]=i("p",null,"JutulConfig(name = nothing)",-1)),s[132]||(s[132]=i("p",null,[l("A configuration object that acts like a "),i("code",null,"Dict{Symbol,Any}"),l(" but contains additional data to limit the valid keys and values to those added by "),i("a",{href:"/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.add_option!"},[i("code",null,"add_option!")])],-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[130]||(s[130]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/types.jl#L104-L109",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",G,[i("summary",null,[s[133]||(s[133]=i("a",{id:"Jutul.JutulContext",href:"#Jutul.JutulContext"},[i("span",{class:"jlbinding"},"Jutul.JutulContext")],-1)),s[134]||(s[134]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[136]||(s[136]=i("p",null,"Abstract type for the context Jutul should execute in (matrix formats, memory allocation, etc.)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[135]||(s[135]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L83-L85",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",U,[i("summary",null,[s[137]||(s[137]=i("a",{id:"Jutul.JutulDiscretization",href:"#Jutul.JutulDiscretization"},[i("span",{class:"jlbinding"},"Jutul.JutulDiscretization")],-1)),s[138]||(s[138]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[140]||(s[140]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> disc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Ask discretization for entry <code>i</code> when discretizing some equation on the chosen entity (e.g. <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.Cells"><code>Cells</code></a>)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[139]||(s[139]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L26-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",W,[i("summary",null,[s[141]||(s[141]=i("a",{id:"Jutul.JutulDiscretization-2",href:"#Jutul.JutulDiscretization-2"},[i("span",{class:"jlbinding"},"Jutul.JutulDiscretization")],-1)),s[142]||(s[142]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[144]||(s[144]=i("p",null,"Abstract type for a Jutul discretization",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[143]||(s[143]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L21-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",H,[i("summary",null,[s[145]||(s[145]=i("a",{id:"Jutul.JutulDomain",href:"#Jutul.JutulDomain"},[i("span",{class:"jlbinding"},"Jutul.JutulDomain")],-1)),s[146]||(s[146]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[148]||(s[148]=i("p",null,"Abstract type for domains where equations can be defined",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[147]||(s[147]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/domains.jl#L1-L3",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",K,[i("summary",null,[s[149]||(s[149]=i("a",{id:"Jutul.JutulEntity",href:"#Jutul.JutulEntity"},[i("span",{class:"jlbinding"},"Jutul.JutulEntity")],-1)),s[150]||(s[150]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[152]||(s[152]=i("p",null,[l("Super-type for all entities where "),i("a",{href:"/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.JutulVariables"},[i("code",null,"JutulVariables")]),l(" can be defined.")],-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[151]||(s[151]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L475-L477",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Y,[i("summary",null,[s[153]||(s[153]=i("a",{id:"Jutul.JutulEquation",href:"#Jutul.JutulEquation"},[i("span",{class:"jlbinding"},"Jutul.JutulEquation")],-1)),s[154]||(s[154]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[156]||(s[156]=i("p",null,"Abstract type for all residual equations",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[155]||(s[155]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L229-L231",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",$,[i("summary",null,[s[157]||(s[157]=i("a",{id:"Jutul.JutulForce",href:"#Jutul.JutulForce"},[i("span",{class:"jlbinding"},"Jutul.JutulForce")],-1)),s[158]||(s[158]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[160]||(s[160]=i("p",null,"Abstract type for driving forces",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[159]||(s[159]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L78-L80",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Z,[i("summary",null,[s[161]||(s[161]=i("a",{id:"Jutul.JutulMatrixLayout",href:"#Jutul.JutulMatrixLayout"},[i("span",{class:"jlbinding"},"Jutul.JutulMatrixLayout")],-1)),s[162]||(s[162]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[164]||(s[164]=i("p",null,"Abstract type for matrix layouts. A layout determines how primary variables and equations are ordered in a sparse matrix representation. Note that this is different from the matrix format itself as it concerns the ordering itself: For example, if all equations for a single cell come in sequence, or if a single equation is given for all entities before the next equation is written.",-1)),s[165]||(s[165]=i("p",null,"Different layouts does not change the solution of the system, but different linear solvers support different layouts.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[163]||(s[163]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L91-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",X,[i("summary",null,[s[166]||(s[166]=i("a",{id:"Jutul.JutulMesh",href:"#Jutul.JutulMesh"},[i("span",{class:"jlbinding"},"Jutul.JutulMesh")],-1)),s[167]||(s[167]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[169]||(s[169]=i("p",null,"A mesh is a type of domain that has been discretized. Abstract subtype.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[168]||(s[168]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L469-L471",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Q,[i("summary",null,[s[170]||(s[170]=i("a",{id:"Jutul.JutulSystem",href:"#Jutul.JutulSystem"},[i("span",{class:"jlbinding"},"Jutul.JutulSystem")],-1)),s[171]||(s[171]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[173]||(s[173]=i("p",null,"Abstract type for the physical system to be solved.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[172]||(s[172]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L16-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ss,[i("summary",null,[s[174]||(s[174]=i("a",{id:"Jutul.JutulVariables",href:"#Jutul.JutulVariables"},[i("span",{class:"jlbinding"},"Jutul.JutulVariables")],-1)),s[175]||(s[175]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[177]||(s[177]=n('<p>Abstract type for all variables in Jutul.</p><p>A variable is associated with a <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.JutulEntity"><code>JutulEntity</code></a> through the <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.associated_entity-Tuple{JutulEquation}"><code>associated_entity</code></a> function. A variable is local to that entity, and cannot depend on other entities. Variables are used by models to define:</p><ul><li><p>primary variables: Sometimes referred to as degrees of freedom, primary unknowns or solution variables</p></li><li><p>parameters: Static quantities that impact the solution</p></li><li><p>secondary variables: Can be computed from a combination of other primary and secondary variables and parameters.</p></li></ul>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[176]||(s[176]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L45-L56",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",is,[i("summary",null,[s[178]||(s[178]=i("a",{id:"Jutul.LUPreconditioner",href:"#Jutul.LUPreconditioner"},[i("span",{class:"jlbinding"},"Jutul.LUPreconditioner")],-1)),s[179]||(s[179]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[181]||(s[181]=i("p",null,"Full LU factorization as preconditioner (intended for smaller subsystems)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[180]||(s[180]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/precond/various.jl#L8-L10",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ts,[i("summary",null,[s[182]||(s[182]=i("a",{id:"Jutul.LUSolver",href:"#Jutul.LUSolver"},[i("span",{class:"jlbinding"},"Jutul.LUSolver")],-1)),s[183]||(s[183]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[185]||(s[185]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LUSolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; reuse_memory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, check </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, max_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Direct solver that calls <code>lu</code> directly. Direct solvers are highly accurate, but are costly in terms of memory usage and execution speed for larger systems.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[184]||(s[184]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/scalar_cpu.jl#L2-L7",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",es,[i("summary",null,[s[186]||(s[186]=i("a",{id:"Jutul.LimitByFailedTimestepSelector",href:"#Jutul.LimitByFailedTimestepSelector"},[i("span",{class:"jlbinding"},"Jutul.LimitByFailedTimestepSelector")],-1)),s[187]||(s[187]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[189]||(s[189]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LimitByFailedTimestepSelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, factor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Limit the timestep by the shortest of <code>num</code> failed timesteps, reducing the timestep by <code>factor</code> multiplied by the shortest failed timestep. If no time-steps failed during the last <code>num</code> steps, the timestep is not changed.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[188]||(s[188]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/timesteps.jl#L151-L157",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ls,[i("summary",null,[s[190]||(s[190]=i("a",{id:"Jutul.MRSTWrapMesh",href:"#Jutul.MRSTWrapMesh"},[i("span",{class:"jlbinding"},"Jutul.MRSTWrapMesh")],-1)),s[191]||(s[191]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[193]||(s[193]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MRSTWrapMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G, N </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Mesh that adapts an exported MRST mesh to the Jutul interface. <code>G</code> is assumed to be read directly from file using <code>MAT.matread</code>. The raw exported grid can be found under the <code>data</code> field.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[192]||(s[192]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/mrst.jl#L9-L15",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",as,[i("summary",null,[s[194]||(s[194]=i("a",{id:"Jutul.MultiModel",href:"#Jutul.MultiModel"},[i("span",{class:"jlbinding"},"Jutul.MultiModel")],-1)),s[195]||(s[195]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[197]||(s[197]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MultiModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(models)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MultiModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(models, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:SomeLabel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A model variant that is made up of many named submodels, each a fully realized <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.SimulationModel-Tuple{Any, Any}"><code>SimulationModel</code></a>.</p><p><code>models</code> should be a <code>NamedTuple</code> or <code>Dict{Symbol, JutulModel}</code>.</p>`,3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[196]||(s[196]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L983-L990",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ns,[i("summary",null,[s[198]||(s[198]=i("a",{id:"Jutul.NoEntity",href:"#Jutul.NoEntity"},[i("span",{class:"jlbinding"},"Jutul.NoEntity")],-1)),s[199]||(s[199]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[201]||(s[201]=i("p",null,"An entity for something that isn't associated with an entity",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[200]||(s[200]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L505-L507",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",os,[i("summary",null,[s[202]||(s[202]=i("a",{id:"Jutul.Nodes",href:"#Jutul.Nodes"},[i("span",{class:"jlbinding"},"Jutul.Nodes")],-1)),s[203]||(s[203]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[205]||(s[205]=i("p",null,[l("Entity for Nodes (intersection between multiple "),i("a",{href:"/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.Faces"},[i("code",null,"Faces")]),l(")")],-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[204]||(s[204]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L500-L502",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",rs,[i("summary",null,[s[206]||(s[206]=i("a",{id:"Jutul.ParallelCSRContext",href:"#Jutul.ParallelCSRContext"},[i("span",{class:"jlbinding"},"Jutul.ParallelCSRContext")],-1)),s[207]||(s[207]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[209]||(s[209]=i("p",null,"A context that uses a CSR sparse matrix format together with threads. Experimental.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[208]||(s[208]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/contexts/csr.jl#L2",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ps,[i("summary",null,[s[210]||(s[210]=i("a",{id:"Jutul.SPAI0Preconditioner",href:"#Jutul.SPAI0Preconditioner"},[i("span",{class:"jlbinding"},"Jutul.SPAI0Preconditioner")],-1)),s[211]||(s[211]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[213]||(s[213]=i("p",null,"Sparse Approximate Inverse preconditioner of lowest order – SPAI(0)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[212]||(s[212]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/precond/spai.jl#L1-L3",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",us,[i("summary",null,[s[214]||(s[214]=i("a",{id:"Jutul.SPU",href:"#Jutul.SPU"},[i("span",{class:"jlbinding"},"Jutul.SPU")],-1)),s[215]||(s[215]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[217]||(s[217]=i("p",null,"Single-point upwinding.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[216]||(s[216]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/conservation/flux.jl#L31-L33",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ds,[i("summary",null,[s[218]||(s[218]=i("a",{id:"Jutul.ScalarVariable",href:"#Jutul.ScalarVariable"},[i("span",{class:"jlbinding"},"Jutul.ScalarVariable")],-1)),s[219]||(s[219]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[221]||(s[221]=i("p",null,"Abstract type for scalar variables (one entry per entity, e.g. pressure or temperature in each cell of a model)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[220]||(s[220]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L59-L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",hs,[i("summary",null,[s[222]||(s[222]=i("a",{id:"Jutul.SimulationModel-Tuple{Any, Any}",href:"#Jutul.SimulationModel-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.SimulationModel")],-1)),s[223]||(s[223]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[225]||(s[225]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain, system; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Instantiate a model for a given <code>system</code> discretized on the <code>domain</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[224]||(s[224]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L259-L263",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ks,[i("summary",null,[s[226]||(s[226]=i("a",{id:"Jutul.SimulationModel-Tuple{JutulMesh, Any}",href:"#Jutul.SimulationModel-Tuple{JutulMesh, Any}"},[i("span",{class:"jlbinding"},"Jutul.SimulationModel")],-1)),s[227]||(s[227]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[229]||(s[229]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, system; discretization </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Type that defines a simulation model - everything needed to solve the discrete equations.</p><p>The minimal setup requires a <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.JutulMesh"><code>JutulMesh</code></a> that defines topology together with a <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.JutulSystem"><code>JutulSystem</code></a> that imposes physical laws.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[228]||(s[228]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L513-L521",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",gs,[i("summary",null,[s[230]||(s[230]=i("a",{id:"Jutul.Simulator-Tuple{Any}",href:"#Jutul.Simulator-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.Simulator")],-1)),s[231]||(s[231]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[233]||(s[233]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Simulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up a simulator object for a <code>model</code> that can be used by <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>. To avoid manually instantiating the simulator, the non-mutating <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}"><code>simulate</code></a> interface can be used instead.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[232]||(s[232]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/types.jl#L19-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ys,[i("summary",null,[s[234]||(s[234]=i("a",{id:"Jutul.SparsityTracingWrapper-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}",href:"#Jutul.SparsityTracingWrapper-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"},[i("span",{class:"jlbinding"},"Jutul.SparsityTracingWrapper")],-1)),s[235]||(s[235]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[237]||(s[237]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SparsityTracingWrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{T, N}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T, N}</span></span></code></pre></div><p>Create a sparsity tracing wrapper for a numeric array. This wrapped array produces outputs that have the same value as the wrapped type, but contains a SparsityTracing seeded value with seed equal to the column index (if matrix) or linear index (if vector).</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[236]||(s[236]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/sparsity.jl#L36-L43",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",cs,[i("summary",null,[s[238]||(s[238]=i("a",{id:"Jutul.TPFA",href:"#Jutul.TPFA"},[i("span",{class:"jlbinding"},"Jutul.TPFA")],-1)),s[239]||(s[239]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[241]||(s[241]=i("p",null,"Two-point flux approximation.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[240]||(s[240]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/conservation/flux.jl#L12-L14",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",bs,[i("summary",null,[s[242]||(s[242]=i("a",{id:"Jutul.TwoPointFiniteVolumeGeometry",href:"#Jutul.TwoPointFiniteVolumeGeometry"},[i("span",{class:"jlbinding"},"Jutul.TwoPointFiniteVolumeGeometry")],-1)),s[243]||(s[243]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[245]||(s[245]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TwoPointFiniteVolumeGeometry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(neighbors, areas, volumes, normals, cell_centers, face_centers)</span></span></code></pre></div><p>Store two-point geometry information for a given list of <code>neighbors</code> specified as a <code>2</code> by <code>n</code> matrix where <code>n</code> is the number of faces such that face <code>i</code> connectes cells <code>N[1, i]</code> and <code>N[2, i]</code>.</p><p>The two-point finite-volume geometry contains the minimal set of geometry information required to compute standard finite-volume discretizations.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[244]||(s[244]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/meshes.jl#L19-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ms,[i("summary",null,[s[246]||(s[246]=i("a",{id:"Jutul.UnstructuredMesh-Tuple{CartesianMesh}",href:"#Jutul.UnstructuredMesh-Tuple{CartesianMesh}"},[i("span",{class:"jlbinding"},"Jutul.UnstructuredMesh")],-1)),s[247]||(s[247]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[249]||(s[249]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnstructuredMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert <code>CartesianMesh</code> instance to unstructured grid. Note that the mesh must be 2D and 3D for a 1-to-1 conversion. 1D meshes are implicitly converted to 2D.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[248]||(s[248]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/unstructured/types.jl#L293-L298",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Es,[i("summary",null,[s[250]||(s[250]=i("a",{id:"Jutul.VariableSet",href:"#Jutul.VariableSet"},[i("span",{class:"jlbinding"},"Jutul.VariableSet")],-1)),s[251]||(s[251]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[253]||(s[253]=i("p",null,"Set of a variable where variables are defined",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[252]||(s[252]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/dd.jl#L6",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",fs,[i("summary",null,[s[254]||(s[254]=i("a",{id:"Jutul.VectorVariables",href:"#Jutul.VectorVariables"},[i("span",{class:"jlbinding"},"Jutul.VectorVariables")],-1)),s[255]||(s[255]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[257]||(s[257]=i("p",null,"Abstract type for vector variables (more than one entry per entity, for example saturations or displacements)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[256]||(s[256]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L64-L67",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_s,[i("summary",null,[s[258]||(s[258]=i("a",{id:"Jutul.WrappedGlobalObjective",href:"#Jutul.WrappedGlobalObjective"},[i("span",{class:"jlbinding"},"Jutul.WrappedGlobalObjective")],-1)),s[259]||(s[259]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[261]||(s[261]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WrappedGlobalObjective</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(objective)</span></span></code></pre></div><p>A global (in time) objective that wraps a function/callable. This type automatically wraps functions/callable structs that are passed to the optimization interface if they have the sum signature (five arguments).</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[260]||(s[260]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L1512-L1518",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",js,[i("summary",null,[s[262]||(s[262]=i("a",{id:"Jutul.WrappedSumObjective",href:"#Jutul.WrappedSumObjective"},[i("span",{class:"jlbinding"},"Jutul.WrappedSumObjective")],-1)),s[263]||(s[263]=l()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[265]||(s[265]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WrappedSumObjective</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(objective)</span></span></code></pre></div><p>An objective that is a sum of function values, evaluated for each step, defined by a function. This type automatically wraps functions/callable structs that are passed to the optimization interface if they have the sum signature (five arguments).</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[264]||(s[264]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L1500-L1507",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",vs,[i("summary",null,[s[266]||(s[266]=i("a",{id:"Jutul.absolute_increment_limit-Tuple{JutulVariables}",href:"#Jutul.absolute_increment_limit-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.absolute_increment_limit")],-1)),s[267]||(s[267]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[269]||(s[269]=i("p",null,"Absolute allowable change for variable during a nonlinear update.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[268]||(s[268]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L86-L88",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Cs,[i("summary",null,[s[270]||(s[270]=i("a",{id:"Jutul.add_option!",href:"#Jutul.add_option!"},[i("span",{class:"jlbinding"},"Jutul.add_option!")],-1)),s[271]||(s[271]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[273]||(s[273]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_option!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opts</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:my_cool_option</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My option has this brief description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add an option to existing <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.JutulConfig"><code>JutulConfig</code></a> structure. Additional currently undocumented keyword arguments can be used to restrict valid types and values.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[272]||(s[272]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/config.jl#L3-L8",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ts,[i("summary",null,[s[274]||(s[274]=i("a",{id:"Jutul.align_to_jacobian!-NTuple{4, Any}",href:"#Jutul.align_to_jacobian!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.align_to_jacobian!")],-1)),s[275]||(s[275]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[277]||(s[277]=i("p",null,"Update an equation so that it knows where to store its derivatives in the Jacobian representation.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[276]||(s[276]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L429-L432",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Fs,[i("summary",null,[s[278]||(s[278]=i("a",{id:"Jutul.align_to_jacobian!-Tuple{ConservationLawTPFAStorage, ConservationLaw, Any, Any, Cells}",href:"#Jutul.align_to_jacobian!-Tuple{ConservationLawTPFAStorage, ConservationLaw, Any, Any, Cells}"},[i("span",{class:"jlbinding"},"Jutul.align_to_jacobian!")],-1)),s[279]||(s[279]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[281]||(s[281]=i("p",null,"Update positions of law's derivatives in global Jacobian",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[280]||(s[280]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/conservation/conservation.jl#L142",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",As,[i("summary",null,[s[282]||(s[282]=i("a",{id:"Jutul.allocate_array_ad-Tuple{AbstractMatrix}",href:"#Jutul.allocate_array_ad-Tuple{AbstractMatrix}"},[i("span",{class:"jlbinding"},"Jutul.allocate_array_ad")],-1)),s[283]||(s[283]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[285]||(s[285]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert matrix to AD matrix.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[284]||(s[284]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L347-L350",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Js,[i("summary",null,[s[286]||(s[286]=i("a",{id:"Jutul.allocate_array_ad-Tuple{AbstractVector}",href:"#Jutul.allocate_array_ad-Tuple{AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.allocate_array_ad")],-1)),s[287]||(s[287]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[289]||(s[289]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert vector to AD vector.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[288]||(s[288]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L336-L339",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",xs,[i("summary",null,[s[290]||(s[290]=i("a",{id:"Jutul.allocate_array_ad-Union{Tuple{Vararg{R}}, Tuple{R}} where R<:Integer",href:"#Jutul.allocate_array_ad-Union{Tuple{Vararg{R}}, Tuple{R}} where R<:Integer"},[i("span",{class:"jlbinding"},"Jutul.allocate_array_ad")],-1)),s[291]||(s[291]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[293]||(s[293]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n[, m]; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Allocate vector or matrix as AD with optionally provided context and a specified non-zero on the diagonal.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Integer</code>: number of entries in vector, or number of rows if <code>m</code> is given.</p></li><li><p><code>m::Integer</code>: number of rows (optional)</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>npartials = 1</code>: Number of partials derivatives to allocate for each element</p></li><li><p><code>diag_pos = nothing</code>: Indices of where to put entities on the diagonal (if any)</p></li></ul><p>Other keyword arguments are passed onto <code>get_ad_entity_scalar</code>.</p><p><strong>Examples:</strong></p><p>Allocate a vector with a single partial:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element Vector{ForwardDiff</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Dual{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Float64, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Allocate a vector with two partials, and set the first to one:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, diag_pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, npartials </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element Vector{ForwardDiff</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Dual{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Float64, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up a matrix with two partials, where the first column has partials [1, 0] and the second [0, 1]:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> allocate_array_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, diag_pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], npartials </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">×</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Matrix{ForwardDiff</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Dual{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Float64, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dual{nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,14)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[292]||(s[292]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L278-L316",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ds,[i("summary",null,[s[294]||(s[294]=i("a",{id:"Jutul.apply!-Tuple{Any, TrivialPreconditioner, Any, Vararg{Any}}",href:"#Jutul.apply!-Tuple{Any, TrivialPreconditioner, Any, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.apply!")],-1)),s[295]||(s[295]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[297]||(s[297]=i("p",null,"Trivial / identity preconditioner with size for use in subsystems.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[296]||(s[296]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/precond/various.jl#L37-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ss,[i("summary",null,[s[298]||(s[298]=i("a",{id:"Jutul.apply_forces!-NTuple{4, Any}",href:"#Jutul.apply_forces!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.apply_forces!")],-1)),s[299]||(s[299]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[301]||(s[301]=i("p",null,"Apply a set of forces to all equations. Equations that don't support a given force will just ignore them, thanks to the power of multiple dispatch.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[300]||(s[300]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L858-L861",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ms,[i("summary",null,[s[302]||(s[302]=i("a",{id:"Jutul.apply_forces_to_equation!-NTuple{7, Any}",href:"#Jutul.apply_forces_to_equation!-NTuple{7, Any}"},[i("span",{class:"jlbinding"},"Jutul.apply_forces_to_equation!")],-1)),s[303]||(s[303]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[305]||(s[305]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">apply_forces_to_equation!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diag_part, storage, model, eq, eq_s, force, time)</span></span></code></pre></div><p>Update an equation with the effect of a force. The default behavior for any force we do not know about is to assume that the force does not impact this particular equation.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[304]||(s[304]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L577-L583",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Bs,[i("summary",null,[s[306]||(s[306]=i("a",{id:"Jutul.as_value-Tuple{AbstractArray}",href:"#Jutul.as_value-Tuple{AbstractArray}"},[i("span",{class:"jlbinding"},"Jutul.as_value")],-1)),s[307]||(s[307]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[309]||(s[309]=i("p",null,"Create a mapped array that produces only the values when indexed.",-1)),s[310]||(s[310]=i("p",null,"Only useful for AD arrays, otherwise it does nothing.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[308]||(s[308]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L476-L480",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ls,[i("summary",null,[s[311]||(s[311]=i("a",{id:"Jutul.associated_entity-Tuple{JutulEquation}",href:"#Jutul.associated_entity-Tuple{JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.associated_entity")],-1)),s[312]||(s[312]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[314]||(s[314]=i("p",null,"Return the domain entity the equation is associated with",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[313]||(s[313]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L259-L261",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Vs,[i("summary",null,[s[315]||(s[315]=i("a",{id:"Jutul.associated_entity-Tuple{JutulVariables}",href:"#Jutul.associated_entity-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.associated_entity")],-1)),s[316]||(s[316]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[318]||(s[318]=i("p",null,"The entity a variable is associated with, and can hold partial derivatives with respect to.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[317]||(s[317]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L9-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ws,[i("summary",null,[s[319]||(s[319]=i("a",{id:"Jutul.cartesian_partition",href:"#Jutul.cartesian_partition"},[i("span",{class:"jlbinding"},"Jutul.cartesian_partition")],-1)),s[320]||(s[320]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[322]||(s[322]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cartesian_partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, coarse_dims, ptype </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :centroids</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Perform Cartesian partition in centroid or IJK space.</p><p><strong>Examples</strong></p><p>Generate 5x5x5 partition based on points (suitable for unstructured meshes)</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p_pts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Jutul</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cartesian_partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain, (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:centroids</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate 5x5x5 partition based on IJK indices (suitable for logically Cartesian meshes)</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mesh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p_ijk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Jutul</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cartesian_partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domain, (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:ijk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,7)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[321]||(s[321]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/partitioning.jl#L163-L184",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ps,[i("summary",null,[s[323]||(s[323]=i("a",{id:"Jutul.cell_dims-Tuple{Any, Any}",href:"#Jutul.cell_dims-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.cell_dims")],-1)),s[324]||(s[324]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[326]||(s[326]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cell_dims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, pos)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span></span></code></pre></div><p>Get physical cell dimensions of cell with index <code>pos</code> for grid <code>g</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[325]||(s[325]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/cart.jl#L130-L134",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Is,[i("summary",null,[s[327]||(s[327]=i("a",{id:"Jutul.cell_index-Tuple{Any, Tuple}",href:"#Jutul.cell_index-Tuple{Any, Tuple}"},[i("span",{class:"jlbinding"},"Jutul.cell_index")],-1)),s[328]||(s[328]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[330]||(s[330]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cell_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, pos)</span></span></code></pre></div><p>Get linear (scalar) index of mesh cell from provided IJK tuple <code>pos</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[329]||(s[329]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/cart.jl#L108-L112",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Os,[i("summary",null,[s[331]||(s[331]=i("a",{id:"Jutul.cells_inside_bounding_box-Tuple{UnstructuredMesh, Any, Any}",href:"#Jutul.cells_inside_bounding_box-Tuple{UnstructuredMesh, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.cells_inside_bounding_box")],-1)),s[332]||(s[332]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[334]||(s[334]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cells_inside_bounding_box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnstructuredMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, low_bb, high_bb; algorithm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, atol </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>',1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[333]||(s[333]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/trajectories.jl#L252-L256",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ns,[i("summary",null,[s[335]||(s[335]=i("a",{id:"Jutul.check_amgcl_availability-Tuple{}",href:"#Jutul.check_amgcl_availability-Tuple{}"},[i("span",{class:"jlbinding"},"Jutul.check_amgcl_availability")],-1)),s[336]||(s[336]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[338]||(s[338]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_amgcl_availability</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; throw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if AMGCLWrap extension is available. If <code>throw=true</code> this wil be an error, otherwise a Boolean indicating if the extension is available will be returned.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[337]||(s[337]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/amgclwrap_ext.jl#L20-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Rs,[i("summary",null,[s[339]||(s[339]=i("a",{id:"Jutul.check_plotting_availability-Tuple{}",href:"#Jutul.check_plotting_availability-Tuple{}"},[i("span",{class:"jlbinding"},"Jutul.check_plotting_availability")],-1)),s[340]||(s[340]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[342]||(s[342]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">check_plotting_availability</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; throw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, interactive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Check if plotting through at least one <code>Makie</code> backend is available in the Julia session (after package has been loaded by for example <code>using GLMakie</code>). The argument <code>throw</code> can be used to control if this function acts as a programmatic check (<code>throw=false</code>) there the return value indicates availability, or if an error message is to be printed telling the user how to get plotting working (<code>throw=true</code>)</p><p>An additional check for specifically <code>interactive</code> plots can also be added.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[341]||(s[341]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/makie_ext.jl#L141-L152",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",qs,[i("summary",null,[s[343]||(s[343]=i("a",{id:"Jutul.compress_timesteps",href:"#Jutul.compress_timesteps"},[i("span",{class:"jlbinding"},"Jutul.compress_timesteps")],-1)),s[344]||(s[344]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[346]||(s[346]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compress_timesteps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timesteps, forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; max_step </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Inf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compress a set of timesteps and forces to the largest possible steps that still covers the same interval and changes forces at exactly the same points in time, while being limited to a maximum size of <code>max_step</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[345]||(s[345]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/timesteps.jl#L248-L254",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",zs,[i("summary",null,[s[347]||(s[347]=i("a",{id:"Jutul.compress_timesteps-Tuple{JutulCase}",href:"#Jutul.compress_timesteps-Tuple{JutulCase}"},[i("span",{class:"jlbinding"},"Jutul.compress_timesteps")],-1)),s[348]||(s[348]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[350]||(s[350]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compress_timesteps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(case</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; max_step </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Inf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compress time steps for a Jutul case. See <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.compress_timesteps"><code>compress_timesteps</code></a> for the general case.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[349]||(s[349]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/timesteps.jl#L305-L310",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Gs,[i("summary",null,[s[351]||(s[351]=i("a",{id:"Jutul.compute_boundary_trans-Tuple{DataDomain, Any}",href:"#Jutul.compute_boundary_trans-Tuple{DataDomain, Any}"},[i("span",{class:"jlbinding"},"Jutul.compute_boundary_trans")],-1)),s[352]||(s[352]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[354]||(s[354]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_boundary_trans</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, perm)</span></span></code></pre></div><p>Compute the boundary half face transmissibilities for perm. The input <code>perm</code> can either be the symbol of some data defined on <code>Cells()</code>, a vector of numbers for each cell or a matrix with number of columns equal to the number of cells.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[353]||(s[353]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/discretization/finite-volume.jl#L262-L269",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Us,[i("summary",null,[s[355]||(s[355]=i("a",{id:"Jutul.compute_face_trans-Tuple{DataDomain, Vararg{Any}}",href:"#Jutul.compute_face_trans-Tuple{DataDomain, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.compute_face_trans")],-1)),s[356]||(s[356]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[358]||(s[358]=i("p",null,"compute_face_trans(g::DataDomain, perm)",-1)),s[359]||(s[359]=i("p",null,[l("Compute face trans for the interior faces. The input "),i("code",null,"perm"),l(" can either be the symbol of some data defined on "),i("code",null,"Cells()"),l(", a vector of numbers for each cell or a matrix with number of columns equal to the number of cells.")],-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[357]||(s[357]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/discretization/finite-volume.jl#L245-L251",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ws,[i("summary",null,[s[360]||(s[360]=i("a",{id:"Jutul.compute_half_face_trans-Tuple{DataDomain, Any}",href:"#Jutul.compute_half_face_trans-Tuple{DataDomain, Any}"},[i("span",{class:"jlbinding"},"Jutul.compute_half_face_trans")],-1)),s[361]||(s[361]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[363]||(s[363]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_half_face_trans</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, perm)</span></span></code></pre></div><p>Compute half-face trans for the interior faces. The input <code>perm</code> can either be the symbol of some data defined on <code>Cells()</code>, a vector of numbers for each cell or a matrix with number of columns equal to the number of cells.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[362]||(s[362]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/discretization/finite-volume.jl#L8-L14",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Hs,[i("summary",null,[s[364]||(s[364]=i("a",{id:"Jutul.convergence_criterion-Tuple{Any, Any, JutulEquation, Any, Any}",href:"#Jutul.convergence_criterion-Tuple{Any, Any, JutulEquation, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.convergence_criterion")],-1)),s[365]||(s[365]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[367]||(s[367]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">convergence_criterion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, storage, eq, eq_s, r; dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the convergence criterion values for a given equation. Can be checked against the corresponding tolerances.</p><p><strong>Arguments</strong></p><ul><li><p><code>model</code>: model that generated the current equation.</p></li><li><p><code>storage</code>: global simulator storage.</p></li><li><p><code>eq::JutulEquation</code>: equation implementation currently being checked</p></li><li><p><code>eq_s</code>: storage for <code>eq</code> where values are contained.</p></li><li><p><code>r</code>: the local residual part corresponding to this model, as a matrix with column index equaling entity index</p></li></ul>',4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[366]||(s[366]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L588-L599",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ks,[i("summary",null,[s[368]||(s[368]=i("a",{id:"Jutul.convert_from_si-Tuple{Any, String}",href:"#Jutul.convert_from_si-Tuple{Any, String}"},[i("span",{class:"jlbinding"},"Jutul.convert_from_si")],-1)),s[369]||(s[369]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[371]||(s[371]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">convert_from_si</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, unit_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{Symbol, String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert <code>value</code> from SI representation to the unit in <code>unit_symbol</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> convert_from_si</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3600.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:hour</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get 3600 s represented as hours</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span></span></code></pre></div>`,4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[370]||(s[370]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/units/interface.jl#L29-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ys,[i("summary",null,[s[372]||(s[372]=i("a",{id:"Jutul.convert_state_ad",href:"#Jutul.convert_state_ad"},[i("span",{class:"jlbinding"},"Jutul.convert_state_ad")],-1)),s[373]||(s[373]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[375]||(s[375]=i("p",null,"Convert a state containing variables as arrays of doubles to a state where those arrays contain the same value as Dual types. The dual type is currently taken from ForwardDiff.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[374]||(s[374]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L217-L221",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",$s,[i("summary",null,[s[376]||(s[376]=i("a",{id:"Jutul.convert_to_si-Tuple{Any, String}",href:"#Jutul.convert_to_si-Tuple{Any, String}"},[i("span",{class:"jlbinding"},"Jutul.convert_to_si")],-1)),s[377]||(s[377]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[379]||(s[379]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">convert_to_si</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, unit_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert <code>value</code> to SI representation from value in the unit given by <code>unit_symbol</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> convert_to_si</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:hour</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get 1 hour represented as seconds</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3600.0</span></span></code></pre></div>`,4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[378]||(s[378]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/units/interface.jl#L1-L12",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Zs,[i("summary",null,[s[380]||(s[380]=i("a",{id:"Jutul.coord_offset-Tuple{Any, Real}",href:"#Jutul.coord_offset-Tuple{Any, Real}"},[i("span",{class:"jlbinding"},"Jutul.coord_offset")],-1)),s[381]||(s[381]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[383]||(s[383]=i("p",null,"Lower corner for one dimension, without any transforms applied",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[382]||(s[382]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/cart.jl#L102-L104",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Xs,[i("summary",null,[s[384]||(s[384]=i("a",{id:"Jutul.data_domain_to_parameters_gradient-Tuple{Any, Any}",href:"#Jutul.data_domain_to_parameters_gradient-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.data_domain_to_parameters_gradient")],-1)),s[385]||(s[385]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[387]||(s[387]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data_domain_to_parameters_gradient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, parameter_gradient; dp_dd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Make a data_domain copy that contains the gradient of some objective with respect to the fields in the data_domain, assuming that the parameters were initialized directly from the data_domain via (<code>setup_parameters</code>)[@ref].</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[386]||(s[386]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/vectorization.jl#L287-L293",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Qs,[i("summary",null,[s[388]||(s[388]=i("a",{id:"Jutul.declare_pattern-Tuple{Any, Any, Any, Any, Vararg{Any}}",href:"#Jutul.declare_pattern-Tuple{Any, Any, Any, Any, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.declare_pattern")],-1)),s[389]||(s[389]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[391]||(s[391]=i("p",null,"Give out source, target arrays of equal length for a given equation attached to the given model.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[390]||(s[390]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L395-L398",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",si,[i("summary",null,[s[392]||(s[392]=i("a",{id:"Jutul.declare_sparsity",href:"#Jutul.declare_sparsity"},[i("span",{class:"jlbinding"},"Jutul.declare_sparsity")],-1)),s[393]||(s[393]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[395]||(s[395]=i("p",null,"Give out I, J arrays of equal length for a given equation attached to the given model.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[394]||(s[394]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L308-L311",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ii,[i("summary",null,[s[396]||(s[396]=i("a",{id:"Jutul.degrees_of_freedom_per_entity-Tuple{Any, ScalarVariable}",href:"#Jutul.degrees_of_freedom_per_entity-Tuple{Any, ScalarVariable}"},[i("span",{class:"jlbinding"},"Jutul.degrees_of_freedom_per_entity")],-1)),s[397]||(s[397]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[399]||(s[399]=i("p",null,"Number of independent primary variables / degrees of freedom per computational entity.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[398]||(s[398]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L73-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ti,[i("summary",null,[s[400]||(s[400]=i("a",{id:"Jutul.descalarize_primary_variable!-Tuple{Any, Any, Any, ScalarVariable, Any}",href:"#Jutul.descalarize_primary_variable!-Tuple{Any, Any, Any, ScalarVariable, Any}"},[i("span",{class:"jlbinding"},"Jutul.descalarize_primary_variable!")],-1)),s[401]||(s[401]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[403]||(s[403]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">descalarize_primary_variable!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dest_array, model, V, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Jutul.ScalarVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index)</span></span></code></pre></div><p>Descalarize a primary variable, overwriting dest_array at entity <code>index</code>. The AD status of entries in <code>dest_array</code> will be retained.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[402]||(s[402]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/scalarization.jl#L49-L54",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ei,[i("summary",null,[s[404]||(s[404]=i("a",{id:"Jutul.descalarize_primary_variables!",href:"#Jutul.descalarize_primary_variables!"},[i("span",{class:"jlbinding"},"Jutul.descalarize_primary_variables!")],-1)),s[405]||(s[405]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[407]||(s[407]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">descalarize_primary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, model, V, pvars</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pairs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">primary_variables)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), ind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eachindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(V))</span></span></code></pre></div><p>Replace valeus in <code>state</code> by the scalarized values found in V.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[406]||(s[406]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/scalarization.jl#L130-L134",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",li,[i("summary",null,[s[408]||(s[408]=i("a",{id:"Jutul.dim-Tuple{JutulMesh}",href:"#Jutul.dim-Tuple{JutulMesh}"},[i("span",{class:"jlbinding"},"Jutul.dim")],-1)),s[409]||(s[409]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[411]||(s[411]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span></span></code></pre></div><p>Get the dimension of a mesh.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[410]||(s[410]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/meshes.jl#L136-L140",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ai,[i("summary",null,[s[412]||(s[412]=i("a",{id:"Jutul.expand_to_ministeps-Tuple{Any, Any}",href:"#Jutul.expand_to_ministeps-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.expand_to_ministeps")],-1)),s[413]||(s[413]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[415]||(s[415]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">substates, dt, report_index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> expand_to_ministeps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(states, reports)</span></span></code></pre></div><p>Get states and timesteps at the finest stored resolution. Output lengths depend on if <code>output_substates</code> option to simulator was enabled.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[414]||(s[414]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/utils.jl#L748-L753",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ni,[i("summary",null,[s[416]||(s[416]=i("a",{id:"Jutul.expand_to_ministeps-Tuple{Jutul.SimResult}",href:"#Jutul.expand_to_ministeps-Tuple{Jutul.SimResult}"},[i("span",{class:"jlbinding"},"Jutul.expand_to_ministeps")],-1)),s[417]||(s[417]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[419]||(s[419]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">substates, dt, report_index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> expand_to_ministeps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get states and timesteps at the finest stored resolution. Output lengths depend on if <code>output_substates</code> option to simulator was enabled.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[418]||(s[418]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/utils.jl#L737-L742",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",oi,[i("summary",null,[s[420]||(s[420]=i("a",{id:"Jutul.extra_debug_output!-NTuple{6, Any}",href:"#Jutul.extra_debug_output!-NTuple{6, Any}"},[i("span",{class:"jlbinding"},"Jutul.extra_debug_output!")],-1)),s[421]||(s[421]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[423]||(s[423]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extra_debug_output!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(report, storage, model, config, iteration, dt)</span></span></code></pre></div><p>Add extra debug output to report during a nonlinear iteration.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[422]||(s[422]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/simulator.jl#L759-L763",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ri,[i("summary",null,[s[424]||(s[424]=i("a",{id:"Jutul.extract_submesh-Tuple{UnstructuredMesh, Any}",href:"#Jutul.extract_submesh-Tuple{UnstructuredMesh, Any}"},[i("span",{class:"jlbinding"},"Jutul.extract_submesh")],-1)),s[425]||(s[425]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[427]||(s[427]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extract_submesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnstructuredMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cells)</span></span></code></pre></div><p>Extract a subgrid for a given mesh and a iterable of <code>cells</code> to keep.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[426]||(s[426]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/unstructured/utils.jl#L27-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",pi,[i("summary",null,[s[428]||(s[428]=i("a",{id:"Jutul.extrude_mesh-Tuple{UnstructuredMesh, Int64}",href:"#Jutul.extrude_mesh-Tuple{UnstructuredMesh, Int64}"},[i("span",{class:"jlbinding"},"Jutul.extrude_mesh")],-1)),s[429]||(s[429]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[431]||(s[431]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extrude_mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m2d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnstructuredMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, nlayers)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extrude_mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m2d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnstructuredMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><p>Extrude a 2D mesh into a 3D mesh by adding layers of cells in the z-direction. The number of layers can be specified as an integer or as an array of depths. The depths must be in increasing order.</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[430]||(s[430]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/extruded.jl#L2-L9",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ui,[i("summary",null,[s[432]||(s[432]=i("a",{id:"Jutul.find_enclosing_cell-Union{Tuple{T}, Tuple{D}, Tuple{UnstructuredMesh{D}, StaticArraysCore.SVector{D, T}, Vararg{AbstractArray{StaticArraysCore.SVector{D, T}, 1}, 4}}, Tuple{UnstructuredMesh{D}, StaticArraysCore.SVector{D, T}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, Any}} where {D, T}",href:"#Jutul.find_enclosing_cell-Union{Tuple{T}, Tuple{D}, Tuple{UnstructuredMesh{D}, StaticArraysCore.SVector{D, T}, Vararg{AbstractArray{StaticArraysCore.SVector{D, T}, 1}, 4}}, Tuple{UnstructuredMesh{D}, StaticArraysCore.SVector{D, T}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, AbstractArray{StaticArraysCore.SVector{D, T}, 1}, Any}} where {D, T}"},[i("span",{class:"jlbinding"},"Jutul.find_enclosing_cell")],-1)),s[433]||(s[433]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[435]||(s[435]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_enclosing_cell</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnstructuredMesh{D}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SVector{D, T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    normals</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{SVector{D, T}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    face_centroids</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{SVector{D, T}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundary_normals</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{SVector{D, T}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundary_centroids</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{SVector{D, T}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cells </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {D, T}</span></span></code></pre></div><p>Find enclosing cell of a point. This can be a bit expensive for larger meshes. Recommended to use the more high level <code>find_enclosing_cells</code> instead.</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[434]||(s[434]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/trajectories.jl#L175-L186",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",di,[i("summary",null,[s[436]||(s[436]=i("a",{id:"Jutul.find_enclosing_cells-Tuple{Any, Any}",href:"#Jutul.find_enclosing_cells-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.find_enclosing_cells")],-1)),s[437]||(s[437]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[439]||(s[439]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_enclosing_cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G, traj; geometry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tpfv_geometry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G), n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Find the cell indices of cells in the mesh <code>G</code> that are intersected by a given trajectory <code>traj</code>. <code>traj</code> can be either a matrix with equal number of columns as dimensions in G (i.e. three columns for 3D) or a <code>Vector</code> of <code>SVector</code> instances with the same length.</p><p>The optional argument <code>geometry</code> is used to define the centroids and normals used in the calculations. You can precompute this if you need to perform many searches. The keyword argument <code>n</code> can be used to set the number of discretizations in each segment.</p><p><code>use_boundary</code> is by default set to <code>false</code>. If set to true, the boundary faces of cells are treated more rigorously when picking exactly what cells are cut by a trajectory, but this requires that the boundary normals are oriented outwards, which is currently not the case for all meshes from downstream packages.</p><p><code>limit_box</code> speeds up the search by limiting the search to the minimal bounding box that contains both the trajectory and the mesh. This can be turned off by passing <code>false</code>. There should be no difference in the cells tagged by changing this option.</p>',5)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[438]||(s[438]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/trajectories.jl#L12-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",hi,[i("summary",null,[s[440]||(s[440]=i("a",{id:"Jutul.full_cell-Tuple{Any, Any}",href:"#Jutul.full_cell-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.full_cell")],-1)),s[441]||(s[441]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[443]||(s[443]=i("p",null,"Inner cell to local cell (full set)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[442]||(s[442]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/trivial_map.jl#L35",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ki,[i("summary",null,[s[444]||(s[444]=i("a",{id:"Jutul.get_1d_interpolator-Tuple{Any, Any}",href:"#Jutul.get_1d_interpolator-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_1d_interpolator")],-1)),s[445]||(s[445]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[447]||(s[447]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_1d_interpolator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xs, ys; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get a 1D interpolator <code>F(x) ≈ y</code> for a table <code>xs, ys</code> that by default does constant extrapolation</p><p><strong>Arguments</strong></p><ul><li><p><code>xs</code>: sorted list of parameter points.</p></li><li><p><code>ys</code>: list of function values with equal length to <code>xs</code></p></li><li><p><code>method=LinearInterpolant</code>: constructor for the interpolation. Defaults to <code>LinearInterpolant</code> which does simple linear interpolation.</p></li><li><p><code>cap_endpoints = true</code>: Add values so that the endpoints are capped (constant extrapolation). Otherwise, the extrapolation will match the method.</p></li><li><p><code>cap_start = cap_endpoints</code>: Fine-grained version of cap_endpoints for the start of the interval only (extrapolation for <code>x &lt; xs[1]</code>)</p></li><li><p><code>cap_end = cap_endpoints</code>:Fine-grained version of cap_endpoints for the end of the interval only (extrapolation for <code>x &gt; xs[end]</code>)</p></li></ul><p>Additional keyword arguments are passed onto the interpolator constructor.</p>',5)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[446]||(s[446]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/interpolation.jl#L101-L116",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",gi,[i("summary",null,[s[448]||(s[448]=i("a",{id:"Jutul.get_2d_interpolator-Tuple{Any, Any, Any}",href:"#Jutul.get_2d_interpolator-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_2d_interpolator")],-1)),s[449]||(s[449]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[451]||(s[451]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_2d_interpolator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xs, ys, fs; method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BilinearInterpolant, cap_endpoints </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>For <code>xs</code> of length <code>nx</code> and <code>ys</code> of length <code>ny</code> generate a 2D interpolation for values given as a <code>nx</code> by <code>ny</code> matrix. By default <code>cap_endpoints=true</code>, and constant extrapolation is used. Fine-grined control over extrapolation can be achieved by setting the keywords arguments <code>cap_x = (cap_low_x, cap_high_x)</code> and analogously for <code>cap_y</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[450]||(s[450]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/interpolation.jl#L212-L220",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",yi,[i("summary",null,[s[452]||(s[452]=i("a",{id:"Jutul.get_ad_entity_scalar-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real",href:"#Jutul.get_ad_entity_scalar-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real"},[i("span",{class:"jlbinding"},"Jutul.get_ad_entity_scalar")],-1)),s[453]||(s[453]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[455]||(s[455]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_ad_entity_scalar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, npartials, diag_pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword_arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get scalar with partial derivatives as AD instance.</p><p><strong>Arguments</strong></p><ul><li><p><code>v::Real</code>: Value of AD variable.</p></li><li><p><code>npartials</code>: Number of partial derivatives each AD instance holds.</p></li><li><p><code>diag_pos</code> = nothing: Position(s) of where to set 1 as the partial derivative instead of zero.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>tag = nothing</code>: Tag for AD instance. Two AD values of the different tag cannot interoperate to avoid perturbation confusion (see ForwardDiff documentation).</li></ul>',6)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[454]||(s[454]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L357-L369",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ci,[i("summary",null,[s[456]||(s[456]=i("a",{id:"Jutul.get_dependencies-Tuple{Any, Any}",href:"#Jutul.get_dependencies-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_dependencies")],-1)),s[457]||(s[457]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[459]||(s[459]=i("p",null,"Get dependencies of variable when viewed as a secondary variable. Normally autogenerated with @jutul_secondary",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[458]||(s[458]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variable_evaluation.jl#L199-L201",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",bi,[i("summary",null,[s[460]||(s[460]=i("a",{id:"Jutul.get_diagonal_entries-Tuple{JutulEquation, Any}",href:"#Jutul.get_diagonal_entries-Tuple{JutulEquation, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_diagonal_entries")],-1)),s[461]||(s[461]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[463]||(s[463]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_diagonal_entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulEquation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, eq_s)</span></span></code></pre></div><p>Get the diagonal entries of a cache, i.e. the entries where entity type and index equals that of the governing equation.</p><p>Note: Be very careful about modifications to this array, as this is a view into the internal AD buffers and it is very easy to create inconsistent Jacobians.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[462]||(s[462]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L616-L623",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",mi,[i("summary",null,[s[464]||(s[464]=i("a",{id:"Jutul.get_entity_tag-Tuple{Any, Any}",href:"#Jutul.get_entity_tag-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_entity_tag")],-1)),s[465]||(s[465]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[467]||(s[467]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_entity_tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basetag, entity)</span></span></code></pre></div><p>Combine a base tag (which can be nothing) with a entity to get a tag that captures base tag + entity tag for use with AD initialization.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[466]||(s[466]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L493-L498",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ei,[i("summary",null,[s[468]||(s[468]=i("a",{id:"Jutul.get_entries-Tuple{CompactAutoDiffCache}",href:"#Jutul.get_entries-Tuple{CompactAutoDiffCache}"},[i("span",{class:"jlbinding"},"Jutul.get_entries")],-1)),s[469]||(s[469]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[471]||(s[471]=i("p",null,"Get entries of autodiff cache. Entries are AD vectors that hold values and derivatives.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[470]||(s[470]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/compact.jl#L1-L3",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",fi,[i("summary",null,[s[472]||(s[472]=i("a",{id:"Jutul.get_entries-Tuple{JutulEquation}",href:"#Jutul.get_entries-Tuple{JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.get_entries")],-1)),s[473]||(s[473]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[475]||(s[475]=i("p",null,"Get the entries of the main autodiff cache for an equation.",-1)),s[476]||(s[476]=i("p",null,"Note: This only gets the .equation field's entries.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[474]||(s[474]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L19-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_i,[i("summary",null,[s[477]||(s[477]=i("a",{id:"Jutul.get_mesh_entity_tag-Tuple{JutulMesh, Vararg{Any}}",href:"#Jutul.get_mesh_entity_tag-Tuple{JutulMesh, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.get_mesh_entity_tag")],-1)),s[478]||(s[478]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[480]||(s[480]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_mesh_entity_tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(met</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, entity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulEntity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tag_group</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tag_value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; throw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the indices tagged for <code>entity</code> in group <code>tag_group</code>, optionally for the specific <code>tag_value</code>. If <code>ismissing(tag_value)</code>, the Dict containing the tag group will be returned.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[479]||(s[479]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L1297-L1303",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ji,[i("summary",null,[s[481]||(s[481]=i("a",{id:"Jutul.get_parameters-Tuple{SimulationModel}",href:"#Jutul.get_parameters-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_parameters")],-1)),s[482]||(s[482]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[484]||(s[484]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the parameter definitions (as <code>OrderedDict</code>) for a given <code>model</code>.</p><p>Parameters are defined as static values in a forward simulation that combine with the primary variables to compute secondary variables and model equations.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[483]||(s[483]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L40-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",vi,[i("summary",null,[s[485]||(s[485]=i("a",{id:"Jutul.get_primary_variable_ordered_entities-Tuple{SimulationModel}",href:"#Jutul.get_primary_variable_ordered_entities-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_primary_variable_ordered_entities")],-1)),s[486]||(s[486]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[488]||(s[488]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_primary_variable_ordered_entities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get only the entities where primary variables are present, sorted by their order in the primary variables.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[487]||(s[487]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L184-L188",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ci,[i("summary",null,[s[489]||(s[489]=i("a",{id:"Jutul.get_primary_variables-Tuple{SimulationModel}",href:"#Jutul.get_primary_variables-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_primary_variables")],-1)),s[490]||(s[490]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[492]||(s[492]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_primary_variables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the primary variable definitions (as <code>OrderedDict</code>) for a given <code>model</code>.</p><p>Primary variables are sometimes referred to as solution variables or primary unknowns. The set of primary variables completely determines the state of the system together with the <code>parameters</code>.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[491]||(s[491]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L3-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ti,[i("summary",null,[s[493]||(s[493]=i("a",{id:"Jutul.get_secondary_variables-Tuple{SimulationModel}",href:"#Jutul.get_secondary_variables-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_secondary_variables")],-1)),s[494]||(s[494]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[496]||(s[496]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_secondary_variables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the secondary variable definitions (as <code>OrderedDict</code>) for a given <code>model</code>.</p><p>Secondary variables are variables that can be computed from the primary variables together with the parameters.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[495]||(s[495]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L16-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Fi,[i("summary",null,[s[497]||(s[497]=i("a",{id:"Jutul.get_sparse_arguments-Tuple{Any, Any}",href:"#Jutul.get_sparse_arguments-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.get_sparse_arguments")],-1)),s[498]||(s[498]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[500]||(s[500]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_sparse_arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model)</span></span></code></pre></div><p>Get the [<code>SparsePattern</code>]@ref for the Jacobian matrix of a given simulator storage and corresponding model.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[499]||(s[499]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L558-L562",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ai,[i("summary",null,[s[501]||(s[501]=i("a",{id:"Jutul.get_tstr",href:"#Jutul.get_tstr"},[i("span",{class:"jlbinding"},"Jutul.get_tstr")],-1)),s[502]||(s[502]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[504]||(s[504]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_tstr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dT, lim </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get formatted time string of <code>dT</code> given in seconds, limited to <code>lim</code> number of units.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[503]||(s[503]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/utils.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ji,[i("summary",null,[s[505]||(s[505]=i("a",{id:"Jutul.get_variable-Tuple{SimulationModel, Symbol}",href:"#Jutul.get_variable-Tuple{SimulationModel, Symbol}"},[i("span",{class:"jlbinding"},"Jutul.get_variable")],-1)),s[506]||(s[506]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[508]||(s[508]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_variable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get implementation of variable or parameter with name <code>name</code> for the model.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[507]||(s[507]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L67-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",xi,[i("summary",null,[s[509]||(s[509]=i("a",{id:"Jutul.get_variables-Tuple{SimulationModel}",href:"#Jutul.get_variables-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.get_variables")],-1)),s[510]||(s[510]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[512]||(s[512]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_variables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get all variable definitions (as <code>OrderedDict</code>) for a given <code>model</code>.</p><p>This is the union of <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.get_secondary_variables-Tuple{SimulationModel}"><code>get_secondary_variables</code></a> and <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.get_primary_variables-Tuple{SimulationModel}"><code>get_primary_variables</code></a>.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[511]||(s[511]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L29-L35",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Di,[i("summary",null,[s[513]||(s[513]=i("a",{id:"Jutul.global_cell-Tuple{Any, Any}",href:"#Jutul.global_cell-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.global_cell")],-1)),s[514]||(s[514]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[516]||(s[516]=i("p",null,"Local cell -> global cell (full set)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[515]||(s[515]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/trivial_map.jl#L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Si,[i("summary",null,[s[517]||(s[517]=i("a",{id:"Jutul.global_face-Tuple{Any, Any}",href:"#Jutul.global_face-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.global_face")],-1)),s[518]||(s[518]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[520]||(s[520]=i("p",null,"Local face -> global face (full set)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[519]||(s[519]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/trivial_map.jl#L21",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Mi,[i("summary",null,[s[521]||(s[521]=i("a",{id:"Jutul.initialize_context!-NTuple{4, Any}",href:"#Jutul.initialize_context!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.initialize_context!")],-1)),s[522]||(s[522]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[524]||(s[524]=i("p",null,"Initialize context when setting up a model",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[523]||(s[523]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/context.jl#L62-L64",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Bi,[i("summary",null,[s[525]||(s[525]=i("a",{id:"Jutul.initialize_extra_state_fields!-Tuple{Any, JutulModel}",href:"#Jutul.initialize_extra_state_fields!-Tuple{Any, JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.initialize_extra_state_fields!")],-1)),s[526]||(s[526]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[528]||(s[528]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_extra_state_fields!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Add model-dependent changing variables that need to be in state, but are never AD variables themselves (for example status flags).</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[527]||(s[527]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L267-L272",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Li,[i("summary",null,[s[529]||(s[529]=i("a",{id:"Jutul.initialize_storage!-Tuple{Any, JutulModel}",href:"#Jutul.initialize_storage!-Tuple{Any, JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.initialize_storage!")],-1)),s[530]||(s[530]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[532]||(s[532]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_storage!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; initialize_state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialize the already allocated storage at the beginning of a simulation. Use this to e.g. set up extra stuff in state0 needed for initializing the simulation loop.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[531]||(s[531]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L388-L393",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Vi,[i("summary",null,[s[533]||(s[533]=i("a",{id:"Jutul.initialize_variable_value-Tuple{Any, VectorVariables, AbstractVector}",href:"#Jutul.initialize_variable_value-Tuple{Any, VectorVariables, AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.initialize_variable_value")],-1)),s[534]||(s[534]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[536]||(s[536]=i("p",null,"Initializer for the value of non-scalar primary variables",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[535]||(s[535]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L341-L343",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",wi,[i("summary",null,[s[537]||(s[537]=i("a",{id:"Jutul.interior_cell-Tuple{Any, Any}",href:"#Jutul.interior_cell-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.interior_cell")],-1)),s[538]||(s[538]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[540]||(s[540]=i("p",null,"Local cell in full set -> inner cell (or zero)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[539]||(s[539]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/trivial_map.jl#L32",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Pi,[i("summary",null,[s[541]||(s[541]=i("a",{id:"Jutul.interpolation_constant_lookup",href:"#Jutul.interpolation_constant_lookup"},[i("span",{class:"jlbinding"},"Jutul.interpolation_constant_lookup")],-1)),s[542]||(s[542]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[544]||(s[544]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">interpolation_constant_lookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(X, constant_dx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate a lookup table for linear interpolation when dx is evenly spaced.</p><p>Note: Setting <code>constant_dx=true</code> can lead to incorrect interpolations if the data is not evenly spaced.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[543]||(s[543]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/interpolation.jl#L43-L50",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ii,[i("summary",null,[s[545]||(s[545]=i("a",{id:"Jutul.jutul_message",href:"#Jutul.jutul_message"},[i("span",{class:"jlbinding"},"Jutul.jutul_message")],-1)),s[546]||(s[546]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[548]||(s[548]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">jutul_message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jutul&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :light_blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Print a line with a colored prefix. The prefix is colored with the <code>color</code> argument. The <code>fancy</code> argument controls whether the output is colored or not.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[547]||(s[547]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/print.jl#L189-L194",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Oi,[i("summary",null,[s[549]||(s[549]=i("a",{id:"Jutul.jutul_output_path",href:"#Jutul.jutul_output_path"},[i("span",{class:"jlbinding"},"Jutul.jutul_output_path")],-1)),s[550]||(s[550]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[552]||(s[552]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> jutul_output_path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; subfolder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;jutul&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, basedir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, create </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get path for output. The final path will be found in /basedir/&lt;subfolder/name. If <code>subfolder=missing</code>, the path will be set to /basedir/name instead. <code>name</code> will be autogenerated if not provided.</p><p>Pass the optional input <code>create = false</code> to avoid making the directory. To globally set the default output dir, set <code>ENV[&quot;JUTUL_OUTPUT_PATH&quot;]``to your desired</code>basedir``.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[551]||(s[551]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/utils.jl#L939-L948",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ni,[i("summary",null,[s[553]||(s[553]=i("a",{id:"Jutul.linear_timestep_selection",href:"#Jutul.linear_timestep_selection"},[i("span",{class:"jlbinding"},"Jutul.linear_timestep_selection")],-1)),s[554]||(s[554]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[556]||(s[556]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">linear_timestep_selection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, x0, x1, dt0, dt1)</span></span></code></pre></div><p>Produce linear estimate of timestep <code>dt</code> for some value <code>x</code> from observed observations. If the observations have the same <code>x</code> or <code>dt</code> values, a simple scaling based on the <code>x1</code> value is used.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[555]||(s[555]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/timesteps.jl#L226-L232",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ri,[i("summary",null,[s[557]||(s[557]=i("a",{id:"Jutul.load_balanced_endpoint-Tuple{Any, Any, Any}",href:"#Jutul.load_balanced_endpoint-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.load_balanced_endpoint")],-1)),s[558]||(s[558]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[560]||(s[560]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">load_balanced_endpoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block_index, nvals, nblocks)</span></span></code></pre></div><p>Endpoint for interval <code>block_index</code> that subdivides <code>nvals</code> into <code>nblocks</code> in a load balanced manner. This is done by adding one element to the first set of blocks whenever possible.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[559]||(s[559]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/partitioning.jl#L311-L317",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",qi,[i("summary",null,[s[561]||(s[561]=i("a",{id:"Jutul.load_balanced_interval-Tuple{Any, Any, Any}",href:"#Jutul.load_balanced_interval-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.load_balanced_interval")],-1)),s[562]||(s[562]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[564]||(s[564]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">load_balanced_interval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b, n, m)</span></span></code></pre></div><p>Create UnitRange for block b ∈ [1, m] for interval of total length n</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[563]||(s[563]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/partitioning.jl#L328-L332",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",zi,[i("summary",null,[s[565]||(s[565]=i("a",{id:"Jutul.local_ad-Tuple{Any, Any, Any}",href:"#Jutul.local_ad-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.local_ad")],-1)),s[566]||(s[566]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[568]||(s[568]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">local_ad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">I</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ad_tag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:∂T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ∂T}</span></span></code></pre></div><p>Create local_ad for state for index I of AD tag of type ad_tag</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[567]||(s[567]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/local_ad.jl#L180-L184",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Gi,[i("summary",null,[s[569]||(s[569]=i("a",{id:"Jutul.local_cell-Tuple{Any, Any}",href:"#Jutul.local_cell-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.local_cell")],-1)),s[570]||(s[570]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[572]||(s[572]=i("p",null,"Global cell -> local cell (full set)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[571]||(s[571]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/trivial_map.jl#L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ui,[i("summary",null,[s[573]||(s[573]=i("a",{id:"Jutul.local_face-Tuple{Any, Any}",href:"#Jutul.local_face-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.local_face")],-1)),s[574]||(s[574]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[576]||(s[576]=i("p",null,"Global face -> local face (full set)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[575]||(s[575]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/trivial_map.jl#L30",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Wi,[i("summary",null,[s[577]||(s[577]=i("a",{id:"Jutul.local_residual_view-NTuple{4, Any}",href:"#Jutul.local_residual_view-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.local_residual_view")],-1)),s[578]||(s[578]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[580]||(s[580]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">local_residual_view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r_buf, model, eq, equation_offset)</span></span></code></pre></div><p>Get a matrix view of the residual so that, independent of ordering, the column index corresponds to the entity index for the given equation <code>eq</code> starting at <code>equation_offset</code> in the global residual buffer <code>r_buf</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[579]||(s[579]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L758-L764",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Hi,[i("summary",null,[s[581]||(s[581]=i("a",{id:"Jutul.maximum_value-Tuple{JutulVariables}",href:"#Jutul.maximum_value-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.maximum_value")],-1)),s[582]||(s[582]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[584]||(s[584]=i("p",null,"Upper (inclusive) limit for variable.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[583]||(s[583]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L98-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ki,[i("summary",null,[s[585]||(s[585]=i("a",{id:"Jutul.merge_step_report_errors-Tuple{Any}",href:"#Jutul.merge_step_report_errors-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.merge_step_report_errors")],-1)),s[586]||(s[586]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[588]||(s[588]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">merge_step_report_errors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data; fn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max)</span></span></code></pre></div><p>Merge step reports errors of the same type using a pair wise reduction (default: max)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[587]||(s[587]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/utils.jl#L1009-L1013",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Yi,[i("summary",null,[s[589]||(s[589]=i("a",{id:"Jutul.mesh_from_gmsh",href:"#Jutul.mesh_from_gmsh"},[i("span",{class:"jlbinding"},"Jutul.mesh_from_gmsh")],-1)),s[590]||(s[590]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[592]||(s[592]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mesh_from_gmsh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pth)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mesh_from_gmsh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mesh_from_gmsh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pth; verbose </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Parse a Gmsh file and return a Jutul <code>UnstructuredMesh</code> (in 3D only). Requires the Gmsh.jl package to be loaded. If no path is provided in <code>pth</code> it is assumed that you are managing the Gmsh state manually and it will use the current selected mesh inside Gmsh. Please note that Gmsh is GPL licensed unless you have obtained another type of license from the authors.</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[591]||(s[591]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/gmsh_ext.jl#L3-L13",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",$i,[i("summary",null,[s[593]||(s[593]=i("a",{id:"Jutul.minimum_value-Tuple{JutulVariables}",href:"#Jutul.minimum_value-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.minimum_value")],-1)),s[594]||(s[594]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[596]||(s[596]=i("p",null,"Lower (inclusive) limit for variable.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[595]||(s[595]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L103-L105",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Zi,[i("summary",null,[s[597]||(s[597]=i("a",{id:"Jutul.model_accumulation!",href:"#Jutul.model_accumulation!"},[i("span",{class:"jlbinding"},"Jutul.model_accumulation!")],-1)),s[598]||(s[598]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[600]||(s[600]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">model_accumulation!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(acc, sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HelperSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    update_secondary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the accumulation term into Vector acc.</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[599]||(s[599]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/helper.jl#L219-L227",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Xi,[i("summary",null,[s[601]||(s[601]=i("a",{id:"Jutul.model_residual!",href:"#Jutul.model_residual!"},[i("span",{class:"jlbinding"},"Jutul.model_residual!")],-1)),s[602]||(s[602]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[604]||(s[604]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">model_residual!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, sim, x, x0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    include_accumulation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Fill in the model residual into Vector r.</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[603]||(s[603]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/helper.jl#L88-L96",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Qi,[i("summary",null,[s[605]||(s[605]=i("a",{id:"Jutul.model_residual-Union{Tuple{T}, Tuple{HelperSimulator{<:Any, <:Any, <:Any, T}, Any, Vararg{Any}}} where T",href:"#Jutul.model_residual-Union{Tuple{T}, Tuple{HelperSimulator{<:Any, <:Any, <:Any, T}, Any, Vararg{Any}}} where T"},[i("span",{class:"jlbinding"},"Jutul.model_residual")],-1)),s[606]||(s[606]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[608]||(s[608]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">model_residual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HelperSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Out of place version of <code>model_residual!</code></p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[607]||(s[607]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/helper.jl#L75-L79",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",st,[i("summary",null,[s[609]||(s[609]=i("a",{id:"Jutul.number_of_boundary_faces",href:"#Jutul.number_of_boundary_faces"},[i("span",{class:"jlbinding"},"Jutul.number_of_boundary_faces")],-1)),s[610]||(s[610]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[612]||(s[612]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_boundary_faces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span></span></code></pre></div><p>Get the number of boundary/exterior faces in a mesh.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[611]||(s[611]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/meshes.jl#L157-L161",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",it,[i("summary",null,[s[613]||(s[613]=i("a",{id:"Jutul.number_of_cells-Tuple{JutulMesh}",href:"#Jutul.number_of_cells-Tuple{JutulMesh}"},[i("span",{class:"jlbinding"},"Jutul.number_of_cells")],-1)),s[614]||(s[614]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[616]||(s[616]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span></span></code></pre></div><p>Get the number of cells in a mesh.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[615]||(s[615]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/meshes.jl#L143-L147",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",tt,[i("summary",null,[s[617]||(s[617]=i("a",{id:"Jutul.number_of_cells-Tuple{Union{DataDomain, DiscretizedDomain}}",href:"#Jutul.number_of_cells-Tuple{Union{DataDomain, DiscretizedDomain}}"},[i("span",{class:"jlbinding"},"Jutul.number_of_cells")],-1)),s[618]||(s[618]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[620]||(s[620]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_cells</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{DataDomain, DiscretizedDomain}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the number of cells in a <code>DataDomain</code> or <code>DiscretizedDomain</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[619]||(s[619]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/domains.jl#L60-L64",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",et,[i("summary",null,[s[621]||(s[621]=i("a",{id:"Jutul.number_of_degrees_of_freedom-Tuple{JutulModel}",href:"#Jutul.number_of_degrees_of_freedom-Tuple{JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.number_of_degrees_of_freedom")],-1)),s[622]||(s[622]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[624]||(s[624]=i("p",null,"Total number of degrees of freedom for a model, over all primary variables and all entities.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[623]||(s[623]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L14-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",lt,[i("summary",null,[s[625]||(s[625]=i("a",{id:"Jutul.number_of_entities-Tuple{Any, JutulEquation}",href:"#Jutul.number_of_entities-Tuple{Any, JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[626]||(s[626]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[628]||(s[628]=i("p",null,"Get the number of entities (e.g. the number of cells) that the equation is defined on.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[627]||(s[627]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L286-L288",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",at,[i("summary",null,[s[629]||(s[629]=i("a",{id:"Jutul.number_of_entities-Tuple{Any, JutulVariables}",href:"#Jutul.number_of_entities-Tuple{Any, JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[630]||(s[630]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[632]||(s[632]=i("p",null,"Number of entities (e.g. Cells, Faces) a variable is defined on. By default, each primary variable exists on all cells of a discretized domain",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[631]||(s[631]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L2-L6",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",nt,[i("summary",null,[s[633]||(s[633]=i("a",{id:"Jutul.number_of_entities-Tuple{JutulAutoDiffCache}",href:"#Jutul.number_of_entities-Tuple{JutulAutoDiffCache}"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[634]||(s[634]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[636]||(s[636]=i("p",null,"Get number of entities a cache is defined on.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[635]||(s[635]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L3-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ot,[i("summary",null,[s[637]||(s[637]=i("a",{id:"Jutul.number_of_entities-Tuple{T} where T<:AbstractVector",href:"#Jutul.number_of_entities-Tuple{T} where T<:AbstractVector"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[638]||(s[638]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[640]||(s[640]=i("p",null,"Number of entities for vector stored in state (just the number of elements)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[639]||(s[639]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L9-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",rt,[i("summary",null,[s[641]||(s[641]=i("a",{id:"Jutul.number_of_entities-Tuple{T} where T<:AbstractArray",href:"#Jutul.number_of_entities-Tuple{T} where T<:AbstractArray"},[i("span",{class:"jlbinding"},"Jutul.number_of_entities")],-1)),s[642]||(s[642]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[644]||(s[644]=i("p",null,"Number of entities for matrix stored in state (convention is number of columns)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[643]||(s[643]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L14-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",pt,[i("summary",null,[s[645]||(s[645]=i("a",{id:"Jutul.number_of_equations-Tuple{Any, JutulEquation}",href:"#Jutul.number_of_equations-Tuple{Any, JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.number_of_equations")],-1)),s[646]||(s[646]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[648]||(s[648]=i("p",null,"Get the total number of equations on the domain of model.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[647]||(s[647]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L293-L295",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ut,[i("summary",null,[s[649]||(s[649]=i("a",{id:"Jutul.number_of_equations_per_entity-Tuple{JutulModel, JutulEquation}",href:"#Jutul.number_of_equations_per_entity-Tuple{JutulModel, JutulEquation}"},[i("span",{class:"jlbinding"},"Jutul.number_of_equations_per_entity")],-1)),s[650]||(s[650]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[652]||(s[652]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number_of_equations_per_entity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, eq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulEquation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the number of equations per entity. For example, mass balance of two components will have two equations per grid cell (= entity)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[651]||(s[651]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L267-L272",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",dt,[i("summary",null,[s[653]||(s[653]=i("a",{id:"Jutul.number_of_faces-Tuple{Any}",href:"#Jutul.number_of_faces-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.number_of_faces")],-1)),s[654]||(s[654]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[656]||(s[656]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_faces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span></span></code></pre></div><p>Get the number of faces in a mesh.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[655]||(s[655]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/meshes.jl#L150-L154",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ht,[i("summary",null,[s[657]||(s[657]=i("a",{id:"Jutul.number_of_faces-Tuple{Union{DataDomain, DiscretizedDomain}}",href:"#Jutul.number_of_faces-Tuple{Union{DataDomain, DiscretizedDomain}}"},[i("span",{class:"jlbinding"},"Jutul.number_of_faces")],-1)),s[658]||(s[658]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[660]||(s[660]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_faces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{DataDomain, DiscretizedDomain}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the number of faces in a <code>DataDomain</code> or <code>DiscretizedDomain</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[659]||(s[659]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/domains.jl#L69-L73",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",kt,[i("summary",null,[s[661]||(s[661]=i("a",{id:"Jutul.number_of_half_faces-Tuple{Union{DataDomain, DiscretizedDomain}}",href:"#Jutul.number_of_half_faces-Tuple{Union{DataDomain, DiscretizedDomain}}"},[i("span",{class:"jlbinding"},"Jutul.number_of_half_faces")],-1)),s[662]||(s[662]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[664]||(s[664]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_half_faces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{DataDomain, DiscretizedDomain}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the number of half-faces in a <code>DataDomain</code> or <code>DiscretizedDomain</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[663]||(s[663]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/domains.jl#L78-L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",gt,[i("summary",null,[s[665]||(s[665]=i("a",{id:"Jutul.number_of_partials_per_entity-Tuple{SimulationModel, JutulEntity}",href:"#Jutul.number_of_partials_per_entity-Tuple{SimulationModel, JutulEntity}"},[i("span",{class:"jlbinding"},"Jutul.number_of_partials_per_entity")],-1)),s[666]||(s[666]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[668]||(s[668]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number_of_partials_per_entity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, entity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulEntity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the number of local partial derivatives per entity in a <code>model</code> for a given <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.JutulEntity"><code>JutulEntity</code></a>. This is the sum of <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.degrees_of_freedom_per_entity-Tuple{Any, ScalarVariable}"><code>degrees_of_freedom_per_entity</code></a> for all primary variables defined on <code>entity</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[667]||(s[667]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L207-L212",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",yt,[i("summary",null,[s[669]||(s[669]=i("a",{id:"Jutul.number_of_values",href:"#Jutul.number_of_values"},[i("span",{class:"jlbinding"},"Jutul.number_of_values")],-1)),s[670]||(s[670]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[672]||(s[672]=i("p",null,"Total number of values for a model, for a given type of variables over all entities",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[671]||(s[671]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L34-L36",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ct,[i("summary",null,[s[673]||(s[673]=i("a",{id:"Jutul.numerical_eltype-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T",href:"#Jutul.numerical_eltype-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T"},[i("span",{class:"jlbinding"},"Jutul.numerical_eltype")],-1)),s[674]||(s[674]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[676]||(s[676]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">numerical_eltype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span></code></pre></div><p>Get the numerical eltype (i.e. the inner type of the element type that could potentially be AD)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[675]||(s[675]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/local_ad.jl#L112-L117",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",bt,[i("summary",null,[s[677]||(s[677]=i("a",{id:"Jutul.numerical_type-Tuple{T} where T<:Real",href:"#Jutul.numerical_type-Tuple{T} where T<:Real"},[i("span",{class:"jlbinding"},"Jutul.numerical_type")],-1)),s[678]||(s[678]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[680]||(s[680]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">numerical_type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span></code></pre></div><p>Get the numerical eltype (i.e. the inner type of the element type that could potentially be AD). This function should be overloaded if you have a custom type that wraps a numeric/potentially AD type.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[679]||(s[679]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/local_ad.jl#L126-L132",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",mt,[i("summary",null,[s[681]||(s[681]=i("a",{id:"Jutul.optimization_step_info-Tuple{Int64, Real, Real}",href:"#Jutul.optimization_step_info-Tuple{Int64, Real, Real}"},[i("span",{class:"jlbinding"},"Jutul.optimization_step_info")],-1)),s[682]||(s[682]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[684]||(s[684]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">optimization_step_info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(step</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, time</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dt; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Optimization step information is normally not set up manually, but the output from this function will be passed to objective functions as <code>step_info</code>. This function is a <code>Dict</code> with the following fields:</p><p><strong>Fields</strong></p><ul><li><p><code>:time</code> - The time at the end of the step. To get time at the start of the step, use <code>step_info[:time] - step_info[:dt]</code></p></li><li><p><code>:dt</code> - The time step size for this step.</p></li><li><p><code>:step</code> - The step number, starting at 1. Not that this is the report step, and multiple <code>step_info</code> entries could have the same step if substeps are used.</p></li><li><p><code>:Nstep</code> - The total number of steps in the simulation.</p></li><li><p><code>:substep</code> - The substep number, starting at 1. This is used to indicate that multiple steps are taken within a single step.</p></li><li><p><code>:substep_global</code> - The global substep number, starting at 1 and will not reset between global steps.</p></li><li><p><code>:Nsubstep_global</code> - The total number of substeps in the simulation.</p></li><li><p><code>:total_time</code> - The total time of the simulation (i.e. time at the final step and substep)</p></li></ul>',4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[683]||(s[683]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/gradients.jl#L980-L1002",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Et,[i("summary",null,[s[685]||(s[685]=i("a",{id:"Jutul.parameters_jacobian_wrt_data_domain-Tuple{Any}",href:"#Jutul.parameters_jacobian_wrt_data_domain-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.parameters_jacobian_wrt_data_domain")],-1)),s[686]||(s[686]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[688]||(s[688]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parameters_jacobian_wrt_data_domain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model; copy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the (sparse) Jacobian of parameters with respect to data_domain values (i.e. floating point values). Optionally, <code>config</code> can be passed to allow <code>vectorize_variables</code> to only include a subset of the parameters.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[687]||(s[687]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/vectorization.jl#L227-L233",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ft,[i("summary",null,[s[689]||(s[689]=i("a",{id:"Jutul.partition",href:"#Jutul.partition"},[i("span",{class:"jlbinding"},"Jutul.partition")],-1)),s[690]||(s[690]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[692]||(s[692]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, num_coarse, weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); partitioner </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MetisPartitioner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), groups </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> maximum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N), group_by_weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, buffer_group </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Partition based on neighborship (with optional groups kept contigious after partitioning)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[691]||(s[691]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/partitioning.jl#L239-L244",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_t,[i("summary",null,[s[693]||(s[693]=i("a",{id:"Jutul.partition_hypergraph",href:"#Jutul.partition_hypergraph"},[i("span",{class:"jlbinding"},"Jutul.partition_hypergraph")],-1)),s[694]||(s[694]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[696]||(s[696]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">partition_hypergraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, partitioner </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MetisPartitioner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); expand </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Partition a hypergraph from <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.setup_partitioner_hypergraph-Tuple{Matrix{Int64}}"><code>setup_partitioner_hypergraph</code></a> using a given partitioner. If the optional <code>expand</code> parameter is set to true the result will be expanded to the full graph (i.e. where groups are not condensed).</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[695]||(s[695]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/partitioning.jl#L433-L439",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",jt,[i("summary",null,[s[697]||(s[697]=i("a",{id:"Jutul.physical_representation-Tuple{Any}",href:"#Jutul.physical_representation-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.physical_representation")],-1)),s[698]||(s[698]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[700]||(s[700]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">physical_representation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span></code></pre></div><p>Get the physical representation of an object. The physical representation is usually some kind of mesh or domain that represents a physical domain.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[699]||(s[699]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/domains.jl#L7-L12",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",vt,[i("summary",null,[s[701]||(s[701]=i("a",{id:"Jutul.physical_representation-Tuple{DataDomain}",href:"#Jutul.physical_representation-Tuple{DataDomain}"},[i("span",{class:"jlbinding"},"Jutul.physical_representation")],-1)),s[702]||(s[702]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[704]||(s[704]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">physical_representation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the underlying physical representation (domain or mesh) that is wrapped.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[703]||(s[703]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/domains.jl#L71-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ct,[i("summary",null,[s[705]||(s[705]=i("a",{id:"Jutul.physical_representation-Tuple{DiscretizedDomain}",href:"#Jutul.physical_representation-Tuple{DiscretizedDomain}"},[i("span",{class:"jlbinding"},"Jutul.physical_representation")],-1)),s[706]||(s[706]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[708]||(s[708]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">physical_representation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiscretizedDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the underlying physical representation (domain or mesh) that was discretized.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[707]||(s[707]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/domains.jl#L23-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Tt,[i("summary",null,[s[709]||(s[709]=i("a",{id:"Jutul.physical_representation-Tuple{SimulationModel}",href:"#Jutul.physical_representation-Tuple{SimulationModel}"},[i("span",{class:"jlbinding"},"Jutul.physical_representation")],-1)),s[710]||(s[710]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[712]||(s[712]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">physical_representation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimulationModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the underlying physical representation for the model (domain or mesh)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[711]||(s[711]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/core_types/core_types.jl#L346-L350",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ft,[i("summary",null,[s[713]||(s[713]=i("a",{id:"Jutul.pick_next_timestep-Tuple{IterationTimestepSelector, Vararg{Any, 9}}",href:"#Jutul.pick_next_timestep-Tuple{IterationTimestepSelector, Vararg{Any, 9}}"},[i("span",{class:"jlbinding"},"Jutul.pick_next_timestep")],-1)),s[714]||(s[714]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[716]||(s[716]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pick_next_timestep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IterationTimestepSelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sim, config, dt_prev, dT, forces, reports, current_reports, step_index, new_step)</span></span></code></pre></div><p>Pick the next time-step for <code>IterationTimestepSelector</code>. This function uses the number of iterations from previous timesteps to estimate the relationship between the last and the new time step.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[715]||(s[715]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/timesteps.jl#L61-L67",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",At,[i("summary",null,[s[717]||(s[717]=i("a",{id:"Jutul.plot_cell_data!-Tuple",href:"#Jutul.plot_cell_data!-Tuple"},[i("span",{class:"jlbinding"},"Jutul.plot_cell_data!")],-1)),s[718]||(s[718]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[720]||(s[720]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_cell_data!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ax, mesh, data; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Mutating version of <code>plot_cell_data</code> that plots into an existing Makie <code>Axis</code></p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[719]||(s[719]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/makie_ext.jl#L123-L127",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Jt,[i("summary",null,[s[721]||(s[721]=i("a",{id:"Jutul.plot_cell_data-Tuple",href:"#Jutul.plot_cell_data-Tuple"},[i("span",{class:"jlbinding"},"Jutul.plot_cell_data")],-1)),s[722]||(s[722]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[724]||(s[724]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_cell_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mesh</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_cell_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mesh, data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cells </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    faces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundaryfaces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Plot cell-wise values (as a vector) on the mesh. Optionally, indices <code>cells</code>, <code>faces</code> or <code>boundaryfaces</code> can be passed to limit the plotting to a specific selection of entities.</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[723]||(s[723]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/makie_ext.jl#L102-L113",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",xt,[i("summary",null,[s[725]||(s[725]=i("a",{id:"Jutul.plot_interactive-Tuple",href:"#Jutul.plot_interactive-Tuple"},[i("span",{class:"jlbinding"},"Jutul.plot_interactive")],-1)),s[726]||(s[726]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[728]||(s[728]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_interactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mesh, vector_of_dicts; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Launch an interactive plot of a mesh with the given <code>vector_of_dicts</code> (or just a dict). Each dict can have cell data either as vectors (one value per cell) or matrices (one column per cell).</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[727]||(s[727]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/makie_ext.jl#L8-L14",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Dt,[i("summary",null,[s[729]||(s[729]=i("a",{id:"Jutul.plot_mesh!-Tuple",href:"#Jutul.plot_mesh!-Tuple"},[i("span",{class:"jlbinding"},"Jutul.plot_mesh!")],-1)),s[730]||(s[730]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[732]||(s[732]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_mesh!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ax, mesh)</span></span></code></pre></div><p>Mutating version of <code>plot_mesh</code> that plots into an existing Makie <code>Axis</code> instance.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[731]||(s[731]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/makie_ext.jl#L57-L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",St,[i("summary",null,[s[733]||(s[733]=i("a",{id:"Jutul.plot_mesh-Tuple",href:"#Jutul.plot_mesh-Tuple"},[i("span",{class:"jlbinding"},"Jutul.plot_mesh")],-1)),s[734]||(s[734]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[736]||(s[736]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mesh)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mesh;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cells </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    faces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundaryfaces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    outer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :lightblue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Plot a <code>mesh</code> with uniform colors. Optionally, indices <code>cells</code>, <code>faces</code> or <code>boundaryfaces</code> can be passed to limit the plotting to a specific selection of entities.</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[735]||(s[735]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/makie_ext.jl#L33-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Mt,[i("summary",null,[s[737]||(s[737]=i("a",{id:"Jutul.plot_mesh_edges!-Tuple",href:"#Jutul.plot_mesh_edges!-Tuple"},[i("span",{class:"jlbinding"},"Jutul.plot_mesh_edges!")],-1)),s[738]||(s[738]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[740]||(s[740]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_mesh_edges!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ax, mesh; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Plot the edges of all cells on the exterior of a mesh into existing Makie <code>Axis</code> <code>ax</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[739]||(s[739]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/makie_ext.jl#L87-L92",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Bt,[i("summary",null,[s[741]||(s[741]=i("a",{id:"Jutul.plot_mesh_edges-Tuple",href:"#Jutul.plot_mesh_edges-Tuple"},[i("span",{class:"jlbinding"},"Jutul.plot_mesh_edges")],-1)),s[742]||(s[742]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[744]||(s[744]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">plot_mesh_edges</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mesh; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Plot the edges of all cells on the exterior of a mesh.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[743]||(s[743]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ext/makie_ext.jl#L73-L77",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Lt,[i("summary",null,[s[745]||(s[745]=i("a",{id:"Jutul.prepare_step_storage-Tuple{Any, Any, Missing}",href:"#Jutul.prepare_step_storage-Tuple{Any, Any, Missing}"},[i("span",{class:"jlbinding"},"Jutul.prepare_step_storage")],-1)),s[746]||(s[746]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[748]||(s[748]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prepare_step_storage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialize storage for prepare_step_handler.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[747]||(s[747]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/simulator.jl#L64-L68",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Vt,[i("summary",null,[s[749]||(s[749]=i("a",{id:"Jutul.process_partition",href:"#Jutul.process_partition"},[i("span",{class:"jlbinding"},"Jutul.process_partition")],-1)),s[750]||(s[750]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[752]||(s[752]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> process_partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, partition; weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> process_partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{Tuple{Int, Int}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, partition; weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> process_partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Matrix{Int}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, partition; weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Perform processing of <code>partition</code> on mesh or neighborship to make sure that all coarse blocks in the partition are connected. Optionally, weights can be passed that will be used to remove connections with weights that are zero (or within floating point precision of zero).</p><p>The resulting partition vector will be a copy and will have additional coarse blocks inserted when blocks were split into two or more components.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CartesianMesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Block 1 is disconnected!</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">process_partition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, p)</span></span></code></pre></div>`,4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[751]||(s[751]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/partitioning.jl#L101-L119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",wt,[i("summary",null,[s[753]||(s[753]=i("a",{id:"Jutul.read_results-Tuple{Any}",href:"#Jutul.read_results-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.read_results")],-1)),s[754]||(s[754]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[756]||(s[756]=i("p",null,"states, reports = read_results(pth; read_states = true, read_reports = true)",-1)),s[757]||(s[757]=i("p",null,[l("Read results from a given "),i("code",null,"output_path"),l(" provded to "),i("code",null,"simulate"),l(" or "),i("code",null,"simulator_config"),l(".")],-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[755]||(s[755]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/utils.jl#L608-L612",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Pt,[i("summary",null,[s[758]||(s[758]=i("a",{id:"Jutul.relative_increment_limit-Tuple{JutulVariables}",href:"#Jutul.relative_increment_limit-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.relative_increment_limit")],-1)),s[759]||(s[759]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[761]||(s[761]=i("p",null,"Relative allowable change for variable during a nonlinear update. A variable with value |x| and relative limit 0.2 cannot change more than |x|*0.2.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[760]||(s[760]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L91-L95",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",It,[i("summary",null,[s[762]||(s[762]=i("a",{id:"Jutul.replace_variables!-Tuple{Any}",href:"#Jutul.replace_variables!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.replace_variables!")],-1)),s[763]||(s[763]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[765]||(s[765]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">replace_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, throw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, varname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef, varname2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef2)</span></span></code></pre></div><p>Replace one or more variables that already exists in the model (primary, secondary or parameters) with a new definition.</p><p><strong>Arguments</strong></p><ul><li><p><code>model</code>: instance where variables is to be replaced</p></li><li><p><code>varname=vardef::JutulVariables</code>: replace variable with <code>varname</code> by <code>vardef</code></p></li><li><p><code>throw=true</code>: throw an error if the named variable definition is not found in primary or secondary, otherwise silently return the <code>model</code>.</p></li></ul>',4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[764]||(s[764]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L135-L146",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ot,[i("summary",null,[s[766]||(s[766]=i("a",{id:"Jutul.scalarize_primary_variable-Tuple{Any, Any, ScalarVariable, Any}",href:"#Jutul.scalarize_primary_variable-Tuple{Any, Any, ScalarVariable, Any}"},[i("span",{class:"jlbinding"},"Jutul.scalarize_primary_variable")],-1)),s[767]||(s[767]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[769]||(s[769]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scalarize_primary_variable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, source_vec, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Jutul.ScalarVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index)</span></span></code></pre></div><p>Scalarize a primary variable. For scalars, this means getting the value itself.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[768]||(s[768]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/scalarization.jl#L40-L44",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Nt,[i("summary",null,[s[770]||(s[770]=i("a",{id:"Jutul.scalarize_primary_variables",href:"#Jutul.scalarize_primary_variables"},[i("span",{class:"jlbinding"},"Jutul.scalarize_primary_variables")],-1)),s[771]||(s[771]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[773]||(s[773]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scalarize_primary_variables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, state, pvars </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">primary_variables)</span></span></code></pre></div><p>Create a vector where each entry corresponds to a tuple of values that minimally defines the given variables. All variables must belong to the same type of entity. This is checked by this function.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[772]||(s[772]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/scalarization.jl#L91-L97",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Rt,[i("summary",null,[s[774]||(s[774]=i("a",{id:"Jutul.scalarize_primary_variables!-Union{Tuple{T}, Tuple{Array{Jutul.ScalarizedJutulVariables{T}, 1}, Any, Any, NamedTuple}} where T",href:"#Jutul.scalarize_primary_variables!-Union{Tuple{T}, Tuple{Array{Jutul.ScalarizedJutulVariables{T}, 1}, Any, Any, NamedTuple}} where T"},[i("span",{class:"jlbinding"},"Jutul.scalarize_primary_variables!")],-1)),s[775]||(s[775]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[777]||(s[777]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scalarize_primary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model, state, pvars</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span></code></pre></div><p>Scalarize into array. See <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.scalarize_primary_variables"><code>scalarize_primary_variables</code></a> for more details.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[776]||(s[776]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/scalarization.jl#L115-L119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",qt,[i("summary",null,[s[778]||(s[778]=i("a",{id:"Jutul.scalarized_primary_variable_type-Tuple{Any, ScalarVariable}",href:"#Jutul.scalarized_primary_variable_type-Tuple{Any, ScalarVariable}"},[i("span",{class:"jlbinding"},"Jutul.scalarized_primary_variable_type")],-1)),s[779]||(s[779]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[781]||(s[781]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scalarized_primary_variable_type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Jutul.ScalarVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the type of a scalarized numerical variable (=Float64 for variables that are already represented as scalars)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[780]||(s[780]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/scalarization.jl#L17-L22",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",zt,[i("summary",null,[s[782]||(s[782]=i("a",{id:"Jutul.set_default_tolerances-Tuple{Any}",href:"#Jutul.set_default_tolerances-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.set_default_tolerances")],-1)),s[783]||(s[783]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[785]||(s[785]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_default_tolerances</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model)</span></span></code></pre></div><p>Set default tolerances for the nonlinear convergence check of the governing equations.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[784]||(s[784]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L776-L780",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Gt,[i("summary",null,[s[786]||(s[786]=i("a",{id:"Jutul.set_parameters!-Tuple{Any}",href:"#Jutul.set_parameters!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.set_parameters!")],-1)),s[787]||(s[787]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[789]||(s[789]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_parameters!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, parname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pardef)</span></span></code></pre></div><p>Set a parameter with name <code>varname</code> to the definition <code>vardef</code> (adding if it does not exist)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[788]||(s[788]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L117-L121",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ut,[i("summary",null,[s[790]||(s[790]=i("a",{id:"Jutul.set_primary_variables!-Tuple{Any}",href:"#Jutul.set_primary_variables!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.set_primary_variables!")],-1)),s[791]||(s[791]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[793]||(s[793]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_primary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, varname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_primary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, varname1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef1, varname2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef2)</span></span></code></pre></div><p>Set a primary variable with name <code>varname</code> to the definition <code>vardef</code> (adding if it does not exist)</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[792]||(s[792]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L94-L99",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Wt,[i("summary",null,[s[794]||(s[794]=i("a",{id:"Jutul.set_secondary_variables!-Tuple{Any}",href:"#Jutul.set_secondary_variables!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.set_secondary_variables!")],-1)),s[795]||(s[795]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[797]||(s[797]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_secondary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, varname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_secondary_variables!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, varname1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef1, varname2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vardef2)</span></span></code></pre></div><p>Set a secondary variable with name <code>varname</code> to the definition <code>vardef</code> (adding if it does not exist)</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[796]||(s[796]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L105-L111",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ht,[i("summary",null,[s[798]||(s[798]=i("a",{id:"Jutul.setup_adjoint_storage-Tuple{Any}",href:"#Jutul.setup_adjoint_storage-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.setup_adjoint_storage")],-1)),s[799]||(s[799]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[801]||(s[801]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_adjoint_storage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model; state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model), parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model))</span></span></code></pre></div><p>Set up storage for use with <code>solve_adjoint_sensitivities!</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[800]||(s[800]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/gradients.jl#L103-L107",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Kt,[i("summary",null,[s[802]||(s[802]=i("a",{id:"Jutul.setup_forces-Tuple{JutulModel}",href:"#Jutul.setup_forces-Tuple{JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.setup_forces")],-1)),s[803]||(s[803]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[805]||(s[805]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; force_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> force_value)</span></span></code></pre></div><p>Set up forces for a given model. Keyword arguments varies depending on what the model supports.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[804]||(s[804]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L881-L886",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Yt,[i("summary",null,[s[806]||(s[806]=i("a",{id:"Jutul.setup_parameter_optimization-Tuple{Any, Any, Any, Any, Any, Any, Vararg{Any}}",href:"#Jutul.setup_parameter_optimization-Tuple{Any, Any, Any, Any, Any, Any, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.setup_parameter_optimization")],-1)),s[807]||(s[807]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[809]||(s[809]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_parameter_optimization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, state0, param, dt, forces, G, opt_cfg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> optimization_config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, param);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    grad_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :adjoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    print </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    copy_case </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    param_obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up function handles for optimizing the case defined by the inputs to <code>simulate</code> together with a per-timestep objective function <code>G</code>. The objective function should fit the format described in <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.AbstractGlobalObjective">AbstractGlobalObjective</a> or <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.AbstractSumObjective">AbstractSumObjective</a>.</p><p>Generally calling either of the functions will mutate the data Dict. The options are:</p><ul><li><p><code>F_o(x)</code>: evaluate objective</p></li><li><p><code>dF_o(dFdx, x)</code>: evaluate gradient of objective, mutating <code>dFdx</code> (may trigger evaluation of <code>F_o</code>)</p></li><li><p><code>F_and_dF(F, dFdx, x)</code>: evaluate <code>F</code> and/or <code>dF</code>. If <code>nothing</code> is passed for an entry, the corresponding entry is skipped.</p></li></ul>`,4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[808]||(s[808]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/optimization.jl#L17-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",$t,[i("summary",null,[s[810]||(s[810]=i("a",{id:"Jutul.setup_parameters-Tuple{DataDomain, JutulModel}",href:"#Jutul.setup_parameters-Tuple{DataDomain, JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.setup_parameters")],-1)),s[811]||(s[811]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[813]||(s[813]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value)</span></span></code></pre></div><p>Set up a parameter storage for a given model with values for the parameter defined in the model.</p><p><strong>Arguments</strong></p><ul><li><code>name=value</code>: The name of the parameter together with the value(s) of the parameter.</li></ul><p>A scalar (or short vector of the right size for <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) will be repeated over the entire domain, while a vector (or matrix for <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) with length (number of columns for <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) equal to the entity count (for example, number of cells for a cell variable) will be used directly.</p>',5)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[812]||(s[812]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L291-L301",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Zt,[i("summary",null,[s[814]||(s[814]=i("a",{id:"Jutul.setup_partitioner_hypergraph-Tuple{Matrix{Int64}}",href:"#Jutul.setup_partitioner_hypergraph-Tuple{Matrix{Int64}}"},[i("span",{class:"jlbinding"},"Jutul.setup_partitioner_hypergraph")],-1)),s[815]||(s[815]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[817]||(s[817]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_partitioner_hypergraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Matrix{Int}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    num_nodes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> maximum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    num_edges</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(N, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    node_weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{Int}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Int, num_nodes),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    edge_weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{Int}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Int, num_edges),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    groups </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Int[]]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set up a hypergraph structure for a given neighborship matrix. <code>N</code> should be a matrix with two rows, with one pair of cells in each column. Optionally node and edge weights can be provided. If a list of groups are provided, these nodes will be accumulated together in the hypergraph.</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[816]||(s[816]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/partitioning.jl#L339-L352",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Xt,[i("summary",null,[s[818]||(s[818]=i("a",{id:"Jutul.setup_state!",href:"#Jutul.setup_state!"},[i("span",{class:"jlbinding"},"Jutul.setup_state!")],-1)),s[819]||(s[819]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[821]||(s[821]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_state!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, init_values</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDict</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Initialize primary variables and other state fields, given initial values as a Dict</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[820]||(s[820]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L252-L256",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Qt,[i("summary",null,[s[822]||(s[822]=i("a",{id:"Jutul.setup_state-Tuple{JutulModel, Vararg{Any}}",href:"#Jutul.setup_state-Tuple{JutulModel, Vararg{Any}}"},[i("span",{class:"jlbinding"},"Jutul.setup_state")],-1)),s[823]||(s[823]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[825]||(s[825]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value1, name2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value2)</span></span></code></pre></div><p>Set up a state for a given model with values for the primary variables defined in the model. Normally all primary variables must be initialized in this way.</p><p><strong>Arguments</strong></p><ul><li><code>name=value</code>: The name of the primary variable together with the value(s) used to initialize the primary variable.</li></ul><p>A scalar (or short vector of the right size for <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) will be repeated over the entire domain, while a vector (or matrix for <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) with length (number of columns for <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.VectorVariables"><code>VectorVariables</code></a>) equal to the entity count (for example, number of cells for a cell variable) will be used directly.</p><p>Note: You likely want to overload [<code>setup_state!</code>]@ref for a custom model instead of <code>setup_state</code></p>',6)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[824]||(s[824]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L224-L237",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",se,[i("summary",null,[s[826]||(s[826]=i("a",{id:"Jutul.setup_state_and_parameters-Tuple{DataDomain, JutulModel, AbstractDict}",href:"#Jutul.setup_state_and_parameters-Tuple{DataDomain, JutulModel, AbstractDict}"},[i("span",{class:"jlbinding"},"Jutul.setup_state_and_parameters")],-1)),s[827]||(s[827]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[829]||(s[829]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state, prm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state_and_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, init)</span></span></code></pre></div><p>Simultaneously set up state and parameters from a single <code>init</code> file (typically a <code>Dict</code> containing values that might either be initial values or parameters)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[828]||(s[828]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L325-L330",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ie,[i("summary",null,[s[830]||(s[830]=i("a",{id:"Jutul.setup_storage!-Tuple{Any, JutulModel}",href:"#Jutul.setup_storage!-Tuple{Any, JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.setup_storage!")],-1)),s[831]||(s[831]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[833]||(s[833]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_storage!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; setup_linearized_system </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                setup_equations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                tag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                state0_ad </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                state_ad </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                                kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Allocate storage for a given model. The storage consists of all dynamic quantities used in the simulation. The default implementation allocates properties, equations and linearized system.</p>`,2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[832]||(s[832]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L405-L417",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",te,[i("summary",null,[s[834]||(s[834]=i("a",{id:"Jutul.setup_storage-Tuple{JutulModel}",href:"#Jutul.setup_storage-Tuple{JutulModel}"},[i("span",{class:"jlbinding"},"Jutul.setup_storage")],-1)),s[835]||(s[835]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[837]||(s[837]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup_storage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Allocate storage for the model. You should overload setup_storage! if you have a custom definition.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[836]||(s[836]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L376-L381",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ee,[i("summary",null,[s[838]||(s[838]=i("a",{id:"Jutul.si_unit-Tuple{Symbol}",href:"#Jutul.si_unit-Tuple{Symbol}"},[i("span",{class:"jlbinding"},"Jutul.si_unit")],-1)),s[839]||(s[839]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[841]||(s[841]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">si_unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{String, Symbol}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the multiplicative SI unit conversion factor for a single unit. The return value is given so that <code>x*si_unit(:name)</code> will convert <code>x</code> to the SI representation of the unit with the given name.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> si_unit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:day</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get days represented as seconds</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">86400.0</span></span></code></pre></div>`,4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[840]||(s[840]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/units/interface.jl#L75-L87",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",le,[i("summary",null,[s[842]||(s[842]=i("a",{id:"Jutul.si_units-Tuple",href:"#Jutul.si_units-Tuple"},[i("span",{class:"jlbinding"},"Jutul.si_units")],-1)),s[843]||(s[843]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[845]||(s[845]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u1_val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> si_units</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u1)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> si_units</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:meter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meter, hour </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> si_units</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:meter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:hour</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get multiplicative SI unit conversion factors for multiple units simultaneously. The return value will be a <code>Tuple</code> of values, one for each input argument. Each input arguments can be either a <code>String</code> a <code>Symbol</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> meter, hour </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> si_units</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:meter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:hour</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3600.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[844]||(s[844]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/units/interface.jl#L56-L70",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ae,[i("summary",null,[s[846]||(s[846]=i("a",{id:"Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}",href:"#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.simulate!")],-1)),s[847]||(s[847]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[849]||(s[849]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, timesteps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    initialize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    restart </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Non-allocating (or perhaps less allocating) version of <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>initialize=true</code>: Perform internal updates as if this is the first time</li></ul><p>See also <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}"><code>simulate</code></a> for additional supported input arguments.</p>`,5)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[848]||(s[848]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/simulator.jl#L131-L148",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ne,[i("summary",null,[s[850]||(s[850]=i("a",{id:"Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}",href:"#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.simulate")],-1)),s[851]||(s[851]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[853]||(s[853]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state0, model, timesteps, parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state0, model, timesteps, info_level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state0, model, timesteps; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Simulate a set of <code>timesteps</code> with <code>model</code> for the given initial <code>state0</code> and optionally specific parameters. Additional keyword arguments are passed onto <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulator_config-Tuple{Any}"><code>simulator_config</code></a> and <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>. This interface is primarily for convenience, as all storage for the simulator is allocated upon use and discared upon return. If you want to perform multiple simulations with the same model it is advised to instead instantiate <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.Simulator-Tuple{Any}"><code>Simulator</code></a> and combine it with <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>state0::Dict</code>: initial state, typically created using <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.setup_state-Tuple{JutulModel, Vararg{Any}}"><code>setup_state</code></a> for the <code>model</code> in use.</p></li><li><p><code>model::JutulModel</code>: model that describes the discretized system to solve, for example <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.SimulationModel-Tuple{Any, Any}"><code>SimulationModel</code></a> or <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.MultiModel"><code>MultiModel</code></a>.</p></li><li><p><code>timesteps::AbstractVector</code>: Vector of desired report steps. The simulator will perform time integration until <code>sum(timesteps)</code> is reached, providing outputs at the end of each report step.</p></li><li><p><code>parameters=setup_parameters(model)</code>: Optional overrides the default parameters for the model.</p></li><li><p><code>forces=nothing</code>: Either <code>nothing</code> (for no forces), a single set of forces from <code>setup_forces(model)</code> or a <code>Vector</code> of such forces with equal length to <code>timesteps</code>.</p></li><li><p><code>restart=nothing</code>: If an integer is provided, the simulation will attempt to restart from that step. Requires that <code>output_path</code> is provided here or in the <code>config</code>.</p></li><li><p><code>config=simulator_config(model)</code>: Configuration <code>Dict</code> that holds many fine grained settings for output, linear solver, time-steps, outputs etc.</p></li></ul><p>Additional arguments are passed onto <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulator_config-Tuple{Any}"><code>simulator_config</code></a>.</p><p>See also <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>, <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.Simulator-Tuple{Any}"><code>Simulator</code></a>, <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.SimulationModel-Tuple{Any, Any}"><code>SimulationModel</code></a>, <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulator_config-Tuple{Any}"><code>simulator_config</code></a>.</p>`,6)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[852]||(s[852]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/simulator.jl#L84-L109",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",oe,[i("summary",null,[s[854]||(s[854]=i("a",{id:"Jutul.simulate-Tuple{Any, JutulSimulator, AbstractVector}",href:"#Jutul.simulate-Tuple{Any, JutulSimulator, AbstractVector}"},[i("span",{class:"jlbinding"},"Jutul.simulate")],-1)),s[855]||(s[855]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[857]||(s[857]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state0, sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulSimulator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, timesteps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Simulate a set of <code>timesteps</code> with <code>simulator</code> for the given initial <code>state0</code> and optionally specific parameters.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[856]||(s[856]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/simulator.jl#L120-L124",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",re,[i("summary",null,[s[858]||(s[858]=i("a",{id:"Jutul.simulator_config-Tuple{Any}",href:"#Jutul.simulator_config-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.simulator_config")],-1)),s[859]||(s[859]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[861]||(s[861]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">simulator_config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim; info_level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, linear_solver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GenericKrylov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Set up a simulator configuration object that can be passed onto <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulate!-Tuple{JutulSimulator, AbstractVector}"><code>simulate!</code></a>.</p><p>There are many options available to configure a given simulator. The best way to get an overview of these possible configuration options is to instatiate the config without any arguments and inspecting the resulting table by calling <code>simulator_config(sim)</code> in the REPL.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[860]||(s[860]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/config.jl#L96-L106",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",pe,[i("summary",null,[s[862]||(s[862]=i("a",{id:"Jutul.solve_adjoint_forces-Tuple{JutulCase, Any, Any}",href:"#Jutul.solve_adjoint_forces-Tuple{JutulCase, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.solve_adjoint_forces")],-1)),s[863]||(s[863]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[865]||(s[865]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solve_adjoint_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(case</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, G)</span></span></code></pre></div><p>Solve the adjoint equations for the forces in <code>case</code> given the simulation result <code>res</code> and the objective function <code>G</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[864]||(s[864]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/force_gradients.jl#L292-L297",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ue,[i("summary",null,[s[866]||(s[866]=i("a",{id:"Jutul.solve_adjoint_sensitivities!-NTuple{6, Any}",href:"#Jutul.solve_adjoint_sensitivities!-NTuple{6, Any}"},[i("span",{class:"jlbinding"},"Jutul.solve_adjoint_sensitivities!")],-1)),s[867]||(s[867]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[869]||(s[869]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solve_adjoint_sensitivities!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(∇G, storage, states, state0, timesteps, G; forces)</span></span></code></pre></div><p>Non-allocating version of <code>solve_adjoint_sensitivities</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[868]||(s[868]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/gradients.jl#L222-L226",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",de,[i("summary",null,[s[870]||(s[870]=i("a",{id:"Jutul.solve_adjoint_sensitivities-NTuple{4, Any}",href:"#Jutul.solve_adjoint_sensitivities-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.solve_adjoint_sensitivities")],-1)),s[871]||(s[871]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[873]||(s[873]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solve_adjoint_sensitivities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, states, reports_or_timesteps, G; extra_timing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model), forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model), raw_output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwarg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute sensitivities of <code>model</code> parameter with name <code>target</code> for objective function <code>G</code>.</p><p>The objective function is at the moment assumed to be a sum over all states on the form: <code>obj = Σₙ G(model, state, dt_n, n, forces_for_step_n)</code></p><p>Solves the adjoint equations: For model equations F the gradient with respect to parameters p is ∇ₚG = Σₙ (∂Fₙ / ∂p)ᵀ λₙ where n ∈ [1, N]. Given Lagrange multipliers λₙ from the adjoint equations (∂Fₙ / ∂xₙ)ᵀ λₙ = - (∂J / ∂xₙ)ᵀ - (∂Fₙ₊₁ / ∂xₙ)ᵀ λₙ₊₁ where the last term is omitted for step n = N and G is the objective function.</p>',4)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[872]||(s[872]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/gradients.jl#L3-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",he,[i("summary",null,[s[874]||(s[874]=i("a",{id:"Jutul.solve_numerical_sensitivities-NTuple{5, Any}",href:"#Jutul.solve_numerical_sensitivities-NTuple{5, Any}"},[i("span",{class:"jlbinding"},"Jutul.solve_numerical_sensitivities")],-1)),s[875]||(s[875]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[877]||(s[877]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solve_numerical_sensitivities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, states, reports, G, target;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                            forces </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_forces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                            state0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                            parameters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setup_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                            epsilon </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1e-8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute sensitivities of <code>model</code> parameter with name <code>target</code> for objective function <code>G</code>.</p><p>This method uses numerical perturbation and is primarily intended for testing of <code>solve_adjoint_sensitivities</code>.</p>`,3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[876]||(s[876]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/gradients.jl#L650-L660",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ke,[i("summary",null,[s[878]||(s[878]=i("a",{id:"Jutul.solve_timestep!-NTuple{5, Any}",href:"#Jutul.solve_timestep!-NTuple{5, Any}"},[i("span",{class:"jlbinding"},"Jutul.solve_timestep!")],-1)),s[879]||(s[879]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[881]||(s[881]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solve_timestep!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim, dT, forces, max_its, config; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Internal function for solving a single time-step with fixed driving forces.</p><p><strong>Arguments</strong></p><ul><li><p><code>sim</code>: <code>Simulator</code> instance.</p></li><li><p><code>dT</code>: time-step to be solved</p></li><li><p><code>forces</code>: Driving forces for the time-step</p></li><li><p><code>max_its</code>: Maximum number of steps/Newton iterations.</p></li><li><p><code>config</code>: Configuration for solver (typically output from <code>simulator_config</code>).</p></li></ul><p>Note: This function is exported for fine-grained simulation workflows. The general <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.simulate-Tuple{Any, JutulModel, AbstractVector}"><code>simulate</code></a> interface is both easier to use and performs additional validation.</p>',5)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[880]||(s[880]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/simulator/simulator.jl#L254-L268",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ge,[i("summary",null,[s[882]||(s[882]=i("a",{id:"Jutul.subvariable-Tuple{Any, Any}",href:"#Jutul.subvariable-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.subvariable")],-1)),s[883]||(s[883]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[885]||(s[885]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">subvariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(var, map)</span></span></code></pre></div><p>Get subvariable of Jutul variable</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[884]||(s[884]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/dd/submodels.jl#L144-L148",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ye,[i("summary",null,[s[886]||(s[886]=i("a",{id:"Jutul.successful_reports",href:"#Jutul.successful_reports"},[i("span",{class:"jlbinding"},"Jutul.successful_reports")],-1)),s[887]||(s[887]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[889]||(s[889]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">successful_reports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reports; step </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reports), n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get last n successful reports starting at the end of <code>step</code> and reversing backwards until <code>n</code> values have been found. <code>n</code> can be set to <code>Inf</code> to produce all successful reports.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[888]||(s[888]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/timesteps.jl#L211-L217",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ce,[i("summary",null,[s[890]||(s[890]=i("a",{id:"Jutul.successful_reports-2",href:"#Jutul.successful_reports-2"},[i("span",{class:"jlbinding"},"Jutul.successful_reports")],-1)),s[891]||(s[891]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[893]||(s[893]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">successful_reports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(old_reports, current_reports, step_index, n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the <code>n</code> last successful solve reports from all previous reports (old_reports) and the current ministep set. You can optionally provide a function that replaces the default definition of <code>success=r-&gt;r[:success]</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[892]||(s[892]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/timesteps.jl#L174-L180",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",be,[i("summary",null,[s[894]||(s[894]=i("a",{id:"Jutul.synchronize-Tuple{JutulContext}",href:"#Jutul.synchronize-Tuple{JutulContext}"},[i("span",{class:"jlbinding"},"Jutul.synchronize")],-1)),s[895]||(s[895]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[897]||(s[897]=i("p",null,"Synchronize backend after allocations.",-1)),s[898]||(s[898]=i("p",null,"Some backends may require notification that storage has been allocated.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[896]||(s[896]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/context.jl#L66-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",me,[i("summary",null,[s[899]||(s[899]=i("a",{id:"Jutul.tpfv_geometry",href:"#Jutul.tpfv_geometry"},[i("span",{class:"jlbinding"},"Jutul.tpfv_geometry")],-1)),s[900]||(s[900]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[902]||(s[902]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tpfv_geometry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g)</span></span></code></pre></div><p>Generate two-point finite-volume geometry for a given grid, if supported.</p><p>See also <a href="/JutulDarcy.jl/previews/PR177/ref/jutul#Jutul.TwoPointFiniteVolumeGeometry"><code>TwoPointFiniteVolumeGeometry</code></a>.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[901]||(s[901]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/meshes/meshes.jl#L10-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ee,[i("summary",null,[s[903]||(s[903]=i("a",{id:"Jutul.transfer-Tuple{Any, Any}",href:"#Jutul.transfer-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.transfer")],-1)),s[904]||(s[904]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[906]||(s[906]=i("p",null,"Transfer v to the representation expected by a given context.",-1)),s[907]||(s[907]=i("p",null,"For the defalt context, the transfer function does nothing. For other context such as the CUDA version, it may convert integers and floats to other types (e.g. Float32) and Arrays to CuArrays.",-1)),s[908]||(s[908]=i("p",null,"You will likely have to implement some transfer operators for your own types if you want to simulate with a non-default context.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[905]||(s[905]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/context.jl#L1-L10",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",fe,[i("summary",null,[s[909]||(s[909]=i("a",{id:"Jutul.two_point_potential_drop-NTuple{5, Real}",href:"#Jutul.two_point_potential_drop-NTuple{5, Real}"},[i("span",{class:"jlbinding"},"Jutul.two_point_potential_drop")],-1)),s[910]||(s[910]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[912]||(s[912]=i("p",null,"Two-point potential drop with gravity (generic)",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[911]||(s[911]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/conservation/flux.jl#L328-L330",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_e,[i("summary",null,[s[913]||(s[913]=i("a",{id:"Jutul.unsafe_reinterpret-Tuple{Any, Any, Any}",href:"#Jutul.unsafe_reinterpret-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.unsafe_reinterpret")],-1)),s[914]||(s[914]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[916]||(s[916]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unsafe_reinterpret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Vt, v, n)</span></span></code></pre></div><p>Unsafely reinterpret v as a n length vector of value type Vt</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[915]||(s[915]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/linsolve/utils.jl#L95-L99",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",je,[i("summary",null,[s[917]||(s[917]=i("a",{id:"Jutul.update_before_step!-NTuple{4, Any}",href:"#Jutul.update_before_step!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_before_step!")],-1)),s[918]||(s[918]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[919]||(s[919]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L940-L942",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ve,[i("summary",null,[s[920]||(s[920]=i("a",{id:"Jutul.update_equation!-Tuple{Any, JutulEquation, Any, Any, Any}",href:"#Jutul.update_equation!-Tuple{Any, JutulEquation, Any, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_equation!")],-1)),s[921]||(s[921]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[923]||(s[923]=i("p",null,"Update equation based on currently stored properties",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[922]||(s[922]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L519-L521",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ce,[i("summary",null,[s[924]||(s[924]=i("a",{id:"Jutul.update_equations!",href:"#Jutul.update_equations!"},[i("span",{class:"jlbinding"},"Jutul.update_equations!")],-1)),s[925]||(s[925]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[927]||(s[927]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_equations!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model, dt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Update the governing equations using the current set of primary variables, parameters and secondary variables. Does not fill linearized system.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[926]||(s[926]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L715-L719",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Te,[i("summary",null,[s[928]||(s[928]=i("a",{id:"Jutul.update_equations_and_apply_forces!-NTuple{4, Any}",href:"#Jutul.update_equations_and_apply_forces!-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_equations_and_apply_forces!")],-1)),s[929]||(s[929]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[931]||(s[931]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_equations_and_apply_forces!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model, dt, forces; time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NaN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Update the model equations and apply boundary conditions and forces. Does not fill linearized system.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[930]||(s[930]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L697-L701",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Fe,[i("summary",null,[s[932]||(s[932]=i("a",{id:"Jutul.update_linearized_system!",href:"#Jutul.update_linearized_system!"},[i("span",{class:"jlbinding"},"Jutul.update_linearized_system!")],-1)),s[933]||(s[933]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[935]||(s[935]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_linearized_system!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JutulModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keyword arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Update the linearized system with the current set of equations.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[934]||(s[934]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L730-L734",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ae,[i("summary",null,[s[936]||(s[936]=i("a",{id:"Jutul.update_linearized_system_equation!-Tuple{AbstractArray, Any, Any, JutulEquation, CompactAutoDiffCache}",href:"#Jutul.update_linearized_system_equation!-Tuple{AbstractArray, Any, Any, JutulEquation, CompactAutoDiffCache}"},[i("span",{class:"jlbinding"},"Jutul.update_linearized_system_equation!")],-1)),s[937]||(s[937]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[939]||(s[939]=i("p",null,"Update a linearized system based on the values and derivatives in the equation.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[938]||(s[938]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/equations.jl#L497-L499",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Je,[i("summary",null,[s[940]||(s[940]=i("a",{id:"Jutul.update_parameter_before_step!-NTuple{6, Any}",href:"#Jutul.update_parameter_before_step!-NTuple{6, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_parameter_before_step!")],-1)),s[941]||(s[941]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[943]||(s[943]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_parameter_before_step!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prm_val, prm, storage, model, dt, forces)</span></span></code></pre></div><p>Update parameters before time-step. Used for hysteretic parameters.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[942]||(s[942]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L986-L990",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",xe,[i("summary",null,[s[944]||(s[944]=i("a",{id:"Jutul.update_secondary_variable!",href:"#Jutul.update_secondary_variable!"},[i("span",{class:"jlbinding"},"Jutul.update_secondary_variable!")],-1)),s[945]||(s[945]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[947]||(s[947]=i("p",null,"Update a secondary variable. Normally autogenerated with @jutul_secondary",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[946]||(s[946]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variable_evaluation.jl#L207-L209",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",De,[i("summary",null,[s[948]||(s[948]=i("a",{id:"Jutul.update_state_dependents!-Tuple{Any, JutulModel, Any, Any}",href:"#Jutul.update_state_dependents!-Tuple{Any, JutulModel, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.update_state_dependents!")],-1)),s[949]||(s[949]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[951]||(s[951]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_state_dependents!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(storage, model, dt, forces; time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NaN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, update_secondary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Perform updates of everything that depends on the state: A full linearization for the current primary variables.</p><p>This includes properties, governing equations and the linearized system itself.</p>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[950]||(s[950]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/models.jl#L681-L687",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Se,[i("summary",null,[s[952]||(s[952]=i("a",{id:"Jutul.update_values!-Tuple{AbstractArray, AbstractArray}",href:"#Jutul.update_values!-Tuple{AbstractArray, AbstractArray}"},[i("span",{class:"jlbinding"},"Jutul.update_values!")],-1)),s[953]||(s[953]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[955]||(s[955]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_values!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, dx)</span></span></code></pre></div><p>Replace values (for non-Real types, direct assignment)</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[954]||(s[954]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L410-L414",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Me,[i("summary",null,[s[956]||(s[956]=i("a",{id:"Jutul.update_values!-Union{Tuple{Tag}, Tuple{AbstractArray{<:ForwardDiff.Dual{Tag}}, AbstractArray{<:Real}}} where Tag",href:"#Jutul.update_values!-Union{Tuple{Tag}, Tuple{AbstractArray{<:ForwardDiff.Dual{Tag}}, AbstractArray{<:Real}}} where Tag"},[i("span",{class:"jlbinding"},"Jutul.update_values!")],-1)),s[957]||(s[957]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[959]||(s[959]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update_values!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, dx)</span></span></code></pre></div><p>Replace values of <code>x</code> in-place by <code>y</code>, leaving <code>x</code> with the values of y and the partials of <code>x</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[958]||(s[958]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L388-L392",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Be,[i("summary",null,[s[960]||(s[960]=i("a",{id:"Jutul.value-Tuple{AbstractDict}",href:"#Jutul.value-Tuple{AbstractDict}"},[i("span",{class:"jlbinding"},"Jutul.value")],-1)),s[961]||(s[961]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[963]||(s[963]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Call value on all elements of some Dict.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[962]||(s[962]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L464-L467",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Le,[i("summary",null,[s[964]||(s[964]=i("a",{id:"Jutul.value-Union{Tuple{ForwardDiff.Dual{T, V, N}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}",href:"#Jutul.value-Union{Tuple{ForwardDiff.Dual{T, V, N}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}"},[i("span",{class:"jlbinding"},"Jutul.value")],-1)),s[965]||(s[965]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[967]||(s[967]=i("p",null,"Take value of AD.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[966]||(s[966]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ad/ad.jl#L436-L438",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ve,[i("summary",null,[s[968]||(s[968]=i("a",{id:"Jutul.values_per_entity-Tuple{Any, JutulVariables}",href:"#Jutul.values_per_entity-Tuple{Any, JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.values_per_entity")],-1)),s[969]||(s[969]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[971]||(s[971]=i("p",null,"Number of values held by a primary variable. Normally this is equal to the number of degrees of freedom, but some special primary variables are most conveniently defined by having N values and N-1 independent variables.",-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[970]||(s[970]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L79-L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",we,[i("summary",null,[s[972]||(s[972]=i("a",{id:"Jutul.variable_scale-Tuple{JutulVariables}",href:"#Jutul.variable_scale-Tuple{JutulVariables}"},[i("span",{class:"jlbinding"},"Jutul.variable_scale")],-1)),s[973]||(s[973]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[975]||(s[975]=i("p",null,'Define a "typical" numerical value for a variable to scale the linear system entries.',-1)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[974]||(s[974]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variables/utils.jl#L190-L192",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Pe,[i("summary",null,[s[976]||(s[976]=i("a",{id:"Jutul.write_reports_to_mat_format",href:"#Jutul.write_reports_to_mat_format"},[i("span",{class:"jlbinding"},"Jutul.write_reports_to_mat_format")],-1)),s[977]||(s[977]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[979]||(s[979]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write_reports_to_mat_format</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> jutul_output_path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;report&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> missing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, verbose </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Write the reports to MAT files named &quot;report_1&quot;, &quot;report_2&quot;, ... to the given path.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[978]||(s[978]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/utils.jl#L1098-L1102",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ie,[i("summary",null,[s[980]||(s[980]=i("a",{id:"Jutul.@jutul_secondary-Tuple{Any}",href:"#Jutul.@jutul_secondary-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.@jutul_secondary")],-1)),s[981]||(s[981]=l()),e(t,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),s[983]||(s[983]=n(`<p>Designate the function as updating a secondary variable.</p><p>A generic evaluator is then defined, together with a function for getting the dependencies of that function upon the state. This is most easily documented with an example. If we define the following function annotated with the macro when updating the array containing the values of <code>MyVarType</code> realized for some model:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@jutul_secondary</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> some_fn!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyVarType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model, a, b, c, ix)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ix</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c[i]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The purpose of the macro is to translate this into two functions. The first defines for the dependencies of the function with respect to the fields of the state (primary variables, secondary variables and parameters):</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyVarType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The second function defines a generic version that takes in state, and automatically expands the set of dependencies into <code>getfield</code> calls.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> update_secondary_variable!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array_target, var</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyVarType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model, state, ix)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    some_fn!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array_target, var, model, state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a, state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b, state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c, ix)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>Note that the input names of arguments 4 to end-1 matter, as these will be fetched from state, exactly as written.</p>`,8)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[982]||(s[982]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/variable_evaluation.jl#L4-L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Oe,[i("summary",null,[s[984]||(s[984]=i("a",{id:"Jutul.ConvergenceMonitors.ConvergenceMonitorRelaxation-Tuple{}",href:"#Jutul.ConvergenceMonitors.ConvergenceMonitorRelaxation-Tuple{}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.ConvergenceMonitorRelaxation")],-1)),s[985]||(s[985]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[987]||(s[987]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConvergenceMonitorRelaxation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; w_min </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dw_increase </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dw_decrease </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, w_max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Relaxation strategy based on convergence monitoring. Requires that the simulation has been configured with a <code>ConvergenceMonitorCuttingCriterion</code> so that the convergence status is available in the reports. See corresponding iplementation of <code>select_nonlinear_relaxation_model</code> below for details.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[986]||(s[986]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/relaxation.jl#L8-L15",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ne,[i("summary",null,[s[988]||(s[988]=i("a",{id:"Jutul.ConvergenceMonitors.compute_contraction_factor-Tuple{Any, Any}",href:"#Jutul.ConvergenceMonitors.compute_contraction_factor-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.compute_contraction_factor")],-1)),s[989]||(s[989]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[991]||(s[991]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_contraction_factor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, N)</span></span></code></pre></div><p>Compute contraction factor from a number of Newton iterate distances from convergence (defined with a user-prescribed distance metric). For more than two iterates, the contraction factor is estimated using least-squares assuming the iterates follow a geometric series: rₙ = Θⁿr₀. The function also computes the target contraction factor under this assumption assuming N iterations left.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[990]||(s[990]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/contraction_factors.jl#L1-L9",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Re,[i("summary",null,[s[992]||(s[992]=i("a",{id:"Jutul.ConvergenceMonitors.compute_distance-Tuple{Any}",href:"#Jutul.ConvergenceMonitors.compute_distance-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.compute_distance")],-1)),s[993]||(s[993]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[995]||(s[995]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(report; distance_function </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> scaled_residual_norm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r), mapping </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> maximum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v))</span></span></code></pre></div><p>Compute distance from convergence using a user-defined distance function, and optionally apply a mapping to the distance. The function returns the distance and the names of equation residual norms used in the distance computation.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[994]||(s[994]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/distance_functions.jl#L1-L7",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",qe,[i("summary",null,[s[996]||(s[996]=i("a",{id:"Jutul.ConvergenceMonitors.flatten_dict",href:"#Jutul.ConvergenceMonitors.flatten_dict"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.flatten_dict")],-1)),s[997]||(s[997]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[999]||(s[999]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flatten_dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input_dict</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, separator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, trail </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [])</span></span></code></pre></div><p>Flatten a dict of dicts into a vector of values and a vector of names. The names are on the format <code>&quot;key1&lt;separator&gt;key2&lt;separator&gt;key3&quot;</code> and the values are the corresponding values in the dict.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[998]||(s[998]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/utils.jl#L87-L93",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ze,[i("summary",null,[s[1e3]||(s[1e3]=i("a",{id:"Jutul.ConvergenceMonitors.get_model_residuals-Tuple{Any}",href:"#Jutul.ConvergenceMonitors.get_model_residuals-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.get_model_residuals")],-1)),s[1001]||(s[1001]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1003]||(s[1003]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_model_residuals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(report)</span></span></code></pre></div><p>Get all residual norms for all equations of a model from a nonlinear iteration report, scaled by their respective toelrances. The function returns a dict of dicts with the residual norms for each equation on the form</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>residuals[equation_type][equation][norm] = res/tol</span></span></code></pre></div>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1002]||(s[1002]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/utils.jl#L27-L36",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ge,[i("summary",null,[s[1004]||(s[1004]=i("a",{id:"Jutul.ConvergenceMonitors.get_multimodel_residuals-Tuple{Any}",href:"#Jutul.ConvergenceMonitors.get_multimodel_residuals-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.get_multimodel_residuals")],-1)),s[1005]||(s[1005]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1007]||(s[1007]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_multimodel_residuals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(report)</span></span></code></pre></div><p>Get all residual norms for all equations of all models from a nonlinear iteration report, scaled by their respective toelrances. The function returns a dict of dicts with the residual norms for each equation on the form</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>residuals[model][equation_type][equation][norm] = res/tol</span></span></code></pre></div>',3)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1006]||(s[1006]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/utils.jl#L3-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ue,[i("summary",null,[s[1008]||(s[1008]=i("a",{id:"Jutul.ConvergenceMonitors.make_report-NTuple{4, Any}",href:"#Jutul.ConvergenceMonitors.make_report-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.make_report")],-1)),s[1009]||(s[1009]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1011]||(s[1011]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">make_report</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ, θ_target, oscillation, status)</span></span></code></pre></div><p>Utility for generating a report from the convergence monitor.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1010]||(s[1010]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/cutting_criterions.jl#L153-L157",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",We,[i("summary",null,[s[1012]||(s[1012]=i("a",{id:"Jutul.ConvergenceMonitors.nonconverged_equations-Tuple{Any}",href:"#Jutul.ConvergenceMonitors.nonconverged_equations-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.nonconverged_equations")],-1)),s[1013]||(s[1013]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1015]||(s[1015]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nonconverged_equations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(report)</span></span></code></pre></div><p>Compute distance to convergence as non-converged equations, e.g., 1.0 for non-converged and 0.0 for converged. The final distance is typically taken as the sum of the output from this function.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1014]||(s[1014]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/distance_functions.jl#L38-L44",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",He,[i("summary",null,[s[1016]||(s[1016]=i("a",{id:"Jutul.ConvergenceMonitors.oscillation",href:"#Jutul.ConvergenceMonitors.oscillation"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.oscillation")],-1)),s[1017]||(s[1017]=l()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[1019]||(s[1019]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">oscillation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(contraction_factors, tol)</span></span></code></pre></div><p>Check if the contraction factors are oscillating. The function checks if the contraction factors are oscillating by checking if the last three contraction factors are below a user-defined tolerance defining &quot;slow&quot; convergece. The function returns true if the contraction factors are oscillating, and false otherwise. If less than three contraction factors are provided, the function returns false.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1018]||(s[1018]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/contraction_factors.jl#L27-L36",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ke,[i("summary",null,[s[1020]||(s[1020]=i("a",{id:"Jutul.ConvergenceMonitors.print_convergence_status-Tuple{Jutul.ConvergenceMonitors.ConvergenceMonitorCuttingCriterion, Any, Any}",href:"#Jutul.ConvergenceMonitors.print_convergence_status-Tuple{Jutul.ConvergenceMonitors.ConvergenceMonitorCuttingCriterion, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.print_convergence_status")],-1)),s[1021]||(s[1021]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1023]||(s[1023]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print_convergence_status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConvergenceMonitorCuttingCriterion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, it, it0)</span></span></code></pre></div><p>Utility for printing the status of the convergence monitor.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1022]||(s[1022]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/cutting_criterions.jl#L169-L173",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ye,[i("summary",null,[s[1024]||(s[1024]=i("a",{id:"Jutul.ConvergenceMonitors.process_name-Tuple{Any}",href:"#Jutul.ConvergenceMonitors.process_name-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.process_name")],-1)),s[1025]||(s[1025]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1027]||(s[1027]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">process_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name)</span></span></code></pre></div><p>Process a names to be suibale as dictionary keys.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1026]||(s[1026]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/utils.jl#L74-L78",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",$e,[i("summary",null,[s[1028]||(s[1028]=i("a",{id:"Jutul.ConvergenceMonitors.reset!-Tuple{Jutul.ConvergenceMonitors.ConvergenceMonitorCuttingCriterion, Any, Any}",href:"#Jutul.ConvergenceMonitors.reset!-Tuple{Jutul.ConvergenceMonitors.ConvergenceMonitorCuttingCriterion, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.reset!")],-1)),s[1029]||(s[1029]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1031]||(s[1031]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reset!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConvergenceMonitorCuttingCriterion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, template, max_iter)</span></span></code></pre></div><p>Utility for resetting convergence monitor cutting criterion.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1030]||(s[1030]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/cutting_criterions.jl#L124-L128",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Ze,[i("summary",null,[s[1032]||(s[1032]=i("a",{id:"Jutul.ConvergenceMonitors.scaled_residual_norm-Tuple{Any}",href:"#Jutul.ConvergenceMonitors.scaled_residual_norm-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.scaled_residual_norm")],-1)),s[1033]||(s[1033]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1035]||(s[1035]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scaled_residual_norm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(report)</span></span></code></pre></div><p>Compute distance to convergence as the residual norm of the equations scaled by their respective tolerances.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1034]||(s[1034]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/distance_functions.jl#L22-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Xe,[i("summary",null,[s[1036]||(s[1036]=i("a",{id:"Jutul.ConvergenceMonitors.set_convergence_monitor_cutting_criterion!-Tuple{Any}",href:"#Jutul.ConvergenceMonitors.set_convergence_monitor_cutting_criterion!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.set_convergence_monitor_cutting_criterion!")],-1)),s[1037]||(s[1037]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1039]||(s[1039]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_convergence_monitor_cutting_criterion!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(config; max_nonlinear_iterations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Utility for setting <code>ConvergenceMonitorCuttingCriterion</code> to the simulator config. The function also adjusts the maximum number of nonlinear iterations (to 50 by default).</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1038]||(s[1038]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/cutting_criterions.jl#L22-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Qe,[i("summary",null,[s[1040]||(s[1040]=i("a",{id:"Jutul.ConvergenceMonitors.set_convergence_monitor_relaxation!-Tuple{Any}",href:"#Jutul.ConvergenceMonitors.set_convergence_monitor_relaxation!-Tuple{Any}"},[i("span",{class:"jlbinding"},"Jutul.ConvergenceMonitors.set_convergence_monitor_relaxation!")],-1)),s[1041]||(s[1041]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1043]||(s[1043]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_convergence_monitor_relaxation!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(config; max_nonlinear_iterations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, convergence_monitor_args </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), relaxation_args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Utility for setting <code>ConvergenceMonitorRelaxation</code> to the simulator config. This function also sets the a <code>ConvergenceMonitorCuttingCriterion</code> to the config – see <code>set_convergence_monitor_cutting_criterion!</code>.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1042]||(s[1042]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/relaxation.jl#L26-L32",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",sl,[i("summary",null,[s[1044]||(s[1044]=i("a",{id:"Jutul.cutting_criterion-Tuple{Jutul.ConvergenceMonitors.ConvergenceMonitorCuttingCriterion, Vararg{Any, 9}}",href:"#Jutul.cutting_criterion-Tuple{Jutul.ConvergenceMonitors.ConvergenceMonitorCuttingCriterion, Vararg{Any, 9}}"},[i("span",{class:"jlbinding"},"Jutul.cutting_criterion")],-1)),s[1045]||(s[1045]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1047]||(s[1047]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Jutul</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cutting_criterion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConvergenceMonitorCuttingCriterion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sim, dt, forces, it, max_iter, cfg, e, step_reports, relaxation)</span></span></code></pre></div><p>Cutting ctriterion based on monitoring convergence. The function computes the contraction factor from the distance to convergence (in a user-defined metric) between consecutive iterates. The function also computes the target contraction factor under the assumption that the iterates follow a geometric series, and checks if the iterates are oscillating. Based on this, the iterate is classified as &quot;good&quot;, &quot;ok&quot;, or &quot;bad&quot;, and a counter for number of violations is updated accordingly (+1 for &quot;bad&quot;, -1 for &quot;good&quot;). The timestep is aborted if the number of violations exceeds a user-defined limit.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1046]||(s[1046]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/cutting_criterions.jl#L45-L56",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",il,[i("summary",null,[s[1048]||(s[1048]=i("a",{id:"Jutul.select_nonlinear_relaxation_model-Tuple{Any, Jutul.ConvergenceMonitors.ConvergenceMonitorRelaxation, Any, Any}",href:"#Jutul.select_nonlinear_relaxation_model-Tuple{Any, Jutul.ConvergenceMonitors.ConvergenceMonitorRelaxation, Any, Any}"},[i("span",{class:"jlbinding"},"Jutul.select_nonlinear_relaxation_model")],-1)),s[1049]||(s[1049]=l()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[1051]||(s[1051]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Jutul</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">select_nonlinear_relaxation_model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model, rel_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConvergenceMonitorRelaxation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reports, ω)</span></span></code></pre></div><p>Relaxation strategy based on convergence monitoring. The relaxation factor is decreased if the convergence status is &quot;bad&quot;, and increased if the status is &quot;good&quot;, determined by contraction factors computed from distance to convergence (in a user-defined metric) between consecutive iterates. These are computed during the cutting criterion check and stored in the reports.</p>',2)),e(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>[...s[1050]||(s[1050]=[i("a",{href:"https://github.com/sintefmath/Jutul.jl/blob/v0.4.7/src/ConvergenceMonitors/relaxation.jl#L48-L56",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const ul=o(d,[["render",tl]]);export{pl as __pageData,ul as default};
